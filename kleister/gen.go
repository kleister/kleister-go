// Package kleister provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package kleister

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicScopes  = "Basic.Scopes"
	BearerScopes = "Bearer.Scopes"
	HeaderScopes = "Header.Scopes"
)

// Defines values for GroupModPerm.
const (
	GroupModPermAdmin GroupModPerm = "admin"
	GroupModPermOwner GroupModPerm = "owner"
	GroupModPermUser  GroupModPerm = "user"
)

var (
	// ErrGroupModPerm defines an error if an invalid value gets mapped.
	ErrGroupModPerm = fmt.Errorf("invalid type for GroupModPerm")

	stringToGroupModPerm = map[string]GroupModPerm{
		"admin": GroupModPermAdmin,
		"owner": GroupModPermOwner,
		"user":  GroupModPermUser,
	}
)

// ToGroupModPerm acts as a helper to map a string to the defined enum.
func ToGroupModPerm(val string) (GroupModPerm, error) {
	if res, ok := stringToGroupModPerm[val]; ok {
		return res, nil
	}

	return GroupModPerm(""), ErrGroupModPerm
}

// Defines values for GroupPackPerm.
const (
	GroupPackPermAdmin GroupPackPerm = "admin"
	GroupPackPermOwner GroupPackPerm = "owner"
	GroupPackPermUser  GroupPackPerm = "user"
)

var (
	// ErrGroupPackPerm defines an error if an invalid value gets mapped.
	ErrGroupPackPerm = fmt.Errorf("invalid type for GroupPackPerm")

	stringToGroupPackPerm = map[string]GroupPackPerm{
		"admin": GroupPackPermAdmin,
		"owner": GroupPackPermOwner,
		"user":  GroupPackPermUser,
	}
)

// ToGroupPackPerm acts as a helper to map a string to the defined enum.
func ToGroupPackPerm(val string) (GroupPackPerm, error) {
	if res, ok := stringToGroupPackPerm[val]; ok {
		return res, nil
	}

	return GroupPackPerm(""), ErrGroupPackPerm
}

// Defines values for UserGroupPerm.
const (
	UserGroupPermAdmin UserGroupPerm = "admin"
	UserGroupPermOwner UserGroupPerm = "owner"
	UserGroupPermUser  UserGroupPerm = "user"
)

var (
	// ErrUserGroupPerm defines an error if an invalid value gets mapped.
	ErrUserGroupPerm = fmt.Errorf("invalid type for UserGroupPerm")

	stringToUserGroupPerm = map[string]UserGroupPerm{
		"admin": UserGroupPermAdmin,
		"owner": UserGroupPermOwner,
		"user":  UserGroupPermUser,
	}
)

// ToUserGroupPerm acts as a helper to map a string to the defined enum.
func ToUserGroupPerm(val string) (UserGroupPerm, error) {
	if res, ok := stringToUserGroupPerm[val]; ok {
		return res, nil
	}

	return UserGroupPerm(""), ErrUserGroupPerm
}

// Defines values for UserModPerm.
const (
	UserModPermAdmin UserModPerm = "admin"
	UserModPermOwner UserModPerm = "owner"
	UserModPermUser  UserModPerm = "user"
)

var (
	// ErrUserModPerm defines an error if an invalid value gets mapped.
	ErrUserModPerm = fmt.Errorf("invalid type for UserModPerm")

	stringToUserModPerm = map[string]UserModPerm{
		"admin": UserModPermAdmin,
		"owner": UserModPermOwner,
		"user":  UserModPermUser,
	}
)

// ToUserModPerm acts as a helper to map a string to the defined enum.
func ToUserModPerm(val string) (UserModPerm, error) {
	if res, ok := stringToUserModPerm[val]; ok {
		return res, nil
	}

	return UserModPerm(""), ErrUserModPerm
}

// Defines values for UserPackPerm.
const (
	UserPackPermAdmin UserPackPerm = "admin"
	UserPackPermOwner UserPackPerm = "owner"
	UserPackPermUser  UserPackPerm = "user"
)

var (
	// ErrUserPackPerm defines an error if an invalid value gets mapped.
	ErrUserPackPerm = fmt.Errorf("invalid type for UserPackPerm")

	stringToUserPackPerm = map[string]UserPackPerm{
		"admin": UserPackPermAdmin,
		"owner": UserPackPermOwner,
		"user":  UserPackPermUser,
	}
)

// ToUserPackPerm acts as a helper to map a string to the defined enum.
func ToUserPackPerm(val string) (UserPackPerm, error) {
	if res, ok := stringToUserPackPerm[val]; ok {
		return res, nil
	}

	return UserPackPerm(""), ErrUserPackPerm
}

// Defines values for SortOrderParam.
const (
	SortOrderParamAsc  SortOrderParam = "asc"
	SortOrderParamDesc SortOrderParam = "desc"
)

var (
	// ErrSortOrderParam defines an error if an invalid value gets mapped.
	ErrSortOrderParam = fmt.Errorf("invalid type for SortOrderParam")

	stringToSortOrderParam = map[string]SortOrderParam{
		"asc":  SortOrderParamAsc,
		"desc": SortOrderParamDesc,
	}
)

// ToSortOrderParam acts as a helper to map a string to the defined enum.
func ToSortOrderParam(val string) (SortOrderParam, error) {
	if res, ok := stringToSortOrderParam[val]; ok {
		return res, nil
	}

	return SortOrderParam(""), ErrSortOrderParam
}

// Defines values for ListFabricBuildsParamsOrder.
const (
	ListFabricBuildsParamsOrderAsc  ListFabricBuildsParamsOrder = "asc"
	ListFabricBuildsParamsOrderDesc ListFabricBuildsParamsOrder = "desc"
)

var (
	// ErrListFabricBuildsParamsOrder defines an error if an invalid value gets mapped.
	ErrListFabricBuildsParamsOrder = fmt.Errorf("invalid type for ListFabricBuildsParamsOrder")

	stringToListFabricBuildsParamsOrder = map[string]ListFabricBuildsParamsOrder{
		"asc":  ListFabricBuildsParamsOrderAsc,
		"desc": ListFabricBuildsParamsOrderDesc,
	}
)

// ToListFabricBuildsParamsOrder acts as a helper to map a string to the defined enum.
func ToListFabricBuildsParamsOrder(val string) (ListFabricBuildsParamsOrder, error) {
	if res, ok := stringToListFabricBuildsParamsOrder[val]; ok {
		return res, nil
	}

	return ListFabricBuildsParamsOrder(""), ErrListFabricBuildsParamsOrder
}

// Defines values for ListForgeBuildsParamsOrder.
const (
	ListForgeBuildsParamsOrderAsc  ListForgeBuildsParamsOrder = "asc"
	ListForgeBuildsParamsOrderDesc ListForgeBuildsParamsOrder = "desc"
)

var (
	// ErrListForgeBuildsParamsOrder defines an error if an invalid value gets mapped.
	ErrListForgeBuildsParamsOrder = fmt.Errorf("invalid type for ListForgeBuildsParamsOrder")

	stringToListForgeBuildsParamsOrder = map[string]ListForgeBuildsParamsOrder{
		"asc":  ListForgeBuildsParamsOrderAsc,
		"desc": ListForgeBuildsParamsOrderDesc,
	}
)

// ToListForgeBuildsParamsOrder acts as a helper to map a string to the defined enum.
func ToListForgeBuildsParamsOrder(val string) (ListForgeBuildsParamsOrder, error) {
	if res, ok := stringToListForgeBuildsParamsOrder[val]; ok {
		return res, nil
	}

	return ListForgeBuildsParamsOrder(""), ErrListForgeBuildsParamsOrder
}

// Defines values for ListGroupsParamsOrder.
const (
	ListGroupsParamsOrderAsc  ListGroupsParamsOrder = "asc"
	ListGroupsParamsOrderDesc ListGroupsParamsOrder = "desc"
)

var (
	// ErrListGroupsParamsOrder defines an error if an invalid value gets mapped.
	ErrListGroupsParamsOrder = fmt.Errorf("invalid type for ListGroupsParamsOrder")

	stringToListGroupsParamsOrder = map[string]ListGroupsParamsOrder{
		"asc":  ListGroupsParamsOrderAsc,
		"desc": ListGroupsParamsOrderDesc,
	}
)

// ToListGroupsParamsOrder acts as a helper to map a string to the defined enum.
func ToListGroupsParamsOrder(val string) (ListGroupsParamsOrder, error) {
	if res, ok := stringToListGroupsParamsOrder[val]; ok {
		return res, nil
	}

	return ListGroupsParamsOrder(""), ErrListGroupsParamsOrder
}

// Defines values for ListGroupModsParamsOrder.
const (
	ListGroupModsParamsOrderAsc  ListGroupModsParamsOrder = "asc"
	ListGroupModsParamsOrderDesc ListGroupModsParamsOrder = "desc"
)

var (
	// ErrListGroupModsParamsOrder defines an error if an invalid value gets mapped.
	ErrListGroupModsParamsOrder = fmt.Errorf("invalid type for ListGroupModsParamsOrder")

	stringToListGroupModsParamsOrder = map[string]ListGroupModsParamsOrder{
		"asc":  ListGroupModsParamsOrderAsc,
		"desc": ListGroupModsParamsOrderDesc,
	}
)

// ToListGroupModsParamsOrder acts as a helper to map a string to the defined enum.
func ToListGroupModsParamsOrder(val string) (ListGroupModsParamsOrder, error) {
	if res, ok := stringToListGroupModsParamsOrder[val]; ok {
		return res, nil
	}

	return ListGroupModsParamsOrder(""), ErrListGroupModsParamsOrder
}

// Defines values for ListGroupPacksParamsOrder.
const (
	ListGroupPacksParamsOrderAsc  ListGroupPacksParamsOrder = "asc"
	ListGroupPacksParamsOrderDesc ListGroupPacksParamsOrder = "desc"
)

var (
	// ErrListGroupPacksParamsOrder defines an error if an invalid value gets mapped.
	ErrListGroupPacksParamsOrder = fmt.Errorf("invalid type for ListGroupPacksParamsOrder")

	stringToListGroupPacksParamsOrder = map[string]ListGroupPacksParamsOrder{
		"asc":  ListGroupPacksParamsOrderAsc,
		"desc": ListGroupPacksParamsOrderDesc,
	}
)

// ToListGroupPacksParamsOrder acts as a helper to map a string to the defined enum.
func ToListGroupPacksParamsOrder(val string) (ListGroupPacksParamsOrder, error) {
	if res, ok := stringToListGroupPacksParamsOrder[val]; ok {
		return res, nil
	}

	return ListGroupPacksParamsOrder(""), ErrListGroupPacksParamsOrder
}

// Defines values for ListGroupUsersParamsOrder.
const (
	ListGroupUsersParamsOrderAsc  ListGroupUsersParamsOrder = "asc"
	ListGroupUsersParamsOrderDesc ListGroupUsersParamsOrder = "desc"
)

var (
	// ErrListGroupUsersParamsOrder defines an error if an invalid value gets mapped.
	ErrListGroupUsersParamsOrder = fmt.Errorf("invalid type for ListGroupUsersParamsOrder")

	stringToListGroupUsersParamsOrder = map[string]ListGroupUsersParamsOrder{
		"asc":  ListGroupUsersParamsOrderAsc,
		"desc": ListGroupUsersParamsOrderDesc,
	}
)

// ToListGroupUsersParamsOrder acts as a helper to map a string to the defined enum.
func ToListGroupUsersParamsOrder(val string) (ListGroupUsersParamsOrder, error) {
	if res, ok := stringToListGroupUsersParamsOrder[val]; ok {
		return res, nil
	}

	return ListGroupUsersParamsOrder(""), ErrListGroupUsersParamsOrder
}

// Defines values for ListMinecraftBuildsParamsOrder.
const (
	ListMinecraftBuildsParamsOrderAsc  ListMinecraftBuildsParamsOrder = "asc"
	ListMinecraftBuildsParamsOrderDesc ListMinecraftBuildsParamsOrder = "desc"
)

var (
	// ErrListMinecraftBuildsParamsOrder defines an error if an invalid value gets mapped.
	ErrListMinecraftBuildsParamsOrder = fmt.Errorf("invalid type for ListMinecraftBuildsParamsOrder")

	stringToListMinecraftBuildsParamsOrder = map[string]ListMinecraftBuildsParamsOrder{
		"asc":  ListMinecraftBuildsParamsOrderAsc,
		"desc": ListMinecraftBuildsParamsOrderDesc,
	}
)

// ToListMinecraftBuildsParamsOrder acts as a helper to map a string to the defined enum.
func ToListMinecraftBuildsParamsOrder(val string) (ListMinecraftBuildsParamsOrder, error) {
	if res, ok := stringToListMinecraftBuildsParamsOrder[val]; ok {
		return res, nil
	}

	return ListMinecraftBuildsParamsOrder(""), ErrListMinecraftBuildsParamsOrder
}

// Defines values for ListModsParamsOrder.
const (
	ListModsParamsOrderAsc  ListModsParamsOrder = "asc"
	ListModsParamsOrderDesc ListModsParamsOrder = "desc"
)

var (
	// ErrListModsParamsOrder defines an error if an invalid value gets mapped.
	ErrListModsParamsOrder = fmt.Errorf("invalid type for ListModsParamsOrder")

	stringToListModsParamsOrder = map[string]ListModsParamsOrder{
		"asc":  ListModsParamsOrderAsc,
		"desc": ListModsParamsOrderDesc,
	}
)

// ToListModsParamsOrder acts as a helper to map a string to the defined enum.
func ToListModsParamsOrder(val string) (ListModsParamsOrder, error) {
	if res, ok := stringToListModsParamsOrder[val]; ok {
		return res, nil
	}

	return ListModsParamsOrder(""), ErrListModsParamsOrder
}

// Defines values for ListModGroupsParamsOrder.
const (
	ListModGroupsParamsOrderAsc  ListModGroupsParamsOrder = "asc"
	ListModGroupsParamsOrderDesc ListModGroupsParamsOrder = "desc"
)

var (
	// ErrListModGroupsParamsOrder defines an error if an invalid value gets mapped.
	ErrListModGroupsParamsOrder = fmt.Errorf("invalid type for ListModGroupsParamsOrder")

	stringToListModGroupsParamsOrder = map[string]ListModGroupsParamsOrder{
		"asc":  ListModGroupsParamsOrderAsc,
		"desc": ListModGroupsParamsOrderDesc,
	}
)

// ToListModGroupsParamsOrder acts as a helper to map a string to the defined enum.
func ToListModGroupsParamsOrder(val string) (ListModGroupsParamsOrder, error) {
	if res, ok := stringToListModGroupsParamsOrder[val]; ok {
		return res, nil
	}

	return ListModGroupsParamsOrder(""), ErrListModGroupsParamsOrder
}

// Defines values for ListModUsersParamsOrder.
const (
	ListModUsersParamsOrderAsc  ListModUsersParamsOrder = "asc"
	ListModUsersParamsOrderDesc ListModUsersParamsOrder = "desc"
)

var (
	// ErrListModUsersParamsOrder defines an error if an invalid value gets mapped.
	ErrListModUsersParamsOrder = fmt.Errorf("invalid type for ListModUsersParamsOrder")

	stringToListModUsersParamsOrder = map[string]ListModUsersParamsOrder{
		"asc":  ListModUsersParamsOrderAsc,
		"desc": ListModUsersParamsOrderDesc,
	}
)

// ToListModUsersParamsOrder acts as a helper to map a string to the defined enum.
func ToListModUsersParamsOrder(val string) (ListModUsersParamsOrder, error) {
	if res, ok := stringToListModUsersParamsOrder[val]; ok {
		return res, nil
	}

	return ListModUsersParamsOrder(""), ErrListModUsersParamsOrder
}

// Defines values for ListVersionsParamsOrder.
const (
	ListVersionsParamsOrderAsc  ListVersionsParamsOrder = "asc"
	ListVersionsParamsOrderDesc ListVersionsParamsOrder = "desc"
)

var (
	// ErrListVersionsParamsOrder defines an error if an invalid value gets mapped.
	ErrListVersionsParamsOrder = fmt.Errorf("invalid type for ListVersionsParamsOrder")

	stringToListVersionsParamsOrder = map[string]ListVersionsParamsOrder{
		"asc":  ListVersionsParamsOrderAsc,
		"desc": ListVersionsParamsOrderDesc,
	}
)

// ToListVersionsParamsOrder acts as a helper to map a string to the defined enum.
func ToListVersionsParamsOrder(val string) (ListVersionsParamsOrder, error) {
	if res, ok := stringToListVersionsParamsOrder[val]; ok {
		return res, nil
	}

	return ListVersionsParamsOrder(""), ErrListVersionsParamsOrder
}

// Defines values for ListVersionBuildsParamsOrder.
const (
	ListVersionBuildsParamsOrderAsc  ListVersionBuildsParamsOrder = "asc"
	ListVersionBuildsParamsOrderDesc ListVersionBuildsParamsOrder = "desc"
)

var (
	// ErrListVersionBuildsParamsOrder defines an error if an invalid value gets mapped.
	ErrListVersionBuildsParamsOrder = fmt.Errorf("invalid type for ListVersionBuildsParamsOrder")

	stringToListVersionBuildsParamsOrder = map[string]ListVersionBuildsParamsOrder{
		"asc":  ListVersionBuildsParamsOrderAsc,
		"desc": ListVersionBuildsParamsOrderDesc,
	}
)

// ToListVersionBuildsParamsOrder acts as a helper to map a string to the defined enum.
func ToListVersionBuildsParamsOrder(val string) (ListVersionBuildsParamsOrder, error) {
	if res, ok := stringToListVersionBuildsParamsOrder[val]; ok {
		return res, nil
	}

	return ListVersionBuildsParamsOrder(""), ErrListVersionBuildsParamsOrder
}

// Defines values for ListNeoforgeBuildsParamsOrder.
const (
	ListNeoforgeBuildsParamsOrderAsc  ListNeoforgeBuildsParamsOrder = "asc"
	ListNeoforgeBuildsParamsOrderDesc ListNeoforgeBuildsParamsOrder = "desc"
)

var (
	// ErrListNeoforgeBuildsParamsOrder defines an error if an invalid value gets mapped.
	ErrListNeoforgeBuildsParamsOrder = fmt.Errorf("invalid type for ListNeoforgeBuildsParamsOrder")

	stringToListNeoforgeBuildsParamsOrder = map[string]ListNeoforgeBuildsParamsOrder{
		"asc":  ListNeoforgeBuildsParamsOrderAsc,
		"desc": ListNeoforgeBuildsParamsOrderDesc,
	}
)

// ToListNeoforgeBuildsParamsOrder acts as a helper to map a string to the defined enum.
func ToListNeoforgeBuildsParamsOrder(val string) (ListNeoforgeBuildsParamsOrder, error) {
	if res, ok := stringToListNeoforgeBuildsParamsOrder[val]; ok {
		return res, nil
	}

	return ListNeoforgeBuildsParamsOrder(""), ErrListNeoforgeBuildsParamsOrder
}

// Defines values for ListPacksParamsOrder.
const (
	ListPacksParamsOrderAsc  ListPacksParamsOrder = "asc"
	ListPacksParamsOrderDesc ListPacksParamsOrder = "desc"
)

var (
	// ErrListPacksParamsOrder defines an error if an invalid value gets mapped.
	ErrListPacksParamsOrder = fmt.Errorf("invalid type for ListPacksParamsOrder")

	stringToListPacksParamsOrder = map[string]ListPacksParamsOrder{
		"asc":  ListPacksParamsOrderAsc,
		"desc": ListPacksParamsOrderDesc,
	}
)

// ToListPacksParamsOrder acts as a helper to map a string to the defined enum.
func ToListPacksParamsOrder(val string) (ListPacksParamsOrder, error) {
	if res, ok := stringToListPacksParamsOrder[val]; ok {
		return res, nil
	}

	return ListPacksParamsOrder(""), ErrListPacksParamsOrder
}

// Defines values for ListBuildsParamsOrder.
const (
	ListBuildsParamsOrderAsc  ListBuildsParamsOrder = "asc"
	ListBuildsParamsOrderDesc ListBuildsParamsOrder = "desc"
)

var (
	// ErrListBuildsParamsOrder defines an error if an invalid value gets mapped.
	ErrListBuildsParamsOrder = fmt.Errorf("invalid type for ListBuildsParamsOrder")

	stringToListBuildsParamsOrder = map[string]ListBuildsParamsOrder{
		"asc":  ListBuildsParamsOrderAsc,
		"desc": ListBuildsParamsOrderDesc,
	}
)

// ToListBuildsParamsOrder acts as a helper to map a string to the defined enum.
func ToListBuildsParamsOrder(val string) (ListBuildsParamsOrder, error) {
	if res, ok := stringToListBuildsParamsOrder[val]; ok {
		return res, nil
	}

	return ListBuildsParamsOrder(""), ErrListBuildsParamsOrder
}

// Defines values for ListBuildVersionsParamsOrder.
const (
	ListBuildVersionsParamsOrderAsc  ListBuildVersionsParamsOrder = "asc"
	ListBuildVersionsParamsOrderDesc ListBuildVersionsParamsOrder = "desc"
)

var (
	// ErrListBuildVersionsParamsOrder defines an error if an invalid value gets mapped.
	ErrListBuildVersionsParamsOrder = fmt.Errorf("invalid type for ListBuildVersionsParamsOrder")

	stringToListBuildVersionsParamsOrder = map[string]ListBuildVersionsParamsOrder{
		"asc":  ListBuildVersionsParamsOrderAsc,
		"desc": ListBuildVersionsParamsOrderDesc,
	}
)

// ToListBuildVersionsParamsOrder acts as a helper to map a string to the defined enum.
func ToListBuildVersionsParamsOrder(val string) (ListBuildVersionsParamsOrder, error) {
	if res, ok := stringToListBuildVersionsParamsOrder[val]; ok {
		return res, nil
	}

	return ListBuildVersionsParamsOrder(""), ErrListBuildVersionsParamsOrder
}

// Defines values for ListPackGroupsParamsOrder.
const (
	ListPackGroupsParamsOrderAsc  ListPackGroupsParamsOrder = "asc"
	ListPackGroupsParamsOrderDesc ListPackGroupsParamsOrder = "desc"
)

var (
	// ErrListPackGroupsParamsOrder defines an error if an invalid value gets mapped.
	ErrListPackGroupsParamsOrder = fmt.Errorf("invalid type for ListPackGroupsParamsOrder")

	stringToListPackGroupsParamsOrder = map[string]ListPackGroupsParamsOrder{
		"asc":  ListPackGroupsParamsOrderAsc,
		"desc": ListPackGroupsParamsOrderDesc,
	}
)

// ToListPackGroupsParamsOrder acts as a helper to map a string to the defined enum.
func ToListPackGroupsParamsOrder(val string) (ListPackGroupsParamsOrder, error) {
	if res, ok := stringToListPackGroupsParamsOrder[val]; ok {
		return res, nil
	}

	return ListPackGroupsParamsOrder(""), ErrListPackGroupsParamsOrder
}

// Defines values for ListPackUsersParamsOrder.
const (
	ListPackUsersParamsOrderAsc  ListPackUsersParamsOrder = "asc"
	ListPackUsersParamsOrderDesc ListPackUsersParamsOrder = "desc"
)

var (
	// ErrListPackUsersParamsOrder defines an error if an invalid value gets mapped.
	ErrListPackUsersParamsOrder = fmt.Errorf("invalid type for ListPackUsersParamsOrder")

	stringToListPackUsersParamsOrder = map[string]ListPackUsersParamsOrder{
		"asc":  ListPackUsersParamsOrderAsc,
		"desc": ListPackUsersParamsOrderDesc,
	}
)

// ToListPackUsersParamsOrder acts as a helper to map a string to the defined enum.
func ToListPackUsersParamsOrder(val string) (ListPackUsersParamsOrder, error) {
	if res, ok := stringToListPackUsersParamsOrder[val]; ok {
		return res, nil
	}

	return ListPackUsersParamsOrder(""), ErrListPackUsersParamsOrder
}

// Defines values for ListQuiltBuildsParamsOrder.
const (
	ListQuiltBuildsParamsOrderAsc  ListQuiltBuildsParamsOrder = "asc"
	ListQuiltBuildsParamsOrderDesc ListQuiltBuildsParamsOrder = "desc"
)

var (
	// ErrListQuiltBuildsParamsOrder defines an error if an invalid value gets mapped.
	ErrListQuiltBuildsParamsOrder = fmt.Errorf("invalid type for ListQuiltBuildsParamsOrder")

	stringToListQuiltBuildsParamsOrder = map[string]ListQuiltBuildsParamsOrder{
		"asc":  ListQuiltBuildsParamsOrderAsc,
		"desc": ListQuiltBuildsParamsOrderDesc,
	}
)

// ToListQuiltBuildsParamsOrder acts as a helper to map a string to the defined enum.
func ToListQuiltBuildsParamsOrder(val string) (ListQuiltBuildsParamsOrder, error) {
	if res, ok := stringToListQuiltBuildsParamsOrder[val]; ok {
		return res, nil
	}

	return ListQuiltBuildsParamsOrder(""), ErrListQuiltBuildsParamsOrder
}

// Defines values for ListUsersParamsOrder.
const (
	ListUsersParamsOrderAsc  ListUsersParamsOrder = "asc"
	ListUsersParamsOrderDesc ListUsersParamsOrder = "desc"
)

var (
	// ErrListUsersParamsOrder defines an error if an invalid value gets mapped.
	ErrListUsersParamsOrder = fmt.Errorf("invalid type for ListUsersParamsOrder")

	stringToListUsersParamsOrder = map[string]ListUsersParamsOrder{
		"asc":  ListUsersParamsOrderAsc,
		"desc": ListUsersParamsOrderDesc,
	}
)

// ToListUsersParamsOrder acts as a helper to map a string to the defined enum.
func ToListUsersParamsOrder(val string) (ListUsersParamsOrder, error) {
	if res, ok := stringToListUsersParamsOrder[val]; ok {
		return res, nil
	}

	return ListUsersParamsOrder(""), ErrListUsersParamsOrder
}

// Defines values for ListUserGroupsParamsOrder.
const (
	ListUserGroupsParamsOrderAsc  ListUserGroupsParamsOrder = "asc"
	ListUserGroupsParamsOrderDesc ListUserGroupsParamsOrder = "desc"
)

var (
	// ErrListUserGroupsParamsOrder defines an error if an invalid value gets mapped.
	ErrListUserGroupsParamsOrder = fmt.Errorf("invalid type for ListUserGroupsParamsOrder")

	stringToListUserGroupsParamsOrder = map[string]ListUserGroupsParamsOrder{
		"asc":  ListUserGroupsParamsOrderAsc,
		"desc": ListUserGroupsParamsOrderDesc,
	}
)

// ToListUserGroupsParamsOrder acts as a helper to map a string to the defined enum.
func ToListUserGroupsParamsOrder(val string) (ListUserGroupsParamsOrder, error) {
	if res, ok := stringToListUserGroupsParamsOrder[val]; ok {
		return res, nil
	}

	return ListUserGroupsParamsOrder(""), ErrListUserGroupsParamsOrder
}

// Defines values for ListUserModsParamsOrder.
const (
	ListUserModsParamsOrderAsc  ListUserModsParamsOrder = "asc"
	ListUserModsParamsOrderDesc ListUserModsParamsOrder = "desc"
)

var (
	// ErrListUserModsParamsOrder defines an error if an invalid value gets mapped.
	ErrListUserModsParamsOrder = fmt.Errorf("invalid type for ListUserModsParamsOrder")

	stringToListUserModsParamsOrder = map[string]ListUserModsParamsOrder{
		"asc":  ListUserModsParamsOrderAsc,
		"desc": ListUserModsParamsOrderDesc,
	}
)

// ToListUserModsParamsOrder acts as a helper to map a string to the defined enum.
func ToListUserModsParamsOrder(val string) (ListUserModsParamsOrder, error) {
	if res, ok := stringToListUserModsParamsOrder[val]; ok {
		return res, nil
	}

	return ListUserModsParamsOrder(""), ErrListUserModsParamsOrder
}

// Defines values for ListUserPacksParamsOrder.
const (
	ListUserPacksParamsOrderAsc  ListUserPacksParamsOrder = "asc"
	ListUserPacksParamsOrderDesc ListUserPacksParamsOrder = "desc"
)

var (
	// ErrListUserPacksParamsOrder defines an error if an invalid value gets mapped.
	ErrListUserPacksParamsOrder = fmt.Errorf("invalid type for ListUserPacksParamsOrder")

	stringToListUserPacksParamsOrder = map[string]ListUserPacksParamsOrder{
		"asc":  ListUserPacksParamsOrderAsc,
		"desc": ListUserPacksParamsOrderDesc,
	}
)

// ToListUserPacksParamsOrder acts as a helper to map a string to the defined enum.
func ToListUserPacksParamsOrder(val string) (ListUserPacksParamsOrder, error) {
	if res, ok := stringToListUserPacksParamsOrder[val]; ok {
		return res, nil
	}

	return ListUserPacksParamsOrder(""), ErrListUserPacksParamsOrder
}

// AuthToken defines model for AuthToken.
type AuthToken struct {
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
	Token     *string    `json:"token,omitempty"`
}

// AuthVerify defines model for AuthVerify.
type AuthVerify struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Username  *string    `json:"username,omitempty"`
}

// Build Model to represent build
type Build struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Fabric Model to represent fabric
	Fabric   *Fabric `json:"fabric,omitempty"`
	FabricID *string `json:"fabric_id,omitempty"`

	// Forge Model to represent forge
	Forge   *Forge  `json:"forge,omitempty"`
	ForgeID *string `json:"forge_id,omitempty"`
	ID      *string `json:"id,omitempty"`
	Java    *string `json:"java,omitempty"`
	Latest  *bool   `json:"latest,omitempty"`
	Memory  *string `json:"memory,omitempty"`

	// Minecraft Model to represent minecraft
	Minecraft   *Minecraft `json:"minecraft,omitempty"`
	MinecraftID *string    `json:"minecraft_id,omitempty"`
	Name        *string    `json:"name,omitempty"`

	// Neoforge Model to represent neoforge
	Neoforge   *Neoforge `json:"neoforge,omitempty"`
	NeoforgeID *string   `json:"neoforge_id,omitempty"`

	// Pack Model to represent pack
	Pack   *Pack `json:"pack,omitempty"`
	Public *bool `json:"public,omitempty"`

	// Quilt Model to represent quilt
	Quilt       *Quilt     `json:"quilt,omitempty"`
	QuiltID     *string    `json:"quilt_id,omitempty"`
	Recommended *bool      `json:"recommended,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
}

// BuildVersion Model to represent build version
type BuildVersion struct {
	// Build Model to represent build
	Build     *Build     `json:"build,omitempty"`
	BuildID   string     `json:"build_id"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Version Model to represent version
	Version   *Version `json:"version,omitempty"`
	VersionID string   `json:"version_id"`
}

// Fabric Model to represent fabric
type Fabric struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Forge Model to represent forge
type Forge struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Minecraft *string    `json:"minecraft,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Group Model to represent group
type Group struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// GroupMod Model to represent group mod
type GroupMod struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Group Model to represent group
	Group   *Group `json:"group,omitempty"`
	GroupID string `json:"group_id"`

	// Mod Model to represent mod
	Mod       *Mod          `json:"mod,omitempty"`
	ModID     string        `json:"mod_id"`
	Perm      *GroupModPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time    `json:"updated_at,omitempty"`
}

// GroupModPerm defines model for GroupMod.Perm.
type GroupModPerm string

// GroupPack Model to represent group pack
type GroupPack struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Group Model to represent group
	Group   *Group `json:"group,omitempty"`
	GroupID string `json:"group_id"`

	// Pack Model to represent pack
	Pack      *Pack          `json:"pack,omitempty"`
	PackID    string         `json:"pack_id"`
	Perm      *GroupPackPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time     `json:"updated_at,omitempty"`
}

// GroupPackPerm defines model for GroupPack.Perm.
type GroupPackPerm string

// Minecraft Model to represent minecraft
type Minecraft struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Type      *string    `json:"type,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Mod Model to represent mod
type Mod struct {
	Author *string `json:"author,omitempty"`

	// Avatar Model to represent mod avatar
	Avatar      *ModAvatar `json:"avatar,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	Description *string    `json:"description,omitempty"`
	Donate      *string    `json:"donate,omitempty"`
	ID          *string    `json:"id,omitempty"`
	Name        *string    `json:"name,omitempty"`
	Public      *bool      `json:"public,omitempty"`
	Side        *string    `json:"side,omitempty"`
	Slug        *string    `json:"slug,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
	Website     *string    `json:"website,omitempty"`
}

// ModAvatar Model to represent mod avatar
type ModAvatar struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	URL       *string    `json:"url,omitempty"`
}

// Neoforge Model to represent neoforge
type Neoforge struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Notification Generic response for errors and validations
type Notification struct {
	Errors  *[]Validation `json:"errors,omitempty"`
	Message *string       `json:"message,omitempty"`
	Status  *int          `json:"status,omitempty"`
}

// Pack Model to represent pack
type Pack struct {
	// Avatar Model to represent pack avatar
	Avatar    *PackAvatar `json:"avatar,omitempty"`
	CreatedAt *time.Time  `json:"created_at,omitempty"`
	ID        *string     `json:"id,omitempty"`
	Name      *string     `json:"name,omitempty"`
	Public    *bool       `json:"public,omitempty"`
	Slug      *string     `json:"slug,omitempty"`
	UpdatedAt *time.Time  `json:"updated_at,omitempty"`
	Website   *string     `json:"website,omitempty"`
}

// PackAvatar Model to represent pack avatar
type PackAvatar struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	URL       *string    `json:"url,omitempty"`
}

// Profile Model to represent profile
type Profile struct {
	Active    *bool        `json:"active,omitempty"`
	Admin     *bool        `json:"admin,omitempty"`
	Auths     *[]UserAuth  `json:"auths,omitempty"`
	CreatedAt *time.Time   `json:"created_at,omitempty"`
	Email     *string      `json:"email,omitempty"`
	Fullname  *string      `json:"fullname,omitempty"`
	Groups    *[]UserGroup `json:"groups,omitempty"`
	ID        *string      `json:"id,omitempty"`
	Mods      *[]UserMod   `json:"mods,omitempty"`
	Packs     *[]UserPack  `json:"packs,omitempty"`
	Password  *string      `json:"password,omitempty"`
	Profile   *string      `json:"profile,omitempty"`
	UpdatedAt *time.Time   `json:"updated_at,omitempty"`
	Username  *string      `json:"username,omitempty"`
}

// Provider Model to represent auth provider
type Provider struct {
	Display *string `json:"display,omitempty"`
	Driver  *string `json:"driver,omitempty"`
	Icon    *string `json:"icon,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// Quilt Model to represent quilt
type Quilt struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	ID        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// User Model to represent user
type User struct {
	Active    *bool       `json:"active,omitempty"`
	Admin     *bool       `json:"admin,omitempty"`
	Auths     *[]UserAuth `json:"auths,omitempty"`
	CreatedAt *time.Time  `json:"created_at,omitempty"`
	Email     *string     `json:"email,omitempty"`
	Fullname  *string     `json:"fullname,omitempty"`
	ID        *string     `json:"id,omitempty"`
	Password  *string     `json:"password,omitempty"`
	Profile   *string     `json:"profile,omitempty"`
	UpdatedAt *time.Time  `json:"updated_at,omitempty"`
	Username  *string     `json:"username,omitempty"`
}

// UserAuth Model to represent user auth
type UserAuth struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Provider  *string    `json:"provider,omitempty"`
	Ref       *string    `json:"ref,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// UserGroup Model to represent user group
type UserGroup struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Group Model to represent group
	Group     *Group         `json:"group,omitempty"`
	GroupID   string         `json:"group_id"`
	Perm      *UserGroupPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time     `json:"updated_at,omitempty"`

	// User Model to represent user
	User   *User  `json:"user,omitempty"`
	UserID string `json:"user_id"`
}

// UserGroupPerm defines model for UserGroup.Perm.
type UserGroupPerm string

// UserMod Model to represent user mod
type UserMod struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Mod Model to represent mod
	Mod       *Mod         `json:"mod,omitempty"`
	ModID     string       `json:"mod_id"`
	Perm      *UserModPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time   `json:"updated_at,omitempty"`

	// User Model to represent user
	User   *User  `json:"user,omitempty"`
	UserID string `json:"user_id"`
}

// UserModPerm defines model for UserMod.Perm.
type UserModPerm string

// UserPack Model to represent user pack
type UserPack struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Pack Model to represent pack
	Pack      *Pack         `json:"pack,omitempty"`
	PackID    string        `json:"pack_id"`
	Perm      *UserPackPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time    `json:"updated_at,omitempty"`

	// User Model to represent user
	User   *User  `json:"user,omitempty"`
	UserID string `json:"user_id"`
}

// UserPackPerm defines model for UserPack.Perm.
type UserPackPerm string

// Validation General structure to show validation errors
type Validation struct {
	Field   *string `json:"field,omitempty"`
	Message *string `json:"message,omitempty"`
}

// Version Model to represent version
type Version struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// File Model to represent version file
	File *VersionFile `json:"file,omitempty"`
	ID   *string      `json:"id,omitempty"`

	// Mod Model to represent mod
	Mod       *Mod       `json:"mod,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Public    *bool      `json:"public,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// VersionFile Model to represent version file
type VersionFile struct {
	ContentType *string    `json:"content_type,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	MD5         *string    `json:"md5,omitempty"`
	Path        *string    `json:"path,omitempty"`
	Slug        *string    `json:"slug,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
	URL         *string    `json:"url,omitempty"`
}

// AuthCodeParam defines model for AuthCodeParam.
type AuthCodeParam = string

// AuthProviderParam defines model for AuthProviderParam.
type AuthProviderParam = string

// AuthStateParam defines model for AuthStateParam.
type AuthStateParam = string

// BuildID defines model for BuildParam.
type BuildID = string

// FabricID defines model for FabricParam.
type FabricID = string

// ForgeID defines model for ForgeParam.
type ForgeID = string

// GroupID defines model for GroupParam.
type GroupID = string

// MinecraftID defines model for MinecraftParam.
type MinecraftID = string

// ModID defines model for ModParam.
type ModID = string

// NeoforgeID defines model for NeoforgeParam.
type NeoforgeID = string

// PackID defines model for PackParam.
type PackID = string

// PagingLimitParam defines model for PagingLimitParam.
type PagingLimitParam = int

// PagingOffsetParam defines model for PagingOffsetParam.
type PagingOffsetParam = int

// QuiltID defines model for QuiltParam.
type QuiltID = string

// SearchQueryParam defines model for SearchQueryParam.
type SearchQueryParam = string

// SortColumnParam defines model for SortColumnParam.
type SortColumnParam = string

// SortOrderParam defines model for SortOrderParam.
type SortOrderParam string

// UserID defines model for UserParam.
type UserID = string

// VersionID defines model for VersionParam.
type VersionID = string

// ActionFailedError Generic response for errors and validations
type ActionFailedError = Notification

// AlreadyAttachedError Generic response for errors and validations
type AlreadyAttachedError = Notification

// BadCredentialsError Generic response for errors and validations
type BadCredentialsError = Notification

// BadRequestError Generic response for errors and validations
type BadRequestError = Notification

// BuildResponse Model to represent build
type BuildResponse = Build

// BuildVersionsResponse defines model for BuildVersionsResponse.
type BuildVersionsResponse struct {
	// Build Model to represent build
	Build  *Build `json:"build,omitempty"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`

	// Pack Model to represent pack
	Pack     *Pack          `json:"pack,omitempty"`
	Total    int64          `json:"total"`
	Versions []BuildVersion `json:"versions"`
}

// BuildsResponse defines model for BuildsResponse.
type BuildsResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`

	// Pack Model to represent pack
	Pack  *Pack `json:"pack,omitempty"`
	Total int64 `json:"total"`
}

// FabricBuildsResponse defines model for FabricBuildsResponse.
type FabricBuildsResponse struct {
	Builds []Build `json:"builds"`

	// Fabric Model to represent fabric
	Fabric *Fabric `json:"fabric,omitempty"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
	Total  int64   `json:"total"`
}

// FabricsResponse defines model for FabricsResponse.
type FabricsResponse struct {
	Limit    int64    `json:"limit"`
	Offset   int64    `json:"offset"`
	Total    int64    `json:"total"`
	Versions []Fabric `json:"versions"`
}

// ForgeBuildsResponse defines model for ForgeBuildsResponse.
type ForgeBuildsResponse struct {
	Builds []Build `json:"builds"`

	// Forge Model to represent forge
	Forge  *Forge `json:"forge,omitempty"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	Total  int64  `json:"total"`
}

// ForgesResponse defines model for ForgesResponse.
type ForgesResponse struct {
	Limit    int64   `json:"limit"`
	Offset   int64   `json:"offset"`
	Total    int64   `json:"total"`
	Versions []Forge `json:"versions"`
}

// GroupModsResponse defines model for GroupModsResponse.
type GroupModsResponse struct {
	// Group Model to represent group
	Group  *Group     `json:"group,omitempty"`
	Limit  int64      `json:"limit"`
	Mods   []GroupMod `json:"mods"`
	Offset int64      `json:"offset"`
	Total  int64      `json:"total"`
}

// GroupPacksResponse defines model for GroupPacksResponse.
type GroupPacksResponse struct {
	// Group Model to represent group
	Group  *Group      `json:"group,omitempty"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Packs  []GroupPack `json:"packs"`
	Total  int64       `json:"total"`
}

// GroupResponse Model to represent group
type GroupResponse = Group

// GroupUsersResponse defines model for GroupUsersResponse.
type GroupUsersResponse struct {
	// Group Model to represent group
	Group  *Group      `json:"group,omitempty"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Total  int64       `json:"total"`
	Users  []UserGroup `json:"users"`
}

// GroupsResponse defines model for GroupsResponse.
type GroupsResponse struct {
	Groups []Group `json:"groups"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`
	Total  int64   `json:"total"`
}

// InternalServerError Generic response for errors and validations
type InternalServerError = Notification

// InvalidTokenError Generic response for errors and validations
type InvalidTokenError = Notification

// LoginResponse defines model for LoginResponse.
type LoginResponse = AuthToken

// MinecraftBuildsResponse defines model for MinecraftBuildsResponse.
type MinecraftBuildsResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`

	// Minecraft Model to represent minecraft
	Minecraft *Minecraft `json:"minecraft,omitempty"`
	Offset    int64      `json:"offset"`
	Total     int64      `json:"total"`
}

// MinecraftsResponse defines model for MinecraftsResponse.
type MinecraftsResponse struct {
	Limit    int64       `json:"limit"`
	Offset   int64       `json:"offset"`
	Total    int64       `json:"total"`
	Versions []Minecraft `json:"versions"`
}

// ModAvatarResponse Model to represent mod avatar
type ModAvatarResponse = ModAvatar

// ModGroupsResponse defines model for ModGroupsResponse.
type ModGroupsResponse struct {
	Groups []GroupMod `json:"groups"`
	Limit  int64      `json:"limit"`

	// Mod Model to represent mod
	Mod    *Mod  `json:"mod,omitempty"`
	Offset int64 `json:"offset"`
	Total  int64 `json:"total"`
}

// ModResponse Model to represent mod
type ModResponse = Mod

// ModUsersResponse defines model for ModUsersResponse.
type ModUsersResponse struct {
	Limit int64 `json:"limit"`

	// Mod Model to represent mod
	Mod    *Mod      `json:"mod,omitempty"`
	Offset int64     `json:"offset"`
	Total  int64     `json:"total"`
	Users  []UserMod `json:"users"`
}

// ModsResponse defines model for ModsResponse.
type ModsResponse struct {
	Limit  int64 `json:"limit"`
	Mods   []Mod `json:"mods"`
	Offset int64 `json:"offset"`
	Total  int64 `json:"total"`
}

// NeoforgeBuildsResponse defines model for NeoforgeBuildsResponse.
type NeoforgeBuildsResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`

	// Neoforge Model to represent neoforge
	Neoforge *Neoforge `json:"neoforge,omitempty"`
	Offset   int64     `json:"offset"`
	Total    int64     `json:"total"`
}

// NeoforgesResponse defines model for NeoforgesResponse.
type NeoforgesResponse struct {
	Limit    int64      `json:"limit"`
	Offset   int64      `json:"offset"`
	Total    int64      `json:"total"`
	Versions []Neoforge `json:"versions"`
}

// NotAttachedError Generic response for errors and validations
type NotAttachedError = Notification

// NotAuthorizedError Generic response for errors and validations
type NotAuthorizedError = Notification

// NotFoundError Generic response for errors and validations
type NotFoundError = Notification

// PackAvatarResponse Model to represent pack avatar
type PackAvatarResponse = PackAvatar

// PackGroupsResponse defines model for PackGroupsResponse.
type PackGroupsResponse struct {
	Groups []GroupPack `json:"groups"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`

	// Pack Model to represent pack
	Pack  *Pack `json:"pack,omitempty"`
	Total int64 `json:"total"`
}

// PackResponse Model to represent pack
type PackResponse = Pack

// PackUsersResponse defines model for PackUsersResponse.
type PackUsersResponse struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`

	// Pack Model to represent pack
	Pack  *Pack      `json:"pack,omitempty"`
	Total int64      `json:"total"`
	Users []UserPack `json:"users"`
}

// PacksResponse defines model for PacksResponse.
type PacksResponse struct {
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	Packs  []Pack `json:"packs"`
	Total  int64  `json:"total"`
}

// ProfileResponse Model to represent profile
type ProfileResponse = Profile

// ProvidersResponse defines model for ProvidersResponse.
type ProvidersResponse struct {
	Providers []Provider `json:"providers"`
	Total     int64      `json:"total"`
}

// QuiltBuildsResponse defines model for QuiltBuildsResponse.
type QuiltBuildsResponse struct {
	Builds []Build `json:"builds"`
	Limit  int64   `json:"limit"`
	Offset int64   `json:"offset"`

	// Quilt Model to represent quilt
	Quilt *Quilt `json:"quilt,omitempty"`
	Total int64  `json:"total"`
}

// QuiltsResponse defines model for QuiltsResponse.
type QuiltsResponse struct {
	Limit    int64   `json:"limit"`
	Offset   int64   `json:"offset"`
	Total    int64   `json:"total"`
	Versions []Quilt `json:"versions"`
}

// RefreshResponse defines model for RefreshResponse.
type RefreshResponse = AuthToken

// RemoteUnavailableError Generic response for errors and validations
type RemoteUnavailableError = Notification

// SuccessMessage Generic response for errors and validations
type SuccessMessage = Notification

// TokenResponse defines model for TokenResponse.
type TokenResponse = AuthToken

// UserGroupsResponse defines model for UserGroupsResponse.
type UserGroupsResponse struct {
	Groups []UserGroup `json:"groups"`
	Limit  int64       `json:"limit"`
	Offset int64       `json:"offset"`
	Total  int64       `json:"total"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

// UserModsResponse defines model for UserModsResponse.
type UserModsResponse struct {
	Limit  int64     `json:"limit"`
	Mods   []UserMod `json:"mods"`
	Offset int64     `json:"offset"`
	Total  int64     `json:"total"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

// UserPacksResponse defines model for UserPacksResponse.
type UserPacksResponse struct {
	Limit  int64      `json:"limit"`
	Offset int64      `json:"offset"`
	Packs  []UserPack `json:"packs"`
	Total  int64      `json:"total"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

// UserResponse Model to represent user
type UserResponse = User

// UsersResponse defines model for UsersResponse.
type UsersResponse struct {
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
	Total  int64  `json:"total"`
	Users  []User `json:"users"`
}

// ValidationError Generic response for errors and validations
type ValidationError = Notification

// VerifyResponse defines model for VerifyResponse.
type VerifyResponse = AuthVerify

// VersionBuildsResponse defines model for VersionBuildsResponse.
type VersionBuildsResponse struct {
	Builds []BuildVersion `json:"builds"`
	Limit  int64          `json:"limit"`

	// Mod Model to represent mod
	Mod    *Mod  `json:"mod,omitempty"`
	Offset int64 `json:"offset"`
	Total  int64 `json:"total"`

	// Version Model to represent version
	Version *Version `json:"version,omitempty"`
}

// VersionResponse Model to represent version
type VersionResponse = Version

// VersionsResponse defines model for VersionsResponse.
type VersionsResponse struct {
	Limit int64 `json:"limit"`

	// Mod Model to represent mod
	Mod      *Mod      `json:"mod,omitempty"`
	Offset   int64     `json:"offset"`
	Total    int64     `json:"total"`
	Versions []Version `json:"versions"`
}

// BuildVersionBody defines model for BuildVersionBody.
type BuildVersionBody struct {
	Mod     string `json:"mod,omitempty"`
	Version string `json:"version,omitempty"`
}

// CreateBuildBody defines model for CreateBuildBody.
type CreateBuildBody struct {
	FabricID    *string `json:"fabric_id,omitempty"`
	ForgeID     *string `json:"forge_id,omitempty"`
	Java        *string `json:"java,omitempty"`
	Latest      *bool   `json:"latest,omitempty"`
	Memory      *string `json:"memory,omitempty"`
	MinecraftID *string `json:"minecraft_id,omitempty"`
	Name        *string `json:"name,omitempty"`
	NeoforgeID  *string `json:"neoforge_id,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	QuiltID     *string `json:"quilt_id,omitempty"`
	Recommended *bool   `json:"recommended,omitempty"`
}

// CreateGroupBody defines model for CreateGroupBody.
type CreateGroupBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// CreateModBody defines model for CreateModBody.
type CreateModBody struct {
	Author      *string `json:"author,omitempty"`
	Description *string `json:"description,omitempty"`
	Donate      *string `json:"donate,omitempty"`
	Name        *string `json:"name,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	Side        *string `json:"side,omitempty"`
	Slug        *string `json:"slug,omitempty"`
	Website     *string `json:"website,omitempty"`
}

// CreatePackBody defines model for CreatePackBody.
type CreatePackBody struct {
	Name    *string `json:"name,omitempty"`
	Public  *bool   `json:"public,omitempty"`
	Slug    *string `json:"slug,omitempty"`
	Website *string `json:"website,omitempty"`
}

// CreateUserBody defines model for CreateUserBody.
type CreateUserBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// CreateVersionBody defines model for CreateVersionBody.
type CreateVersionBody struct {
	Name   *string `json:"name,omitempty"`
	Public *bool   `json:"public,omitempty"`
	Upload *string `json:"upload,omitempty"`
}

// FabricBuildBody defines model for FabricBuildBody.
type FabricBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ForgeBuildBody defines model for ForgeBuildBody.
type ForgeBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// GroupModDropBody defines model for GroupModDropBody.
type GroupModDropBody struct {
	Mod string `json:"mod"`
}

// GroupModPermBody defines model for GroupModPermBody.
type GroupModPermBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// GroupPackDropBody defines model for GroupPackDropBody.
type GroupPackDropBody struct {
	Pack string `json:"pack"`
}

// GroupPackPermBody defines model for GroupPackPermBody.
type GroupPackPermBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// GroupUserDropBody defines model for GroupUserDropBody.
type GroupUserDropBody struct {
	User string `json:"user"`
}

// GroupUserPermBody defines model for GroupUserPermBody.
type GroupUserPermBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// LoginAuthBody defines model for LoginAuthBody.
type LoginAuthBody struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// MinecraftBuildBody defines model for MinecraftBuildBody.
type MinecraftBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ModGroupDropBody defines model for ModGroupDropBody.
type ModGroupDropBody struct {
	Group string `json:"group"`
}

// ModGroupPermBody defines model for ModGroupPermBody.
type ModGroupPermBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// ModUserDropBody defines model for ModUserDropBody.
type ModUserDropBody struct {
	User string `json:"user"`
}

// ModUserPermBody defines model for ModUserPermBody.
type ModUserPermBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// NeoforgeBuildBody defines model for NeoforgeBuildBody.
type NeoforgeBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// PackGroupDropBody defines model for PackGroupDropBody.
type PackGroupDropBody struct {
	Group string `json:"group"`
}

// PackGroupPermBody defines model for PackGroupPermBody.
type PackGroupPermBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// PackUserDropBody defines model for PackUserDropBody.
type PackUserDropBody struct {
	User string `json:"user"`
}

// PackUserPermBody defines model for PackUserPermBody.
type PackUserPermBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// QuiltBuildBody defines model for QuiltBuildBody.
type QuiltBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// RedirectAuthBody defines model for RedirectAuthBody.
type RedirectAuthBody struct {
	Token string `json:"token"`
}

// UpdateBuildBody defines model for UpdateBuildBody.
type UpdateBuildBody struct {
	FabricID    *string `json:"fabric_id,omitempty"`
	ForgeID     *string `json:"forge_id,omitempty"`
	Java        *string `json:"java,omitempty"`
	Latest      *bool   `json:"latest,omitempty"`
	Memory      *string `json:"memory,omitempty"`
	MinecraftID *string `json:"minecraft_id,omitempty"`
	Name        *string `json:"name,omitempty"`
	NeoforgeID  *string `json:"neoforge_id,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	QuiltID     *string `json:"quilt_id,omitempty"`
	Recommended *bool   `json:"recommended,omitempty"`
}

// UpdateGroupBody defines model for UpdateGroupBody.
type UpdateGroupBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// UpdateModBody defines model for UpdateModBody.
type UpdateModBody struct {
	Author      *string `json:"author,omitempty"`
	Description *string `json:"description,omitempty"`
	Donate      *string `json:"donate,omitempty"`
	Name        *string `json:"name,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	Side        *string `json:"side,omitempty"`
	Slug        *string `json:"slug,omitempty"`
	Website     *string `json:"website,omitempty"`
}

// UpdatePackBody defines model for UpdatePackBody.
type UpdatePackBody struct {
	Name    *string `json:"name,omitempty"`
	Public  *bool   `json:"public,omitempty"`
	Slug    *string `json:"slug,omitempty"`
	Website *string `json:"website,omitempty"`
}

// UpdateProfileBody defines model for UpdateProfileBody.
type UpdateProfileBody struct {
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UpdateUserBody defines model for UpdateUserBody.
type UpdateUserBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UpdateVersionBody defines model for UpdateVersionBody.
type UpdateVersionBody struct {
	Name   *string `json:"name,omitempty"`
	Public *bool   `json:"public,omitempty"`
	Upload *string `json:"upload,omitempty"`
}

// UserGroupDropBody defines model for UserGroupDropBody.
type UserGroupDropBody struct {
	Group string `json:"group"`
}

// UserGroupPermBody defines model for UserGroupPermBody.
type UserGroupPermBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// UserModDropBody defines model for UserModDropBody.
type UserModDropBody struct {
	Mod string `json:"mod"`
}

// UserModPermBody defines model for UserModPermBody.
type UserModPermBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// UserPackDropBody defines model for UserPackDropBody.
type UserPackDropBody struct {
	Pack string `json:"pack"`
}

// UserPackPermBody defines model for UserPackPermBody.
type UserPackPermBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// VersionBuildBody defines model for VersionBuildBody.
type VersionBuildBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// LoginAuthJSONBody defines parameters for LoginAuth.
type LoginAuthJSONBody struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// RedirectAuthJSONBody defines parameters for RedirectAuth.
type RedirectAuthJSONBody struct {
	Token string `json:"token"`
}

// CallbackProviderParams defines parameters for CallbackProvider.
type CallbackProviderParams struct {
	// State Auth state
	State *AuthStateParam `form:"state,omitempty" json:"state,omitempty"`

	// Code Auth code
	Code *AuthCodeParam `form:"code,omitempty" json:"code,omitempty"`
}

// ListFabricsParams defines parameters for ListFabrics.
type ListFabricsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`
}

// DeleteFabricFromBuildJSONBody defines parameters for DeleteFabricFromBuild.
type DeleteFabricFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListFabricBuildsParams defines parameters for ListFabricBuilds.
type ListFabricBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListFabricBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListFabricBuildsParamsOrder defines parameters for ListFabricBuilds.
type ListFabricBuildsParamsOrder string

// AttachFabricToBuildJSONBody defines parameters for AttachFabricToBuild.
type AttachFabricToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListForgesParams defines parameters for ListForges.
type ListForgesParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`
}

// DeleteForgeFromBuildJSONBody defines parameters for DeleteForgeFromBuild.
type DeleteForgeFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListForgeBuildsParams defines parameters for ListForgeBuilds.
type ListForgeBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListForgeBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListForgeBuildsParamsOrder defines parameters for ListForgeBuilds.
type ListForgeBuildsParamsOrder string

// AttachForgeToBuildJSONBody defines parameters for AttachForgeToBuild.
type AttachForgeToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListGroupsParams defines parameters for ListGroups.
type ListGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupsParamsOrder defines parameters for ListGroups.
type ListGroupsParamsOrder string

// CreateGroupJSONBody defines parameters for CreateGroup.
type CreateGroupJSONBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// UpdateGroupJSONBody defines parameters for UpdateGroup.
type UpdateGroupJSONBody struct {
	Name *string `json:"name,omitempty"`
	Slug *string `json:"slug,omitempty"`
}

// DeleteGroupFromModJSONBody defines parameters for DeleteGroupFromMod.
type DeleteGroupFromModJSONBody struct {
	Mod string `json:"mod"`
}

// ListGroupModsParams defines parameters for ListGroupMods.
type ListGroupModsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupModsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupModsParamsOrder defines parameters for ListGroupMods.
type ListGroupModsParamsOrder string

// AttachGroupToModJSONBody defines parameters for AttachGroupToMod.
type AttachGroupToModJSONBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// PermitGroupModJSONBody defines parameters for PermitGroupMod.
type PermitGroupModJSONBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// DeleteGroupFromPackJSONBody defines parameters for DeleteGroupFromPack.
type DeleteGroupFromPackJSONBody struct {
	Pack string `json:"pack"`
}

// ListGroupPacksParams defines parameters for ListGroupPacks.
type ListGroupPacksParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupPacksParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupPacksParamsOrder defines parameters for ListGroupPacks.
type ListGroupPacksParamsOrder string

// AttachGroupToPackJSONBody defines parameters for AttachGroupToPack.
type AttachGroupToPackJSONBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// PermitGroupPackJSONBody defines parameters for PermitGroupPack.
type PermitGroupPackJSONBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// DeleteGroupFromUserJSONBody defines parameters for DeleteGroupFromUser.
type DeleteGroupFromUserJSONBody struct {
	User string `json:"user"`
}

// ListGroupUsersParams defines parameters for ListGroupUsers.
type ListGroupUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListGroupUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListGroupUsersParamsOrder defines parameters for ListGroupUsers.
type ListGroupUsersParamsOrder string

// AttachGroupToUserJSONBody defines parameters for AttachGroupToUser.
type AttachGroupToUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// PermitGroupUserJSONBody defines parameters for PermitGroupUser.
type PermitGroupUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// ListMinecraftsParams defines parameters for ListMinecrafts.
type ListMinecraftsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`
}

// DeleteMinecraftFromBuildJSONBody defines parameters for DeleteMinecraftFromBuild.
type DeleteMinecraftFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListMinecraftBuildsParams defines parameters for ListMinecraftBuilds.
type ListMinecraftBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListMinecraftBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListMinecraftBuildsParamsOrder defines parameters for ListMinecraftBuilds.
type ListMinecraftBuildsParamsOrder string

// AttachMinecraftToBuildJSONBody defines parameters for AttachMinecraftToBuild.
type AttachMinecraftToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListModsParams defines parameters for ListMods.
type ListModsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListModsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListModsParamsOrder defines parameters for ListMods.
type ListModsParamsOrder string

// CreateModJSONBody defines parameters for CreateMod.
type CreateModJSONBody struct {
	Author      *string `json:"author,omitempty"`
	Description *string `json:"description,omitempty"`
	Donate      *string `json:"donate,omitempty"`
	Name        *string `json:"name,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	Side        *string `json:"side,omitempty"`
	Slug        *string `json:"slug,omitempty"`
	Website     *string `json:"website,omitempty"`
}

// UpdateModJSONBody defines parameters for UpdateMod.
type UpdateModJSONBody struct {
	Author      *string `json:"author,omitempty"`
	Description *string `json:"description,omitempty"`
	Donate      *string `json:"donate,omitempty"`
	Name        *string `json:"name,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	Side        *string `json:"side,omitempty"`
	Slug        *string `json:"slug,omitempty"`
	Website     *string `json:"website,omitempty"`
}

// CreateModAvatarMultipartBody defines parameters for CreateModAvatar.
type CreateModAvatarMultipartBody struct {
	File *openapi_types.File `json:"file,omitempty"`
}

// DeleteModFromGroupJSONBody defines parameters for DeleteModFromGroup.
type DeleteModFromGroupJSONBody struct {
	Group string `json:"group"`
}

// ListModGroupsParams defines parameters for ListModGroups.
type ListModGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListModGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListModGroupsParamsOrder defines parameters for ListModGroups.
type ListModGroupsParamsOrder string

// AttachModToGroupJSONBody defines parameters for AttachModToGroup.
type AttachModToGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// PermitModGroupJSONBody defines parameters for PermitModGroup.
type PermitModGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// DeleteModFromUserJSONBody defines parameters for DeleteModFromUser.
type DeleteModFromUserJSONBody struct {
	User string `json:"user"`
}

// ListModUsersParams defines parameters for ListModUsers.
type ListModUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListModUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListModUsersParamsOrder defines parameters for ListModUsers.
type ListModUsersParamsOrder string

// AttachModToUserJSONBody defines parameters for AttachModToUser.
type AttachModToUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// PermitModUserJSONBody defines parameters for PermitModUser.
type PermitModUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// ListVersionsParams defines parameters for ListVersions.
type ListVersionsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListVersionsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListVersionsParamsOrder defines parameters for ListVersions.
type ListVersionsParamsOrder string

// CreateVersionJSONBody defines parameters for CreateVersion.
type CreateVersionJSONBody struct {
	Name   *string `json:"name,omitempty"`
	Public *bool   `json:"public,omitempty"`
	Upload *string `json:"upload,omitempty"`
}

// UpdateVersionJSONBody defines parameters for UpdateVersion.
type UpdateVersionJSONBody struct {
	Name   *string `json:"name,omitempty"`
	Public *bool   `json:"public,omitempty"`
	Upload *string `json:"upload,omitempty"`
}

// DeleteVersionFromBuildJSONBody defines parameters for DeleteVersionFromBuild.
type DeleteVersionFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListVersionBuildsParams defines parameters for ListVersionBuilds.
type ListVersionBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListVersionBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListVersionBuildsParamsOrder defines parameters for ListVersionBuilds.
type ListVersionBuildsParamsOrder string

// AttachVersionToBuildJSONBody defines parameters for AttachVersionToBuild.
type AttachVersionToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListNeoforgesParams defines parameters for ListNeoforges.
type ListNeoforgesParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`
}

// DeleteNeoforgeFromBuildJSONBody defines parameters for DeleteNeoforgeFromBuild.
type DeleteNeoforgeFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListNeoforgeBuildsParams defines parameters for ListNeoforgeBuilds.
type ListNeoforgeBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListNeoforgeBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListNeoforgeBuildsParamsOrder defines parameters for ListNeoforgeBuilds.
type ListNeoforgeBuildsParamsOrder string

// AttachNeoforgeToBuildJSONBody defines parameters for AttachNeoforgeToBuild.
type AttachNeoforgeToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListPacksParams defines parameters for ListPacks.
type ListPacksParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListPacksParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListPacksParamsOrder defines parameters for ListPacks.
type ListPacksParamsOrder string

// CreatePackJSONBody defines parameters for CreatePack.
type CreatePackJSONBody struct {
	Name    *string `json:"name,omitempty"`
	Public  *bool   `json:"public,omitempty"`
	Slug    *string `json:"slug,omitempty"`
	Website *string `json:"website,omitempty"`
}

// UpdatePackJSONBody defines parameters for UpdatePack.
type UpdatePackJSONBody struct {
	Name    *string `json:"name,omitempty"`
	Public  *bool   `json:"public,omitempty"`
	Slug    *string `json:"slug,omitempty"`
	Website *string `json:"website,omitempty"`
}

// CreatePackAvatarMultipartBody defines parameters for CreatePackAvatar.
type CreatePackAvatarMultipartBody struct {
	File *openapi_types.File `json:"file,omitempty"`
}

// ListBuildsParams defines parameters for ListBuilds.
type ListBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListBuildsParamsOrder defines parameters for ListBuilds.
type ListBuildsParamsOrder string

// CreateBuildJSONBody defines parameters for CreateBuild.
type CreateBuildJSONBody struct {
	FabricID    *string `json:"fabric_id,omitempty"`
	ForgeID     *string `json:"forge_id,omitempty"`
	Java        *string `json:"java,omitempty"`
	Latest      *bool   `json:"latest,omitempty"`
	Memory      *string `json:"memory,omitempty"`
	MinecraftID *string `json:"minecraft_id,omitempty"`
	Name        *string `json:"name,omitempty"`
	NeoforgeID  *string `json:"neoforge_id,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	QuiltID     *string `json:"quilt_id,omitempty"`
	Recommended *bool   `json:"recommended,omitempty"`
}

// UpdateBuildJSONBody defines parameters for UpdateBuild.
type UpdateBuildJSONBody struct {
	FabricID    *string `json:"fabric_id,omitempty"`
	ForgeID     *string `json:"forge_id,omitempty"`
	Java        *string `json:"java,omitempty"`
	Latest      *bool   `json:"latest,omitempty"`
	Memory      *string `json:"memory,omitempty"`
	MinecraftID *string `json:"minecraft_id,omitempty"`
	Name        *string `json:"name,omitempty"`
	NeoforgeID  *string `json:"neoforge_id,omitempty"`
	Public      *bool   `json:"public,omitempty"`
	QuiltID     *string `json:"quilt_id,omitempty"`
	Recommended *bool   `json:"recommended,omitempty"`
}

// DeleteBuildFromVersionJSONBody defines parameters for DeleteBuildFromVersion.
type DeleteBuildFromVersionJSONBody struct {
	Mod     string `json:"mod,omitempty"`
	Version string `json:"version,omitempty"`
}

// ListBuildVersionsParams defines parameters for ListBuildVersions.
type ListBuildVersionsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListBuildVersionsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListBuildVersionsParamsOrder defines parameters for ListBuildVersions.
type ListBuildVersionsParamsOrder string

// AttachBuildToVersionJSONBody defines parameters for AttachBuildToVersion.
type AttachBuildToVersionJSONBody struct {
	Mod     string `json:"mod,omitempty"`
	Version string `json:"version,omitempty"`
}

// DeletePackFromGroupJSONBody defines parameters for DeletePackFromGroup.
type DeletePackFromGroupJSONBody struct {
	Group string `json:"group"`
}

// ListPackGroupsParams defines parameters for ListPackGroups.
type ListPackGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListPackGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListPackGroupsParamsOrder defines parameters for ListPackGroups.
type ListPackGroupsParamsOrder string

// AttachPackToGroupJSONBody defines parameters for AttachPackToGroup.
type AttachPackToGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// PermitPackGroupJSONBody defines parameters for PermitPackGroup.
type PermitPackGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// DeletePackFromUserJSONBody defines parameters for DeletePackFromUser.
type DeletePackFromUserJSONBody struct {
	User string `json:"user"`
}

// ListPackUsersParams defines parameters for ListPackUsers.
type ListPackUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListPackUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListPackUsersParamsOrder defines parameters for ListPackUsers.
type ListPackUsersParamsOrder string

// AttachPackToUserJSONBody defines parameters for AttachPackToUser.
type AttachPackToUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// PermitPackUserJSONBody defines parameters for PermitPackUser.
type PermitPackUserJSONBody struct {
	Perm string `json:"perm"`
	User string `json:"user"`
}

// UpdateProfileJSONBody defines parameters for UpdateProfile.
type UpdateProfileJSONBody struct {
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// ListQuiltsParams defines parameters for ListQuilts.
type ListQuiltsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`
}

// DeleteQuiltFromBuildJSONBody defines parameters for DeleteQuiltFromBuild.
type DeleteQuiltFromBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListQuiltBuildsParams defines parameters for ListQuiltBuilds.
type ListQuiltBuildsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListQuiltBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListQuiltBuildsParamsOrder defines parameters for ListQuiltBuilds.
type ListQuiltBuildsParamsOrder string

// AttachQuiltToBuildJSONBody defines parameters for AttachQuiltToBuild.
type AttachQuiltToBuildJSONBody struct {
	Build string `json:"build,omitempty"`
	Pack  string `json:"pack,omitempty"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUsersParamsOrder defines parameters for ListUsers.
type ListUsersParamsOrder string

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody struct {
	Active   *bool   `json:"active,omitempty"`
	Admin    *bool   `json:"admin,omitempty"`
	Email    *string `json:"email,omitempty"`
	Fullname *string `json:"fullname,omitempty"`
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// DeleteUserFromGroupJSONBody defines parameters for DeleteUserFromGroup.
type DeleteUserFromGroupJSONBody struct {
	Group string `json:"group"`
}

// ListUserGroupsParams defines parameters for ListUserGroups.
type ListUserGroupsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUserGroupsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUserGroupsParamsOrder defines parameters for ListUserGroups.
type ListUserGroupsParamsOrder string

// AttachUserToGroupJSONBody defines parameters for AttachUserToGroup.
type AttachUserToGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// PermitUserGroupJSONBody defines parameters for PermitUserGroup.
type PermitUserGroupJSONBody struct {
	Group string `json:"group"`
	Perm  string `json:"perm"`
}

// DeleteUserFromModJSONBody defines parameters for DeleteUserFromMod.
type DeleteUserFromModJSONBody struct {
	Mod string `json:"mod"`
}

// ListUserModsParams defines parameters for ListUserMods.
type ListUserModsParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUserModsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUserModsParamsOrder defines parameters for ListUserMods.
type ListUserModsParamsOrder string

// AttachUserToModJSONBody defines parameters for AttachUserToMod.
type AttachUserToModJSONBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// PermitUserModJSONBody defines parameters for PermitUserMod.
type PermitUserModJSONBody struct {
	Mod  string `json:"mod"`
	Perm string `json:"perm"`
}

// DeleteUserFromPackJSONBody defines parameters for DeleteUserFromPack.
type DeleteUserFromPackJSONBody struct {
	Pack string `json:"pack"`
}

// ListUserPacksParams defines parameters for ListUserPacks.
type ListUserPacksParams struct {
	// Search Search query
	Search *SearchQueryParam `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *SortColumnParam `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUserPacksParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *PagingLimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *PagingOffsetParam `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUserPacksParamsOrder defines parameters for ListUserPacks.
type ListUserPacksParamsOrder string

// AttachUserToPackJSONBody defines parameters for AttachUserToPack.
type AttachUserToPackJSONBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// PermitUserPackJSONBody defines parameters for PermitUserPack.
type PermitUserPackJSONBody struct {
	Pack string `json:"pack"`
	Perm string `json:"perm"`
}

// LoginAuthJSONRequestBody defines body for LoginAuth for application/json ContentType.
type LoginAuthJSONRequestBody LoginAuthJSONBody

// RedirectAuthJSONRequestBody defines body for RedirectAuth for application/json ContentType.
type RedirectAuthJSONRequestBody RedirectAuthJSONBody

// DeleteFabricFromBuildJSONRequestBody defines body for DeleteFabricFromBuild for application/json ContentType.
type DeleteFabricFromBuildJSONRequestBody DeleteFabricFromBuildJSONBody

// AttachFabricToBuildJSONRequestBody defines body for AttachFabricToBuild for application/json ContentType.
type AttachFabricToBuildJSONRequestBody AttachFabricToBuildJSONBody

// DeleteForgeFromBuildJSONRequestBody defines body for DeleteForgeFromBuild for application/json ContentType.
type DeleteForgeFromBuildJSONRequestBody DeleteForgeFromBuildJSONBody

// AttachForgeToBuildJSONRequestBody defines body for AttachForgeToBuild for application/json ContentType.
type AttachForgeToBuildJSONRequestBody AttachForgeToBuildJSONBody

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody CreateGroupJSONBody

// UpdateGroupJSONRequestBody defines body for UpdateGroup for application/json ContentType.
type UpdateGroupJSONRequestBody UpdateGroupJSONBody

// DeleteGroupFromModJSONRequestBody defines body for DeleteGroupFromMod for application/json ContentType.
type DeleteGroupFromModJSONRequestBody DeleteGroupFromModJSONBody

// AttachGroupToModJSONRequestBody defines body for AttachGroupToMod for application/json ContentType.
type AttachGroupToModJSONRequestBody AttachGroupToModJSONBody

// PermitGroupModJSONRequestBody defines body for PermitGroupMod for application/json ContentType.
type PermitGroupModJSONRequestBody PermitGroupModJSONBody

// DeleteGroupFromPackJSONRequestBody defines body for DeleteGroupFromPack for application/json ContentType.
type DeleteGroupFromPackJSONRequestBody DeleteGroupFromPackJSONBody

// AttachGroupToPackJSONRequestBody defines body for AttachGroupToPack for application/json ContentType.
type AttachGroupToPackJSONRequestBody AttachGroupToPackJSONBody

// PermitGroupPackJSONRequestBody defines body for PermitGroupPack for application/json ContentType.
type PermitGroupPackJSONRequestBody PermitGroupPackJSONBody

// DeleteGroupFromUserJSONRequestBody defines body for DeleteGroupFromUser for application/json ContentType.
type DeleteGroupFromUserJSONRequestBody DeleteGroupFromUserJSONBody

// AttachGroupToUserJSONRequestBody defines body for AttachGroupToUser for application/json ContentType.
type AttachGroupToUserJSONRequestBody AttachGroupToUserJSONBody

// PermitGroupUserJSONRequestBody defines body for PermitGroupUser for application/json ContentType.
type PermitGroupUserJSONRequestBody PermitGroupUserJSONBody

// DeleteMinecraftFromBuildJSONRequestBody defines body for DeleteMinecraftFromBuild for application/json ContentType.
type DeleteMinecraftFromBuildJSONRequestBody DeleteMinecraftFromBuildJSONBody

// AttachMinecraftToBuildJSONRequestBody defines body for AttachMinecraftToBuild for application/json ContentType.
type AttachMinecraftToBuildJSONRequestBody AttachMinecraftToBuildJSONBody

// CreateModJSONRequestBody defines body for CreateMod for application/json ContentType.
type CreateModJSONRequestBody CreateModJSONBody

// UpdateModJSONRequestBody defines body for UpdateMod for application/json ContentType.
type UpdateModJSONRequestBody UpdateModJSONBody

// CreateModAvatarMultipartRequestBody defines body for CreateModAvatar for multipart/form-data ContentType.
type CreateModAvatarMultipartRequestBody CreateModAvatarMultipartBody

// DeleteModFromGroupJSONRequestBody defines body for DeleteModFromGroup for application/json ContentType.
type DeleteModFromGroupJSONRequestBody DeleteModFromGroupJSONBody

// AttachModToGroupJSONRequestBody defines body for AttachModToGroup for application/json ContentType.
type AttachModToGroupJSONRequestBody AttachModToGroupJSONBody

// PermitModGroupJSONRequestBody defines body for PermitModGroup for application/json ContentType.
type PermitModGroupJSONRequestBody PermitModGroupJSONBody

// DeleteModFromUserJSONRequestBody defines body for DeleteModFromUser for application/json ContentType.
type DeleteModFromUserJSONRequestBody DeleteModFromUserJSONBody

// AttachModToUserJSONRequestBody defines body for AttachModToUser for application/json ContentType.
type AttachModToUserJSONRequestBody AttachModToUserJSONBody

// PermitModUserJSONRequestBody defines body for PermitModUser for application/json ContentType.
type PermitModUserJSONRequestBody PermitModUserJSONBody

// CreateVersionJSONRequestBody defines body for CreateVersion for application/json ContentType.
type CreateVersionJSONRequestBody CreateVersionJSONBody

// UpdateVersionJSONRequestBody defines body for UpdateVersion for application/json ContentType.
type UpdateVersionJSONRequestBody UpdateVersionJSONBody

// DeleteVersionFromBuildJSONRequestBody defines body for DeleteVersionFromBuild for application/json ContentType.
type DeleteVersionFromBuildJSONRequestBody DeleteVersionFromBuildJSONBody

// AttachVersionToBuildJSONRequestBody defines body for AttachVersionToBuild for application/json ContentType.
type AttachVersionToBuildJSONRequestBody AttachVersionToBuildJSONBody

// DeleteNeoforgeFromBuildJSONRequestBody defines body for DeleteNeoforgeFromBuild for application/json ContentType.
type DeleteNeoforgeFromBuildJSONRequestBody DeleteNeoforgeFromBuildJSONBody

// AttachNeoforgeToBuildJSONRequestBody defines body for AttachNeoforgeToBuild for application/json ContentType.
type AttachNeoforgeToBuildJSONRequestBody AttachNeoforgeToBuildJSONBody

// CreatePackJSONRequestBody defines body for CreatePack for application/json ContentType.
type CreatePackJSONRequestBody CreatePackJSONBody

// UpdatePackJSONRequestBody defines body for UpdatePack for application/json ContentType.
type UpdatePackJSONRequestBody UpdatePackJSONBody

// CreatePackAvatarMultipartRequestBody defines body for CreatePackAvatar for multipart/form-data ContentType.
type CreatePackAvatarMultipartRequestBody CreatePackAvatarMultipartBody

// CreateBuildJSONRequestBody defines body for CreateBuild for application/json ContentType.
type CreateBuildJSONRequestBody CreateBuildJSONBody

// UpdateBuildJSONRequestBody defines body for UpdateBuild for application/json ContentType.
type UpdateBuildJSONRequestBody UpdateBuildJSONBody

// DeleteBuildFromVersionJSONRequestBody defines body for DeleteBuildFromVersion for application/json ContentType.
type DeleteBuildFromVersionJSONRequestBody DeleteBuildFromVersionJSONBody

// AttachBuildToVersionJSONRequestBody defines body for AttachBuildToVersion for application/json ContentType.
type AttachBuildToVersionJSONRequestBody AttachBuildToVersionJSONBody

// DeletePackFromGroupJSONRequestBody defines body for DeletePackFromGroup for application/json ContentType.
type DeletePackFromGroupJSONRequestBody DeletePackFromGroupJSONBody

// AttachPackToGroupJSONRequestBody defines body for AttachPackToGroup for application/json ContentType.
type AttachPackToGroupJSONRequestBody AttachPackToGroupJSONBody

// PermitPackGroupJSONRequestBody defines body for PermitPackGroup for application/json ContentType.
type PermitPackGroupJSONRequestBody PermitPackGroupJSONBody

// DeletePackFromUserJSONRequestBody defines body for DeletePackFromUser for application/json ContentType.
type DeletePackFromUserJSONRequestBody DeletePackFromUserJSONBody

// AttachPackToUserJSONRequestBody defines body for AttachPackToUser for application/json ContentType.
type AttachPackToUserJSONRequestBody AttachPackToUserJSONBody

// PermitPackUserJSONRequestBody defines body for PermitPackUser for application/json ContentType.
type PermitPackUserJSONRequestBody PermitPackUserJSONBody

// UpdateProfileJSONRequestBody defines body for UpdateProfile for application/json ContentType.
type UpdateProfileJSONRequestBody UpdateProfileJSONBody

// DeleteQuiltFromBuildJSONRequestBody defines body for DeleteQuiltFromBuild for application/json ContentType.
type DeleteQuiltFromBuildJSONRequestBody DeleteQuiltFromBuildJSONBody

// AttachQuiltToBuildJSONRequestBody defines body for AttachQuiltToBuild for application/json ContentType.
type AttachQuiltToBuildJSONRequestBody AttachQuiltToBuildJSONBody

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// DeleteUserFromGroupJSONRequestBody defines body for DeleteUserFromGroup for application/json ContentType.
type DeleteUserFromGroupJSONRequestBody DeleteUserFromGroupJSONBody

// AttachUserToGroupJSONRequestBody defines body for AttachUserToGroup for application/json ContentType.
type AttachUserToGroupJSONRequestBody AttachUserToGroupJSONBody

// PermitUserGroupJSONRequestBody defines body for PermitUserGroup for application/json ContentType.
type PermitUserGroupJSONRequestBody PermitUserGroupJSONBody

// DeleteUserFromModJSONRequestBody defines body for DeleteUserFromMod for application/json ContentType.
type DeleteUserFromModJSONRequestBody DeleteUserFromModJSONBody

// AttachUserToModJSONRequestBody defines body for AttachUserToMod for application/json ContentType.
type AttachUserToModJSONRequestBody AttachUserToModJSONBody

// PermitUserModJSONRequestBody defines body for PermitUserMod for application/json ContentType.
type PermitUserModJSONRequestBody PermitUserModJSONBody

// DeleteUserFromPackJSONRequestBody defines body for DeleteUserFromPack for application/json ContentType.
type DeleteUserFromPackJSONRequestBody DeleteUserFromPackJSONBody

// AttachUserToPackJSONRequestBody defines body for AttachUserToPack for application/json ContentType.
type AttachUserToPackJSONRequestBody AttachUserToPackJSONBody

// PermitUserPackJSONRequestBody defines body for PermitUserPack for application/json ContentType.
type PermitUserPackJSONRequestBody PermitUserPackJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// LoginAuthWithBody request with any body
	LoginAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoginAuth(ctx context.Context, body LoginAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProviders request
	ListProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RedirectAuthWithBody request with any body
	RedirectAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RedirectAuth(ctx context.Context, body RedirectAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshAuth request
	RefreshAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyAuth request
	VerifyAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CallbackProvider request
	CallbackProvider(ctx context.Context, provider AuthProviderParam, params *CallbackProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RequestProvider request
	RequestProvider(ctx context.Context, provider AuthProviderParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFabrics request
	ListFabrics(ctx context.Context, params *ListFabricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFabric request
	UpdateFabric(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFabricFromBuildWithBody request with any body
	DeleteFabricFromBuildWithBody(ctx context.Context, fabricID FabricID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteFabricFromBuild(ctx context.Context, fabricID FabricID, body DeleteFabricFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFabricBuilds request
	ListFabricBuilds(ctx context.Context, fabricID FabricID, params *ListFabricBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachFabricToBuildWithBody request with any body
	AttachFabricToBuildWithBody(ctx context.Context, fabricID FabricID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachFabricToBuild(ctx context.Context, fabricID FabricID, body AttachFabricToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListForges request
	ListForges(ctx context.Context, params *ListForgesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateForge request
	UpdateForge(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteForgeFromBuildWithBody request with any body
	DeleteForgeFromBuildWithBody(ctx context.Context, forgeID ForgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteForgeFromBuild(ctx context.Context, forgeID ForgeID, body DeleteForgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListForgeBuilds request
	ListForgeBuilds(ctx context.Context, forgeID ForgeID, params *ListForgeBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachForgeToBuildWithBody request with any body
	AttachForgeToBuildWithBody(ctx context.Context, forgeID ForgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachForgeToBuild(ctx context.Context, forgeID ForgeID, body AttachForgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroups request
	ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroupWithBody request with any body
	CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowGroup request
	ShowGroup(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGroupWithBody request with any body
	UpdateGroupWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGroup(ctx context.Context, groupID GroupID, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupFromModWithBody request with any body
	DeleteGroupFromModWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteGroupFromMod(ctx context.Context, groupID GroupID, body DeleteGroupFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupMods request
	ListGroupMods(ctx context.Context, groupID GroupID, params *ListGroupModsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachGroupToModWithBody request with any body
	AttachGroupToModWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachGroupToMod(ctx context.Context, groupID GroupID, body AttachGroupToModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitGroupModWithBody request with any body
	PermitGroupModWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitGroupMod(ctx context.Context, groupID GroupID, body PermitGroupModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupFromPackWithBody request with any body
	DeleteGroupFromPackWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteGroupFromPack(ctx context.Context, groupID GroupID, body DeleteGroupFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupPacks request
	ListGroupPacks(ctx context.Context, groupID GroupID, params *ListGroupPacksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachGroupToPackWithBody request with any body
	AttachGroupToPackWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachGroupToPack(ctx context.Context, groupID GroupID, body AttachGroupToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitGroupPackWithBody request with any body
	PermitGroupPackWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitGroupPack(ctx context.Context, groupID GroupID, body PermitGroupPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupFromUserWithBody request with any body
	DeleteGroupFromUserWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteGroupFromUser(ctx context.Context, groupID GroupID, body DeleteGroupFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGroupUsers request
	ListGroupUsers(ctx context.Context, groupID GroupID, params *ListGroupUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachGroupToUserWithBody request with any body
	AttachGroupToUserWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachGroupToUser(ctx context.Context, groupID GroupID, body AttachGroupToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitGroupUserWithBody request with any body
	PermitGroupUserWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitGroupUser(ctx context.Context, groupID GroupID, body PermitGroupUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMinecrafts request
	ListMinecrafts(ctx context.Context, params *ListMinecraftsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMinecraft request
	UpdateMinecraft(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMinecraftFromBuildWithBody request with any body
	DeleteMinecraftFromBuildWithBody(ctx context.Context, minecraftID MinecraftID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteMinecraftFromBuild(ctx context.Context, minecraftID MinecraftID, body DeleteMinecraftFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMinecraftBuilds request
	ListMinecraftBuilds(ctx context.Context, minecraftID MinecraftID, params *ListMinecraftBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachMinecraftToBuildWithBody request with any body
	AttachMinecraftToBuildWithBody(ctx context.Context, minecraftID MinecraftID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachMinecraftToBuild(ctx context.Context, minecraftID MinecraftID, body AttachMinecraftToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMods request
	ListMods(ctx context.Context, params *ListModsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateModWithBody request with any body
	CreateModWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMod(ctx context.Context, body CreateModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMod request
	DeleteMod(ctx context.Context, modID ModID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowMod request
	ShowMod(ctx context.Context, modID ModID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateModWithBody request with any body
	UpdateModWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMod(ctx context.Context, modID ModID, body UpdateModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteModAvatar request
	DeleteModAvatar(ctx context.Context, modID ModID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateModAvatarWithBody request with any body
	CreateModAvatarWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteModFromGroupWithBody request with any body
	DeleteModFromGroupWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteModFromGroup(ctx context.Context, modID ModID, body DeleteModFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListModGroups request
	ListModGroups(ctx context.Context, modID ModID, params *ListModGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachModToGroupWithBody request with any body
	AttachModToGroupWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachModToGroup(ctx context.Context, modID ModID, body AttachModToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitModGroupWithBody request with any body
	PermitModGroupWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitModGroup(ctx context.Context, modID ModID, body PermitModGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteModFromUserWithBody request with any body
	DeleteModFromUserWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteModFromUser(ctx context.Context, modID ModID, body DeleteModFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListModUsers request
	ListModUsers(ctx context.Context, modID ModID, params *ListModUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachModToUserWithBody request with any body
	AttachModToUserWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachModToUser(ctx context.Context, modID ModID, body AttachModToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitModUserWithBody request with any body
	PermitModUserWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitModUser(ctx context.Context, modID ModID, body PermitModUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVersions request
	ListVersions(ctx context.Context, modID ModID, params *ListVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVersionWithBody request with any body
	CreateVersionWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVersion(ctx context.Context, modID ModID, body CreateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVersion request
	DeleteVersion(ctx context.Context, modID ModID, versionID VersionID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowVersion request
	ShowVersion(ctx context.Context, modID ModID, versionID VersionID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVersionWithBody request with any body
	UpdateVersionWithBody(ctx context.Context, modID ModID, versionID VersionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVersion(ctx context.Context, modID ModID, versionID VersionID, body UpdateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVersionFromBuildWithBody request with any body
	DeleteVersionFromBuildWithBody(ctx context.Context, modID ModID, versionID VersionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteVersionFromBuild(ctx context.Context, modID ModID, versionID VersionID, body DeleteVersionFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVersionBuilds request
	ListVersionBuilds(ctx context.Context, modID ModID, versionID VersionID, params *ListVersionBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachVersionToBuildWithBody request with any body
	AttachVersionToBuildWithBody(ctx context.Context, modID ModID, versionID VersionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachVersionToBuild(ctx context.Context, modID ModID, versionID VersionID, body AttachVersionToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNeoforges request
	ListNeoforges(ctx context.Context, params *ListNeoforgesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNeoforge request
	UpdateNeoforge(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNeoforgeFromBuildWithBody request with any body
	DeleteNeoforgeFromBuildWithBody(ctx context.Context, neoforgeID NeoforgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteNeoforgeFromBuild(ctx context.Context, neoforgeID NeoforgeID, body DeleteNeoforgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNeoforgeBuilds request
	ListNeoforgeBuilds(ctx context.Context, neoforgeID NeoforgeID, params *ListNeoforgeBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachNeoforgeToBuildWithBody request with any body
	AttachNeoforgeToBuildWithBody(ctx context.Context, neoforgeID NeoforgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachNeoforgeToBuild(ctx context.Context, neoforgeID NeoforgeID, body AttachNeoforgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPacks request
	ListPacks(ctx context.Context, params *ListPacksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePackWithBody request with any body
	CreatePackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePack(ctx context.Context, body CreatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePack request
	DeletePack(ctx context.Context, packID PackID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowPack request
	ShowPack(ctx context.Context, packID PackID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePackWithBody request with any body
	UpdatePackWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePack(ctx context.Context, packID PackID, body UpdatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePackAvatar request
	DeletePackAvatar(ctx context.Context, packID PackID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePackAvatarWithBody request with any body
	CreatePackAvatarWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBuilds request
	ListBuilds(ctx context.Context, packID PackID, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBuildWithBody request with any body
	CreateBuildWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBuild(ctx context.Context, packID PackID, body CreateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBuild request
	DeleteBuild(ctx context.Context, packID PackID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowBuild request
	ShowBuild(ctx context.Context, packID PackID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBuildWithBody request with any body
	UpdateBuildWithBody(ctx context.Context, packID PackID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBuild(ctx context.Context, packID PackID, buildID BuildID, body UpdateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBuildFromVersionWithBody request with any body
	DeleteBuildFromVersionWithBody(ctx context.Context, packID PackID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteBuildFromVersion(ctx context.Context, packID PackID, buildID BuildID, body DeleteBuildFromVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBuildVersions request
	ListBuildVersions(ctx context.Context, packID PackID, buildID BuildID, params *ListBuildVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachBuildToVersionWithBody request with any body
	AttachBuildToVersionWithBody(ctx context.Context, packID PackID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachBuildToVersion(ctx context.Context, packID PackID, buildID BuildID, body AttachBuildToVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePackFromGroupWithBody request with any body
	DeletePackFromGroupWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePackFromGroup(ctx context.Context, packID PackID, body DeletePackFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPackGroups request
	ListPackGroups(ctx context.Context, packID PackID, params *ListPackGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachPackToGroupWithBody request with any body
	AttachPackToGroupWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachPackToGroup(ctx context.Context, packID PackID, body AttachPackToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitPackGroupWithBody request with any body
	PermitPackGroupWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitPackGroup(ctx context.Context, packID PackID, body PermitPackGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePackFromUserWithBody request with any body
	DeletePackFromUserWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePackFromUser(ctx context.Context, packID PackID, body DeletePackFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPackUsers request
	ListPackUsers(ctx context.Context, packID PackID, params *ListPackUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachPackToUserWithBody request with any body
	AttachPackToUserWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachPackToUser(ctx context.Context, packID PackID, body AttachPackToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitPackUserWithBody request with any body
	PermitPackUserWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitPackUser(ctx context.Context, packID PackID, body PermitPackUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowProfile request
	ShowProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProfileWithBody request with any body
	UpdateProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProfile(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokenProfile request
	TokenProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListQuilts request
	ListQuilts(ctx context.Context, params *ListQuiltsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateQuilt request
	UpdateQuilt(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteQuiltFromBuildWithBody request with any body
	DeleteQuiltFromBuildWithBody(ctx context.Context, quiltID QuiltID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteQuiltFromBuild(ctx context.Context, quiltID QuiltID, body DeleteQuiltFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListQuiltBuilds request
	ListQuiltBuilds(ctx context.Context, quiltID QuiltID, params *ListQuiltBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachQuiltToBuildWithBody request with any body
	AttachQuiltToBuildWithBody(ctx context.Context, quiltID QuiltID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachQuiltToBuild(ctx context.Context, quiltID QuiltID, body AttachQuiltToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowUser request
	ShowUser(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, userID UserID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserFromGroupWithBody request with any body
	DeleteUserFromGroupWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteUserFromGroup(ctx context.Context, userID UserID, body DeleteUserFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserGroups request
	ListUserGroups(ctx context.Context, userID UserID, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachUserToGroupWithBody request with any body
	AttachUserToGroupWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachUserToGroup(ctx context.Context, userID UserID, body AttachUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitUserGroupWithBody request with any body
	PermitUserGroupWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitUserGroup(ctx context.Context, userID UserID, body PermitUserGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserFromModWithBody request with any body
	DeleteUserFromModWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteUserFromMod(ctx context.Context, userID UserID, body DeleteUserFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserMods request
	ListUserMods(ctx context.Context, userID UserID, params *ListUserModsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachUserToModWithBody request with any body
	AttachUserToModWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachUserToMod(ctx context.Context, userID UserID, body AttachUserToModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitUserModWithBody request with any body
	PermitUserModWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitUserMod(ctx context.Context, userID UserID, body PermitUserModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserFromPackWithBody request with any body
	DeleteUserFromPackWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteUserFromPack(ctx context.Context, userID UserID, body DeleteUserFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserPacks request
	ListUserPacks(ctx context.Context, userID UserID, params *ListUserPacksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachUserToPackWithBody request with any body
	AttachUserToPackWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachUserToPack(ctx context.Context, userID UserID, body AttachUserToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitUserPackWithBody request with any body
	PermitUserPackWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitUserPack(ctx context.Context, userID UserID, body PermitUserPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) LoginAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginAuthRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginAuth(ctx context.Context, body LoginAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginAuthRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProvidersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RedirectAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRedirectAuthRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RedirectAuth(ctx context.Context, body RedirectAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRedirectAuthRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshAuthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyAuthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CallbackProvider(ctx context.Context, provider AuthProviderParam, params *CallbackProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCallbackProviderRequest(c.Server, provider, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RequestProvider(ctx context.Context, provider AuthProviderParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRequestProviderRequest(c.Server, provider)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFabrics(ctx context.Context, params *ListFabricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFabricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFabric(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFabricRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFabricFromBuildWithBody(ctx context.Context, fabricID FabricID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFabricFromBuildRequestWithBody(c.Server, fabricID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFabricFromBuild(ctx context.Context, fabricID FabricID, body DeleteFabricFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFabricFromBuildRequest(c.Server, fabricID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFabricBuilds(ctx context.Context, fabricID FabricID, params *ListFabricBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFabricBuildsRequest(c.Server, fabricID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachFabricToBuildWithBody(ctx context.Context, fabricID FabricID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachFabricToBuildRequestWithBody(c.Server, fabricID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachFabricToBuild(ctx context.Context, fabricID FabricID, body AttachFabricToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachFabricToBuildRequest(c.Server, fabricID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListForges(ctx context.Context, params *ListForgesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListForgesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateForge(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateForgeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteForgeFromBuildWithBody(ctx context.Context, forgeID ForgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteForgeFromBuildRequestWithBody(c.Server, forgeID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteForgeFromBuild(ctx context.Context, forgeID ForgeID, body DeleteForgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteForgeFromBuildRequest(c.Server, forgeID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListForgeBuilds(ctx context.Context, forgeID ForgeID, params *ListForgeBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListForgeBuildsRequest(c.Server, forgeID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachForgeToBuildWithBody(ctx context.Context, forgeID ForgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachForgeToBuildRequestWithBody(c.Server, forgeID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachForgeToBuild(ctx context.Context, forgeID ForgeID, body AttachForgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachForgeToBuildRequest(c.Server, forgeID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroups(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, groupID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowGroup(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowGroupRequest(c.Server, groupID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroup(ctx context.Context, groupID GroupID, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupFromModWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupFromModRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupFromMod(ctx context.Context, groupID GroupID, body DeleteGroupFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupFromModRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupMods(ctx context.Context, groupID GroupID, params *ListGroupModsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupModsRequest(c.Server, groupID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachGroupToModWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachGroupToModRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachGroupToMod(ctx context.Context, groupID GroupID, body AttachGroupToModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachGroupToModRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitGroupModWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitGroupModRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitGroupMod(ctx context.Context, groupID GroupID, body PermitGroupModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitGroupModRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupFromPackWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupFromPackRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupFromPack(ctx context.Context, groupID GroupID, body DeleteGroupFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupFromPackRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupPacks(ctx context.Context, groupID GroupID, params *ListGroupPacksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupPacksRequest(c.Server, groupID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachGroupToPackWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachGroupToPackRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachGroupToPack(ctx context.Context, groupID GroupID, body AttachGroupToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachGroupToPackRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitGroupPackWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitGroupPackRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitGroupPack(ctx context.Context, groupID GroupID, body PermitGroupPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitGroupPackRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupFromUserWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupFromUserRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupFromUser(ctx context.Context, groupID GroupID, body DeleteGroupFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupFromUserRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGroupUsers(ctx context.Context, groupID GroupID, params *ListGroupUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupUsersRequest(c.Server, groupID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachGroupToUserWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachGroupToUserRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachGroupToUser(ctx context.Context, groupID GroupID, body AttachGroupToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachGroupToUserRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitGroupUserWithBody(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitGroupUserRequestWithBody(c.Server, groupID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitGroupUser(ctx context.Context, groupID GroupID, body PermitGroupUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitGroupUserRequest(c.Server, groupID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMinecrafts(ctx context.Context, params *ListMinecraftsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMinecraftsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMinecraft(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMinecraftRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMinecraftFromBuildWithBody(ctx context.Context, minecraftID MinecraftID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMinecraftFromBuildRequestWithBody(c.Server, minecraftID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMinecraftFromBuild(ctx context.Context, minecraftID MinecraftID, body DeleteMinecraftFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMinecraftFromBuildRequest(c.Server, minecraftID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMinecraftBuilds(ctx context.Context, minecraftID MinecraftID, params *ListMinecraftBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMinecraftBuildsRequest(c.Server, minecraftID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachMinecraftToBuildWithBody(ctx context.Context, minecraftID MinecraftID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachMinecraftToBuildRequestWithBody(c.Server, minecraftID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachMinecraftToBuild(ctx context.Context, minecraftID MinecraftID, body AttachMinecraftToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachMinecraftToBuildRequest(c.Server, minecraftID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMods(ctx context.Context, params *ListModsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMod(ctx context.Context, body CreateModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMod(ctx context.Context, modID ModID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModRequest(c.Server, modID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowMod(ctx context.Context, modID ModID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowModRequest(c.Server, modID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateModWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateModRequestWithBody(c.Server, modID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMod(ctx context.Context, modID ModID, body UpdateModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateModRequest(c.Server, modID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModAvatar(ctx context.Context, modID ModID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModAvatarRequest(c.Server, modID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModAvatarWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModAvatarRequestWithBody(c.Server, modID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModFromGroupWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModFromGroupRequestWithBody(c.Server, modID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModFromGroup(ctx context.Context, modID ModID, body DeleteModFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModFromGroupRequest(c.Server, modID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListModGroups(ctx context.Context, modID ModID, params *ListModGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModGroupsRequest(c.Server, modID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachModToGroupWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachModToGroupRequestWithBody(c.Server, modID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachModToGroup(ctx context.Context, modID ModID, body AttachModToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachModToGroupRequest(c.Server, modID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitModGroupWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitModGroupRequestWithBody(c.Server, modID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitModGroup(ctx context.Context, modID ModID, body PermitModGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitModGroupRequest(c.Server, modID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModFromUserWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModFromUserRequestWithBody(c.Server, modID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModFromUser(ctx context.Context, modID ModID, body DeleteModFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModFromUserRequest(c.Server, modID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListModUsers(ctx context.Context, modID ModID, params *ListModUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModUsersRequest(c.Server, modID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachModToUserWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachModToUserRequestWithBody(c.Server, modID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachModToUser(ctx context.Context, modID ModID, body AttachModToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachModToUserRequest(c.Server, modID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitModUserWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitModUserRequestWithBody(c.Server, modID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitModUser(ctx context.Context, modID ModID, body PermitModUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitModUserRequest(c.Server, modID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVersions(ctx context.Context, modID ModID, params *ListVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVersionsRequest(c.Server, modID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVersionWithBody(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVersionRequestWithBody(c.Server, modID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVersion(ctx context.Context, modID ModID, body CreateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVersionRequest(c.Server, modID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVersion(ctx context.Context, modID ModID, versionID VersionID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVersionRequest(c.Server, modID, versionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowVersion(ctx context.Context, modID ModID, versionID VersionID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowVersionRequest(c.Server, modID, versionID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVersionWithBody(ctx context.Context, modID ModID, versionID VersionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVersionRequestWithBody(c.Server, modID, versionID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVersion(ctx context.Context, modID ModID, versionID VersionID, body UpdateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVersionRequest(c.Server, modID, versionID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVersionFromBuildWithBody(ctx context.Context, modID ModID, versionID VersionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVersionFromBuildRequestWithBody(c.Server, modID, versionID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVersionFromBuild(ctx context.Context, modID ModID, versionID VersionID, body DeleteVersionFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVersionFromBuildRequest(c.Server, modID, versionID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVersionBuilds(ctx context.Context, modID ModID, versionID VersionID, params *ListVersionBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVersionBuildsRequest(c.Server, modID, versionID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachVersionToBuildWithBody(ctx context.Context, modID ModID, versionID VersionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachVersionToBuildRequestWithBody(c.Server, modID, versionID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachVersionToBuild(ctx context.Context, modID ModID, versionID VersionID, body AttachVersionToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachVersionToBuildRequest(c.Server, modID, versionID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNeoforges(ctx context.Context, params *ListNeoforgesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNeoforgesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNeoforge(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNeoforgeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNeoforgeFromBuildWithBody(ctx context.Context, neoforgeID NeoforgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNeoforgeFromBuildRequestWithBody(c.Server, neoforgeID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNeoforgeFromBuild(ctx context.Context, neoforgeID NeoforgeID, body DeleteNeoforgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNeoforgeFromBuildRequest(c.Server, neoforgeID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNeoforgeBuilds(ctx context.Context, neoforgeID NeoforgeID, params *ListNeoforgeBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNeoforgeBuildsRequest(c.Server, neoforgeID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachNeoforgeToBuildWithBody(ctx context.Context, neoforgeID NeoforgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachNeoforgeToBuildRequestWithBody(c.Server, neoforgeID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachNeoforgeToBuild(ctx context.Context, neoforgeID NeoforgeID, body AttachNeoforgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachNeoforgeToBuildRequest(c.Server, neoforgeID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPacks(ctx context.Context, params *ListPacksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPacksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePackRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePack(ctx context.Context, body CreatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePackRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePack(ctx context.Context, packID PackID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackRequest(c.Server, packID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowPack(ctx context.Context, packID PackID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowPackRequest(c.Server, packID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePackWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePackRequestWithBody(c.Server, packID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePack(ctx context.Context, packID PackID, body UpdatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePackRequest(c.Server, packID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackAvatar(ctx context.Context, packID PackID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackAvatarRequest(c.Server, packID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePackAvatarWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePackAvatarRequestWithBody(c.Server, packID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBuilds(ctx context.Context, packID PackID, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBuildsRequest(c.Server, packID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBuildWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBuildRequestWithBody(c.Server, packID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBuild(ctx context.Context, packID PackID, body CreateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBuildRequest(c.Server, packID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBuild(ctx context.Context, packID PackID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBuildRequest(c.Server, packID, buildID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowBuild(ctx context.Context, packID PackID, buildID BuildID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowBuildRequest(c.Server, packID, buildID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBuildWithBody(ctx context.Context, packID PackID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBuildRequestWithBody(c.Server, packID, buildID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBuild(ctx context.Context, packID PackID, buildID BuildID, body UpdateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBuildRequest(c.Server, packID, buildID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBuildFromVersionWithBody(ctx context.Context, packID PackID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBuildFromVersionRequestWithBody(c.Server, packID, buildID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBuildFromVersion(ctx context.Context, packID PackID, buildID BuildID, body DeleteBuildFromVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBuildFromVersionRequest(c.Server, packID, buildID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBuildVersions(ctx context.Context, packID PackID, buildID BuildID, params *ListBuildVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBuildVersionsRequest(c.Server, packID, buildID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachBuildToVersionWithBody(ctx context.Context, packID PackID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachBuildToVersionRequestWithBody(c.Server, packID, buildID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachBuildToVersion(ctx context.Context, packID PackID, buildID BuildID, body AttachBuildToVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachBuildToVersionRequest(c.Server, packID, buildID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackFromGroupWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackFromGroupRequestWithBody(c.Server, packID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackFromGroup(ctx context.Context, packID PackID, body DeletePackFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackFromGroupRequest(c.Server, packID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPackGroups(ctx context.Context, packID PackID, params *ListPackGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPackGroupsRequest(c.Server, packID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPackToGroupWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPackToGroupRequestWithBody(c.Server, packID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPackToGroup(ctx context.Context, packID PackID, body AttachPackToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPackToGroupRequest(c.Server, packID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitPackGroupWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitPackGroupRequestWithBody(c.Server, packID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitPackGroup(ctx context.Context, packID PackID, body PermitPackGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitPackGroupRequest(c.Server, packID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackFromUserWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackFromUserRequestWithBody(c.Server, packID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackFromUser(ctx context.Context, packID PackID, body DeletePackFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackFromUserRequest(c.Server, packID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPackUsers(ctx context.Context, packID PackID, params *ListPackUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPackUsersRequest(c.Server, packID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPackToUserWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPackToUserRequestWithBody(c.Server, packID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPackToUser(ctx context.Context, packID PackID, body AttachPackToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPackToUserRequest(c.Server, packID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitPackUserWithBody(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitPackUserRequestWithBody(c.Server, packID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitPackUser(ctx context.Context, packID PackID, body PermitPackUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitPackUserRequest(c.Server, packID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowProfileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProfileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProfile(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProfileRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenProfileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListQuilts(ctx context.Context, params *ListQuiltsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListQuiltsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateQuilt(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateQuiltRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteQuiltFromBuildWithBody(ctx context.Context, quiltID QuiltID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteQuiltFromBuildRequestWithBody(c.Server, quiltID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteQuiltFromBuild(ctx context.Context, quiltID QuiltID, body DeleteQuiltFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteQuiltFromBuildRequest(c.Server, quiltID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListQuiltBuilds(ctx context.Context, quiltID QuiltID, params *ListQuiltBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListQuiltBuildsRequest(c.Server, quiltID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachQuiltToBuildWithBody(ctx context.Context, quiltID QuiltID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachQuiltToBuildRequestWithBody(c.Server, quiltID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachQuiltToBuild(ctx context.Context, quiltID QuiltID, body AttachQuiltToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachQuiltToBuildRequest(c.Server, quiltID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowUser(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowUserRequest(c.Server, userID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, userID UserID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromGroupWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromGroupRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromGroup(ctx context.Context, userID UserID, body DeleteUserFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromGroupRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserGroups(ctx context.Context, userID UserID, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserGroupsRequest(c.Server, userID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToGroupWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToGroupRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToGroup(ctx context.Context, userID UserID, body AttachUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToGroupRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserGroupWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserGroupRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserGroup(ctx context.Context, userID UserID, body PermitUserGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserGroupRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromModWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromModRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromMod(ctx context.Context, userID UserID, body DeleteUserFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromModRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserMods(ctx context.Context, userID UserID, params *ListUserModsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserModsRequest(c.Server, userID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToModWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToModRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToMod(ctx context.Context, userID UserID, body AttachUserToModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToModRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserModWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserModRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserMod(ctx context.Context, userID UserID, body PermitUserModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserModRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromPackWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromPackRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromPack(ctx context.Context, userID UserID, body DeleteUserFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromPackRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserPacks(ctx context.Context, userID UserID, params *ListUserPacksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserPacksRequest(c.Server, userID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToPackWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToPackRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToPack(ctx context.Context, userID UserID, body AttachUserToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToPackRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserPackWithBody(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserPackRequestWithBody(c.Server, userID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserPack(ctx context.Context, userID UserID, body PermitUserPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserPackRequest(c.Server, userID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewLoginAuthRequest calls the generic LoginAuth builder with application/json body
func NewLoginAuthRequest(server string, body LoginAuthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginAuthRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginAuthRequestWithBody generates requests for LoginAuth with any type of body
func NewLoginAuthRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProvidersRequest generates requests for ListProviders
func NewListProvidersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRedirectAuthRequest calls the generic RedirectAuth builder with application/json body
func NewRedirectAuthRequest(server string, body RedirectAuthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRedirectAuthRequestWithBody(server, "application/json", bodyReader)
}

// NewRedirectAuthRequestWithBody generates requests for RedirectAuth with any type of body
func NewRedirectAuthRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/redirect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefreshAuthRequest generates requests for RefreshAuth
func NewRefreshAuthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerifyAuthRequest generates requests for VerifyAuth
func NewVerifyAuthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/verify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCallbackProviderRequest generates requests for CallbackProvider
func NewCallbackProviderRequest(server string, provider AuthProviderParam, params *CallbackProviderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/%s/callback", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRequestProviderRequest generates requests for RequestProvider
func NewRequestProviderRequest(server string, provider AuthProviderParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/%s/request", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFabricsRequest generates requests for ListFabrics
func NewListFabricsRequest(server string, params *ListFabricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fabric")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFabricRequest generates requests for UpdateFabric
func NewUpdateFabricRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fabric")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteFabricFromBuildRequest calls the generic DeleteFabricFromBuild builder with application/json body
func NewDeleteFabricFromBuildRequest(server string, fabricID FabricID, body DeleteFabricFromBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteFabricFromBuildRequestWithBody(server, fabricID, "application/json", bodyReader)
}

// NewDeleteFabricFromBuildRequestWithBody generates requests for DeleteFabricFromBuild with any type of body
func NewDeleteFabricFromBuildRequestWithBody(server string, fabricID FabricID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fabric_id", runtime.ParamLocationPath, fabricID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fabric/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFabricBuildsRequest generates requests for ListFabricBuilds
func NewListFabricBuildsRequest(server string, fabricID FabricID, params *ListFabricBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fabric_id", runtime.ParamLocationPath, fabricID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fabric/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachFabricToBuildRequest calls the generic AttachFabricToBuild builder with application/json body
func NewAttachFabricToBuildRequest(server string, fabricID FabricID, body AttachFabricToBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachFabricToBuildRequestWithBody(server, fabricID, "application/json", bodyReader)
}

// NewAttachFabricToBuildRequestWithBody generates requests for AttachFabricToBuild with any type of body
func NewAttachFabricToBuildRequestWithBody(server string, fabricID FabricID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fabric_id", runtime.ParamLocationPath, fabricID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fabric/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListForgesRequest generates requests for ListForges
func NewListForgesRequest(server string, params *ListForgesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/forge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateForgeRequest generates requests for UpdateForge
func NewUpdateForgeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/forge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteForgeFromBuildRequest calls the generic DeleteForgeFromBuild builder with application/json body
func NewDeleteForgeFromBuildRequest(server string, forgeID ForgeID, body DeleteForgeFromBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteForgeFromBuildRequestWithBody(server, forgeID, "application/json", bodyReader)
}

// NewDeleteForgeFromBuildRequestWithBody generates requests for DeleteForgeFromBuild with any type of body
func NewDeleteForgeFromBuildRequestWithBody(server string, forgeID ForgeID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "forge_id", runtime.ParamLocationPath, forgeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/forge/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListForgeBuildsRequest generates requests for ListForgeBuilds
func NewListForgeBuildsRequest(server string, forgeID ForgeID, params *ListForgeBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "forge_id", runtime.ParamLocationPath, forgeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/forge/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachForgeToBuildRequest calls the generic AttachForgeToBuild builder with application/json body
func NewAttachForgeToBuildRequest(server string, forgeID ForgeID, body AttachForgeToBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachForgeToBuildRequestWithBody(server, forgeID, "application/json", bodyReader)
}

// NewAttachForgeToBuildRequestWithBody generates requests for AttachForgeToBuild with any type of body
func NewAttachForgeToBuildRequestWithBody(server string, forgeID ForgeID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "forge_id", runtime.ParamLocationPath, forgeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/forge/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGroupsRequest generates requests for ListGroups
func NewListGroupsRequest(server string, params *ListGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, groupID GroupID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowGroupRequest generates requests for ShowGroup
func NewShowGroupRequest(server string, groupID GroupID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGroupRequest calls the generic UpdateGroup builder with application/json body
func NewUpdateGroupRequest(server string, groupID GroupID, body UpdateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGroupRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewUpdateGroupRequestWithBody generates requests for UpdateGroup with any type of body
func NewUpdateGroupRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupFromModRequest calls the generic DeleteGroupFromMod builder with application/json body
func NewDeleteGroupFromModRequest(server string, groupID GroupID, body DeleteGroupFromModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteGroupFromModRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewDeleteGroupFromModRequestWithBody generates requests for DeleteGroupFromMod with any type of body
func NewDeleteGroupFromModRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGroupModsRequest generates requests for ListGroupMods
func NewListGroupModsRequest(server string, groupID GroupID, params *ListGroupModsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachGroupToModRequest calls the generic AttachGroupToMod builder with application/json body
func NewAttachGroupToModRequest(server string, groupID GroupID, body AttachGroupToModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachGroupToModRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewAttachGroupToModRequestWithBody generates requests for AttachGroupToMod with any type of body
func NewAttachGroupToModRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitGroupModRequest calls the generic PermitGroupMod builder with application/json body
func NewPermitGroupModRequest(server string, groupID GroupID, body PermitGroupModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitGroupModRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewPermitGroupModRequestWithBody generates requests for PermitGroupMod with any type of body
func NewPermitGroupModRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupFromPackRequest calls the generic DeleteGroupFromPack builder with application/json body
func NewDeleteGroupFromPackRequest(server string, groupID GroupID, body DeleteGroupFromPackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteGroupFromPackRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewDeleteGroupFromPackRequestWithBody generates requests for DeleteGroupFromPack with any type of body
func NewDeleteGroupFromPackRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGroupPacksRequest generates requests for ListGroupPacks
func NewListGroupPacksRequest(server string, groupID GroupID, params *ListGroupPacksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachGroupToPackRequest calls the generic AttachGroupToPack builder with application/json body
func NewAttachGroupToPackRequest(server string, groupID GroupID, body AttachGroupToPackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachGroupToPackRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewAttachGroupToPackRequestWithBody generates requests for AttachGroupToPack with any type of body
func NewAttachGroupToPackRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitGroupPackRequest calls the generic PermitGroupPack builder with application/json body
func NewPermitGroupPackRequest(server string, groupID GroupID, body PermitGroupPackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitGroupPackRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewPermitGroupPackRequestWithBody generates requests for PermitGroupPack with any type of body
func NewPermitGroupPackRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupFromUserRequest calls the generic DeleteGroupFromUser builder with application/json body
func NewDeleteGroupFromUserRequest(server string, groupID GroupID, body DeleteGroupFromUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteGroupFromUserRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewDeleteGroupFromUserRequestWithBody generates requests for DeleteGroupFromUser with any type of body
func NewDeleteGroupFromUserRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGroupUsersRequest generates requests for ListGroupUsers
func NewListGroupUsersRequest(server string, groupID GroupID, params *ListGroupUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachGroupToUserRequest calls the generic AttachGroupToUser builder with application/json body
func NewAttachGroupToUserRequest(server string, groupID GroupID, body AttachGroupToUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachGroupToUserRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewAttachGroupToUserRequestWithBody generates requests for AttachGroupToUser with any type of body
func NewAttachGroupToUserRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitGroupUserRequest calls the generic PermitGroupUser builder with application/json body
func NewPermitGroupUserRequest(server string, groupID GroupID, body PermitGroupUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitGroupUserRequestWithBody(server, groupID, "application/json", bodyReader)
}

// NewPermitGroupUserRequestWithBody generates requests for PermitGroupUser with any type of body
func NewPermitGroupUserRequestWithBody(server string, groupID GroupID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListMinecraftsRequest generates requests for ListMinecrafts
func NewListMinecraftsRequest(server string, params *ListMinecraftsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/minecraft")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMinecraftRequest generates requests for UpdateMinecraft
func NewUpdateMinecraftRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/minecraft")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteMinecraftFromBuildRequest calls the generic DeleteMinecraftFromBuild builder with application/json body
func NewDeleteMinecraftFromBuildRequest(server string, minecraftID MinecraftID, body DeleteMinecraftFromBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteMinecraftFromBuildRequestWithBody(server, minecraftID, "application/json", bodyReader)
}

// NewDeleteMinecraftFromBuildRequestWithBody generates requests for DeleteMinecraftFromBuild with any type of body
func NewDeleteMinecraftFromBuildRequestWithBody(server string, minecraftID MinecraftID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "minecraft_id", runtime.ParamLocationPath, minecraftID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/minecraft/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListMinecraftBuildsRequest generates requests for ListMinecraftBuilds
func NewListMinecraftBuildsRequest(server string, minecraftID MinecraftID, params *ListMinecraftBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "minecraft_id", runtime.ParamLocationPath, minecraftID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/minecraft/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachMinecraftToBuildRequest calls the generic AttachMinecraftToBuild builder with application/json body
func NewAttachMinecraftToBuildRequest(server string, minecraftID MinecraftID, body AttachMinecraftToBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachMinecraftToBuildRequestWithBody(server, minecraftID, "application/json", bodyReader)
}

// NewAttachMinecraftToBuildRequestWithBody generates requests for AttachMinecraftToBuild with any type of body
func NewAttachMinecraftToBuildRequestWithBody(server string, minecraftID MinecraftID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "minecraft_id", runtime.ParamLocationPath, minecraftID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/minecraft/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListModsRequest generates requests for ListMods
func NewListModsRequest(server string, params *ListModsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateModRequest calls the generic CreateMod builder with application/json body
func NewCreateModRequest(server string, body CreateModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateModRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateModRequestWithBody generates requests for CreateMod with any type of body
func NewCreateModRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteModRequest generates requests for DeleteMod
func NewDeleteModRequest(server string, modID ModID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowModRequest generates requests for ShowMod
func NewShowModRequest(server string, modID ModID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateModRequest calls the generic UpdateMod builder with application/json body
func NewUpdateModRequest(server string, modID ModID, body UpdateModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateModRequestWithBody(server, modID, "application/json", bodyReader)
}

// NewUpdateModRequestWithBody generates requests for UpdateMod with any type of body
func NewUpdateModRequestWithBody(server string, modID ModID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteModAvatarRequest generates requests for DeleteModAvatar
func NewDeleteModAvatarRequest(server string, modID ModID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/avatar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateModAvatarRequestWithBody generates requests for CreateModAvatar with any type of body
func NewCreateModAvatarRequestWithBody(server string, modID ModID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/avatar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteModFromGroupRequest calls the generic DeleteModFromGroup builder with application/json body
func NewDeleteModFromGroupRequest(server string, modID ModID, body DeleteModFromGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteModFromGroupRequestWithBody(server, modID, "application/json", bodyReader)
}

// NewDeleteModFromGroupRequestWithBody generates requests for DeleteModFromGroup with any type of body
func NewDeleteModFromGroupRequestWithBody(server string, modID ModID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListModGroupsRequest generates requests for ListModGroups
func NewListModGroupsRequest(server string, modID ModID, params *ListModGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachModToGroupRequest calls the generic AttachModToGroup builder with application/json body
func NewAttachModToGroupRequest(server string, modID ModID, body AttachModToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachModToGroupRequestWithBody(server, modID, "application/json", bodyReader)
}

// NewAttachModToGroupRequestWithBody generates requests for AttachModToGroup with any type of body
func NewAttachModToGroupRequestWithBody(server string, modID ModID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitModGroupRequest calls the generic PermitModGroup builder with application/json body
func NewPermitModGroupRequest(server string, modID ModID, body PermitModGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitModGroupRequestWithBody(server, modID, "application/json", bodyReader)
}

// NewPermitModGroupRequestWithBody generates requests for PermitModGroup with any type of body
func NewPermitModGroupRequestWithBody(server string, modID ModID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteModFromUserRequest calls the generic DeleteModFromUser builder with application/json body
func NewDeleteModFromUserRequest(server string, modID ModID, body DeleteModFromUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteModFromUserRequestWithBody(server, modID, "application/json", bodyReader)
}

// NewDeleteModFromUserRequestWithBody generates requests for DeleteModFromUser with any type of body
func NewDeleteModFromUserRequestWithBody(server string, modID ModID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListModUsersRequest generates requests for ListModUsers
func NewListModUsersRequest(server string, modID ModID, params *ListModUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachModToUserRequest calls the generic AttachModToUser builder with application/json body
func NewAttachModToUserRequest(server string, modID ModID, body AttachModToUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachModToUserRequestWithBody(server, modID, "application/json", bodyReader)
}

// NewAttachModToUserRequestWithBody generates requests for AttachModToUser with any type of body
func NewAttachModToUserRequestWithBody(server string, modID ModID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitModUserRequest calls the generic PermitModUser builder with application/json body
func NewPermitModUserRequest(server string, modID ModID, body PermitModUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitModUserRequestWithBody(server, modID, "application/json", bodyReader)
}

// NewPermitModUserRequestWithBody generates requests for PermitModUser with any type of body
func NewPermitModUserRequestWithBody(server string, modID ModID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVersionsRequest generates requests for ListVersions
func NewListVersionsRequest(server string, modID ModID, params *ListVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVersionRequest calls the generic CreateVersion builder with application/json body
func NewCreateVersionRequest(server string, modID ModID, body CreateVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVersionRequestWithBody(server, modID, "application/json", bodyReader)
}

// NewCreateVersionRequestWithBody generates requests for CreateVersion with any type of body
func NewCreateVersionRequestWithBody(server string, modID ModID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVersionRequest generates requests for DeleteVersion
func NewDeleteVersionRequest(server string, modID ModID, versionID VersionID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version_id", runtime.ParamLocationPath, versionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowVersionRequest generates requests for ShowVersion
func NewShowVersionRequest(server string, modID ModID, versionID VersionID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version_id", runtime.ParamLocationPath, versionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVersionRequest calls the generic UpdateVersion builder with application/json body
func NewUpdateVersionRequest(server string, modID ModID, versionID VersionID, body UpdateVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVersionRequestWithBody(server, modID, versionID, "application/json", bodyReader)
}

// NewUpdateVersionRequestWithBody generates requests for UpdateVersion with any type of body
func NewUpdateVersionRequestWithBody(server string, modID ModID, versionID VersionID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version_id", runtime.ParamLocationPath, versionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVersionFromBuildRequest calls the generic DeleteVersionFromBuild builder with application/json body
func NewDeleteVersionFromBuildRequest(server string, modID ModID, versionID VersionID, body DeleteVersionFromBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteVersionFromBuildRequestWithBody(server, modID, versionID, "application/json", bodyReader)
}

// NewDeleteVersionFromBuildRequestWithBody generates requests for DeleteVersionFromBuild with any type of body
func NewDeleteVersionFromBuildRequestWithBody(server string, modID ModID, versionID VersionID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version_id", runtime.ParamLocationPath, versionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions/%s/builds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVersionBuildsRequest generates requests for ListVersionBuilds
func NewListVersionBuildsRequest(server string, modID ModID, versionID VersionID, params *ListVersionBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version_id", runtime.ParamLocationPath, versionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions/%s/builds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachVersionToBuildRequest calls the generic AttachVersionToBuild builder with application/json body
func NewAttachVersionToBuildRequest(server string, modID ModID, versionID VersionID, body AttachVersionToBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachVersionToBuildRequestWithBody(server, modID, versionID, "application/json", bodyReader)
}

// NewAttachVersionToBuildRequestWithBody generates requests for AttachVersionToBuild with any type of body
func NewAttachVersionToBuildRequestWithBody(server string, modID ModID, versionID VersionID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version_id", runtime.ParamLocationPath, versionID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions/%s/builds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListNeoforgesRequest generates requests for ListNeoforges
func NewListNeoforgesRequest(server string, params *ListNeoforgesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/neoforge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNeoforgeRequest generates requests for UpdateNeoforge
func NewUpdateNeoforgeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/neoforge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNeoforgeFromBuildRequest calls the generic DeleteNeoforgeFromBuild builder with application/json body
func NewDeleteNeoforgeFromBuildRequest(server string, neoforgeID NeoforgeID, body DeleteNeoforgeFromBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteNeoforgeFromBuildRequestWithBody(server, neoforgeID, "application/json", bodyReader)
}

// NewDeleteNeoforgeFromBuildRequestWithBody generates requests for DeleteNeoforgeFromBuild with any type of body
func NewDeleteNeoforgeFromBuildRequestWithBody(server string, neoforgeID NeoforgeID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "neoforge_id", runtime.ParamLocationPath, neoforgeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/neoforge/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListNeoforgeBuildsRequest generates requests for ListNeoforgeBuilds
func NewListNeoforgeBuildsRequest(server string, neoforgeID NeoforgeID, params *ListNeoforgeBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "neoforge_id", runtime.ParamLocationPath, neoforgeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/neoforge/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachNeoforgeToBuildRequest calls the generic AttachNeoforgeToBuild builder with application/json body
func NewAttachNeoforgeToBuildRequest(server string, neoforgeID NeoforgeID, body AttachNeoforgeToBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachNeoforgeToBuildRequestWithBody(server, neoforgeID, "application/json", bodyReader)
}

// NewAttachNeoforgeToBuildRequestWithBody generates requests for AttachNeoforgeToBuild with any type of body
func NewAttachNeoforgeToBuildRequestWithBody(server string, neoforgeID NeoforgeID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "neoforge_id", runtime.ParamLocationPath, neoforgeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/neoforge/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPacksRequest generates requests for ListPacks
func NewListPacksRequest(server string, params *ListPacksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePackRequest calls the generic CreatePack builder with application/json body
func NewCreatePackRequest(server string, body CreatePackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePackRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePackRequestWithBody generates requests for CreatePack with any type of body
func NewCreatePackRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePackRequest generates requests for DeletePack
func NewDeletePackRequest(server string, packID PackID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowPackRequest generates requests for ShowPack
func NewShowPackRequest(server string, packID PackID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePackRequest calls the generic UpdatePack builder with application/json body
func NewUpdatePackRequest(server string, packID PackID, body UpdatePackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePackRequestWithBody(server, packID, "application/json", bodyReader)
}

// NewUpdatePackRequestWithBody generates requests for UpdatePack with any type of body
func NewUpdatePackRequestWithBody(server string, packID PackID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePackAvatarRequest generates requests for DeletePackAvatar
func NewDeletePackAvatarRequest(server string, packID PackID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/avatar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePackAvatarRequestWithBody generates requests for CreatePackAvatar with any type of body
func NewCreatePackAvatarRequestWithBody(server string, packID PackID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/avatar", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBuildsRequest generates requests for ListBuilds
func NewListBuildsRequest(server string, packID PackID, params *ListBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBuildRequest calls the generic CreateBuild builder with application/json body
func NewCreateBuildRequest(server string, packID PackID, body CreateBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBuildRequestWithBody(server, packID, "application/json", bodyReader)
}

// NewCreateBuildRequestWithBody generates requests for CreateBuild with any type of body
func NewCreateBuildRequestWithBody(server string, packID PackID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBuildRequest generates requests for DeleteBuild
func NewDeleteBuildRequest(server string, packID PackID, buildID BuildID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowBuildRequest generates requests for ShowBuild
func NewShowBuildRequest(server string, packID PackID, buildID BuildID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBuildRequest calls the generic UpdateBuild builder with application/json body
func NewUpdateBuildRequest(server string, packID PackID, buildID BuildID, body UpdateBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBuildRequestWithBody(server, packID, buildID, "application/json", bodyReader)
}

// NewUpdateBuildRequestWithBody generates requests for UpdateBuild with any type of body
func NewUpdateBuildRequestWithBody(server string, packID PackID, buildID BuildID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBuildFromVersionRequest calls the generic DeleteBuildFromVersion builder with application/json body
func NewDeleteBuildFromVersionRequest(server string, packID PackID, buildID BuildID, body DeleteBuildFromVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteBuildFromVersionRequestWithBody(server, packID, buildID, "application/json", bodyReader)
}

// NewDeleteBuildFromVersionRequestWithBody generates requests for DeleteBuildFromVersion with any type of body
func NewDeleteBuildFromVersionRequestWithBody(server string, packID PackID, buildID BuildID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds/%s/versions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBuildVersionsRequest generates requests for ListBuildVersions
func NewListBuildVersionsRequest(server string, packID PackID, buildID BuildID, params *ListBuildVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds/%s/versions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachBuildToVersionRequest calls the generic AttachBuildToVersion builder with application/json body
func NewAttachBuildToVersionRequest(server string, packID PackID, buildID BuildID, body AttachBuildToVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachBuildToVersionRequestWithBody(server, packID, buildID, "application/json", bodyReader)
}

// NewAttachBuildToVersionRequestWithBody generates requests for AttachBuildToVersion with any type of body
func NewAttachBuildToVersionRequestWithBody(server string, packID PackID, buildID BuildID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds/%s/versions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePackFromGroupRequest calls the generic DeletePackFromGroup builder with application/json body
func NewDeletePackFromGroupRequest(server string, packID PackID, body DeletePackFromGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePackFromGroupRequestWithBody(server, packID, "application/json", bodyReader)
}

// NewDeletePackFromGroupRequestWithBody generates requests for DeletePackFromGroup with any type of body
func NewDeletePackFromGroupRequestWithBody(server string, packID PackID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPackGroupsRequest generates requests for ListPackGroups
func NewListPackGroupsRequest(server string, packID PackID, params *ListPackGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachPackToGroupRequest calls the generic AttachPackToGroup builder with application/json body
func NewAttachPackToGroupRequest(server string, packID PackID, body AttachPackToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachPackToGroupRequestWithBody(server, packID, "application/json", bodyReader)
}

// NewAttachPackToGroupRequestWithBody generates requests for AttachPackToGroup with any type of body
func NewAttachPackToGroupRequestWithBody(server string, packID PackID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitPackGroupRequest calls the generic PermitPackGroup builder with application/json body
func NewPermitPackGroupRequest(server string, packID PackID, body PermitPackGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitPackGroupRequestWithBody(server, packID, "application/json", bodyReader)
}

// NewPermitPackGroupRequestWithBody generates requests for PermitPackGroup with any type of body
func NewPermitPackGroupRequestWithBody(server string, packID PackID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePackFromUserRequest calls the generic DeletePackFromUser builder with application/json body
func NewDeletePackFromUserRequest(server string, packID PackID, body DeletePackFromUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePackFromUserRequestWithBody(server, packID, "application/json", bodyReader)
}

// NewDeletePackFromUserRequestWithBody generates requests for DeletePackFromUser with any type of body
func NewDeletePackFromUserRequestWithBody(server string, packID PackID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPackUsersRequest generates requests for ListPackUsers
func NewListPackUsersRequest(server string, packID PackID, params *ListPackUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachPackToUserRequest calls the generic AttachPackToUser builder with application/json body
func NewAttachPackToUserRequest(server string, packID PackID, body AttachPackToUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachPackToUserRequestWithBody(server, packID, "application/json", bodyReader)
}

// NewAttachPackToUserRequestWithBody generates requests for AttachPackToUser with any type of body
func NewAttachPackToUserRequestWithBody(server string, packID PackID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitPackUserRequest calls the generic PermitPackUser builder with application/json body
func NewPermitPackUserRequest(server string, packID PackID, body PermitPackUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitPackUserRequestWithBody(server, packID, "application/json", bodyReader)
}

// NewPermitPackUserRequestWithBody generates requests for PermitPackUser with any type of body
func NewPermitPackUserRequestWithBody(server string, packID PackID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShowProfileRequest generates requests for ShowProfile
func NewShowProfileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile/self")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProfileRequest calls the generic UpdateProfile builder with application/json body
func NewUpdateProfileRequest(server string, body UpdateProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProfileRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateProfileRequestWithBody generates requests for UpdateProfile with any type of body
func NewUpdateProfileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile/self")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTokenProfileRequest generates requests for TokenProfile
func NewTokenProfileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListQuiltsRequest generates requests for ListQuilts
func NewListQuiltsRequest(server string, params *ListQuiltsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/quilt")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateQuiltRequest generates requests for UpdateQuilt
func NewUpdateQuiltRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/quilt")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteQuiltFromBuildRequest calls the generic DeleteQuiltFromBuild builder with application/json body
func NewDeleteQuiltFromBuildRequest(server string, quiltID QuiltID, body DeleteQuiltFromBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteQuiltFromBuildRequestWithBody(server, quiltID, "application/json", bodyReader)
}

// NewDeleteQuiltFromBuildRequestWithBody generates requests for DeleteQuiltFromBuild with any type of body
func NewDeleteQuiltFromBuildRequestWithBody(server string, quiltID QuiltID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "quilt_id", runtime.ParamLocationPath, quiltID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/quilt/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListQuiltBuildsRequest generates requests for ListQuiltBuilds
func NewListQuiltBuildsRequest(server string, quiltID QuiltID, params *ListQuiltBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "quilt_id", runtime.ParamLocationPath, quiltID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/quilt/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachQuiltToBuildRequest calls the generic AttachQuiltToBuild builder with application/json body
func NewAttachQuiltToBuildRequest(server string, quiltID QuiltID, body AttachQuiltToBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachQuiltToBuildRequestWithBody(server, quiltID, "application/json", bodyReader)
}

// NewAttachQuiltToBuildRequestWithBody generates requests for AttachQuiltToBuild with any type of body
func NewAttachQuiltToBuildRequestWithBody(server string, quiltID QuiltID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "quilt_id", runtime.ParamLocationPath, quiltID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/quilt/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userID UserID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowUserRequest generates requests for ShowUser
func NewShowUserRequest(server string, userID UserID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, userID UserID, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserFromGroupRequest calls the generic DeleteUserFromGroup builder with application/json body
func NewDeleteUserFromGroupRequest(server string, userID UserID, body DeleteUserFromGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteUserFromGroupRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewDeleteUserFromGroupRequestWithBody generates requests for DeleteUserFromGroup with any type of body
func NewDeleteUserFromGroupRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserGroupsRequest generates requests for ListUserGroups
func NewListUserGroupsRequest(server string, userID UserID, params *ListUserGroupsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachUserToGroupRequest calls the generic AttachUserToGroup builder with application/json body
func NewAttachUserToGroupRequest(server string, userID UserID, body AttachUserToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachUserToGroupRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewAttachUserToGroupRequestWithBody generates requests for AttachUserToGroup with any type of body
func NewAttachUserToGroupRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitUserGroupRequest calls the generic PermitUserGroup builder with application/json body
func NewPermitUserGroupRequest(server string, userID UserID, body PermitUserGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitUserGroupRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewPermitUserGroupRequestWithBody generates requests for PermitUserGroup with any type of body
func NewPermitUserGroupRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserFromModRequest calls the generic DeleteUserFromMod builder with application/json body
func NewDeleteUserFromModRequest(server string, userID UserID, body DeleteUserFromModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteUserFromModRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewDeleteUserFromModRequestWithBody generates requests for DeleteUserFromMod with any type of body
func NewDeleteUserFromModRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserModsRequest generates requests for ListUserMods
func NewListUserModsRequest(server string, userID UserID, params *ListUserModsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachUserToModRequest calls the generic AttachUserToMod builder with application/json body
func NewAttachUserToModRequest(server string, userID UserID, body AttachUserToModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachUserToModRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewAttachUserToModRequestWithBody generates requests for AttachUserToMod with any type of body
func NewAttachUserToModRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitUserModRequest calls the generic PermitUserMod builder with application/json body
func NewPermitUserModRequest(server string, userID UserID, body PermitUserModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitUserModRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewPermitUserModRequestWithBody generates requests for PermitUserMod with any type of body
func NewPermitUserModRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserFromPackRequest calls the generic DeleteUserFromPack builder with application/json body
func NewDeleteUserFromPackRequest(server string, userID UserID, body DeleteUserFromPackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteUserFromPackRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewDeleteUserFromPackRequestWithBody generates requests for DeleteUserFromPack with any type of body
func NewDeleteUserFromPackRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserPacksRequest generates requests for ListUserPacks
func NewListUserPacksRequest(server string, userID UserID, params *ListUserPacksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachUserToPackRequest calls the generic AttachUserToPack builder with application/json body
func NewAttachUserToPackRequest(server string, userID UserID, body AttachUserToPackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachUserToPackRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewAttachUserToPackRequestWithBody generates requests for AttachUserToPack with any type of body
func NewAttachUserToPackRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitUserPackRequest calls the generic PermitUserPack builder with application/json body
func NewPermitUserPackRequest(server string, userID UserID, body PermitUserPackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitUserPackRequestWithBody(server, userID, "application/json", bodyReader)
}

// NewPermitUserPackRequestWithBody generates requests for PermitUserPack with any type of body
func NewPermitUserPackRequestWithBody(server string, userID UserID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// LoginAuthWithBodyWithResponse request with any body
	LoginAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginAuthResponse, error)

	LoginAuthWithResponse(ctx context.Context, body LoginAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginAuthResponse, error)

	// ListProvidersWithResponse request
	ListProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListProvidersResponse, error)

	// RedirectAuthWithBodyWithResponse request with any body
	RedirectAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RedirectAuthResponse, error)

	RedirectAuthWithResponse(ctx context.Context, body RedirectAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*RedirectAuthResponse, error)

	// RefreshAuthWithResponse request
	RefreshAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RefreshAuthResponse, error)

	// VerifyAuthWithResponse request
	VerifyAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VerifyAuthResponse, error)

	// CallbackProviderWithResponse request
	CallbackProviderWithResponse(ctx context.Context, provider AuthProviderParam, params *CallbackProviderParams, reqEditors ...RequestEditorFn) (*CallbackProviderResponse, error)

	// RequestProviderWithResponse request
	RequestProviderWithResponse(ctx context.Context, provider AuthProviderParam, reqEditors ...RequestEditorFn) (*RequestProviderResponse, error)

	// ListFabricsWithResponse request
	ListFabricsWithResponse(ctx context.Context, params *ListFabricsParams, reqEditors ...RequestEditorFn) (*ListFabricsResponse, error)

	// UpdateFabricWithResponse request
	UpdateFabricWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateFabricResponse, error)

	// DeleteFabricFromBuildWithBodyWithResponse request with any body
	DeleteFabricFromBuildWithBodyWithResponse(ctx context.Context, fabricID FabricID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteFabricFromBuildResponse, error)

	DeleteFabricFromBuildWithResponse(ctx context.Context, fabricID FabricID, body DeleteFabricFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteFabricFromBuildResponse, error)

	// ListFabricBuildsWithResponse request
	ListFabricBuildsWithResponse(ctx context.Context, fabricID FabricID, params *ListFabricBuildsParams, reqEditors ...RequestEditorFn) (*ListFabricBuildsResponse, error)

	// AttachFabricToBuildWithBodyWithResponse request with any body
	AttachFabricToBuildWithBodyWithResponse(ctx context.Context, fabricID FabricID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachFabricToBuildResponse, error)

	AttachFabricToBuildWithResponse(ctx context.Context, fabricID FabricID, body AttachFabricToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachFabricToBuildResponse, error)

	// ListForgesWithResponse request
	ListForgesWithResponse(ctx context.Context, params *ListForgesParams, reqEditors ...RequestEditorFn) (*ListForgesResponse, error)

	// UpdateForgeWithResponse request
	UpdateForgeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateForgeResponse, error)

	// DeleteForgeFromBuildWithBodyWithResponse request with any body
	DeleteForgeFromBuildWithBodyWithResponse(ctx context.Context, forgeID ForgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteForgeFromBuildResponse, error)

	DeleteForgeFromBuildWithResponse(ctx context.Context, forgeID ForgeID, body DeleteForgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteForgeFromBuildResponse, error)

	// ListForgeBuildsWithResponse request
	ListForgeBuildsWithResponse(ctx context.Context, forgeID ForgeID, params *ListForgeBuildsParams, reqEditors ...RequestEditorFn) (*ListForgeBuildsResponse, error)

	// AttachForgeToBuildWithBodyWithResponse request with any body
	AttachForgeToBuildWithBodyWithResponse(ctx context.Context, forgeID ForgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachForgeToBuildResponse, error)

	AttachForgeToBuildWithResponse(ctx context.Context, forgeID ForgeID, body AttachForgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachForgeToBuildResponse, error)

	// ListGroupsWithResponse request
	ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error)

	// CreateGroupWithBodyWithResponse request with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// DeleteGroupWithResponse request
	DeleteGroupWithResponse(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// ShowGroupWithResponse request
	ShowGroupWithResponse(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*ShowGroupResponse, error)

	// UpdateGroupWithBodyWithResponse request with any body
	UpdateGroupWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	UpdateGroupWithResponse(ctx context.Context, groupID GroupID, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error)

	// DeleteGroupFromModWithBodyWithResponse request with any body
	DeleteGroupFromModWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGroupFromModResponse, error)

	DeleteGroupFromModWithResponse(ctx context.Context, groupID GroupID, body DeleteGroupFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGroupFromModResponse, error)

	// ListGroupModsWithResponse request
	ListGroupModsWithResponse(ctx context.Context, groupID GroupID, params *ListGroupModsParams, reqEditors ...RequestEditorFn) (*ListGroupModsResponse, error)

	// AttachGroupToModWithBodyWithResponse request with any body
	AttachGroupToModWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachGroupToModResponse, error)

	AttachGroupToModWithResponse(ctx context.Context, groupID GroupID, body AttachGroupToModJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachGroupToModResponse, error)

	// PermitGroupModWithBodyWithResponse request with any body
	PermitGroupModWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitGroupModResponse, error)

	PermitGroupModWithResponse(ctx context.Context, groupID GroupID, body PermitGroupModJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitGroupModResponse, error)

	// DeleteGroupFromPackWithBodyWithResponse request with any body
	DeleteGroupFromPackWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGroupFromPackResponse, error)

	DeleteGroupFromPackWithResponse(ctx context.Context, groupID GroupID, body DeleteGroupFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGroupFromPackResponse, error)

	// ListGroupPacksWithResponse request
	ListGroupPacksWithResponse(ctx context.Context, groupID GroupID, params *ListGroupPacksParams, reqEditors ...RequestEditorFn) (*ListGroupPacksResponse, error)

	// AttachGroupToPackWithBodyWithResponse request with any body
	AttachGroupToPackWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachGroupToPackResponse, error)

	AttachGroupToPackWithResponse(ctx context.Context, groupID GroupID, body AttachGroupToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachGroupToPackResponse, error)

	// PermitGroupPackWithBodyWithResponse request with any body
	PermitGroupPackWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitGroupPackResponse, error)

	PermitGroupPackWithResponse(ctx context.Context, groupID GroupID, body PermitGroupPackJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitGroupPackResponse, error)

	// DeleteGroupFromUserWithBodyWithResponse request with any body
	DeleteGroupFromUserWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGroupFromUserResponse, error)

	DeleteGroupFromUserWithResponse(ctx context.Context, groupID GroupID, body DeleteGroupFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGroupFromUserResponse, error)

	// ListGroupUsersWithResponse request
	ListGroupUsersWithResponse(ctx context.Context, groupID GroupID, params *ListGroupUsersParams, reqEditors ...RequestEditorFn) (*ListGroupUsersResponse, error)

	// AttachGroupToUserWithBodyWithResponse request with any body
	AttachGroupToUserWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachGroupToUserResponse, error)

	AttachGroupToUserWithResponse(ctx context.Context, groupID GroupID, body AttachGroupToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachGroupToUserResponse, error)

	// PermitGroupUserWithBodyWithResponse request with any body
	PermitGroupUserWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitGroupUserResponse, error)

	PermitGroupUserWithResponse(ctx context.Context, groupID GroupID, body PermitGroupUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitGroupUserResponse, error)

	// ListMinecraftsWithResponse request
	ListMinecraftsWithResponse(ctx context.Context, params *ListMinecraftsParams, reqEditors ...RequestEditorFn) (*ListMinecraftsResponse, error)

	// UpdateMinecraftWithResponse request
	UpdateMinecraftWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateMinecraftResponse, error)

	// DeleteMinecraftFromBuildWithBodyWithResponse request with any body
	DeleteMinecraftFromBuildWithBodyWithResponse(ctx context.Context, minecraftID MinecraftID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteMinecraftFromBuildResponse, error)

	DeleteMinecraftFromBuildWithResponse(ctx context.Context, minecraftID MinecraftID, body DeleteMinecraftFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteMinecraftFromBuildResponse, error)

	// ListMinecraftBuildsWithResponse request
	ListMinecraftBuildsWithResponse(ctx context.Context, minecraftID MinecraftID, params *ListMinecraftBuildsParams, reqEditors ...RequestEditorFn) (*ListMinecraftBuildsResponse, error)

	// AttachMinecraftToBuildWithBodyWithResponse request with any body
	AttachMinecraftToBuildWithBodyWithResponse(ctx context.Context, minecraftID MinecraftID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachMinecraftToBuildResponse, error)

	AttachMinecraftToBuildWithResponse(ctx context.Context, minecraftID MinecraftID, body AttachMinecraftToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachMinecraftToBuildResponse, error)

	// ListModsWithResponse request
	ListModsWithResponse(ctx context.Context, params *ListModsParams, reqEditors ...RequestEditorFn) (*ListModsResponse, error)

	// CreateModWithBodyWithResponse request with any body
	CreateModWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModResponse, error)

	CreateModWithResponse(ctx context.Context, body CreateModJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModResponse, error)

	// DeleteModWithResponse request
	DeleteModWithResponse(ctx context.Context, modID ModID, reqEditors ...RequestEditorFn) (*DeleteModResponse, error)

	// ShowModWithResponse request
	ShowModWithResponse(ctx context.Context, modID ModID, reqEditors ...RequestEditorFn) (*ShowModResponse, error)

	// UpdateModWithBodyWithResponse request with any body
	UpdateModWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateModResponse, error)

	UpdateModWithResponse(ctx context.Context, modID ModID, body UpdateModJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateModResponse, error)

	// DeleteModAvatarWithResponse request
	DeleteModAvatarWithResponse(ctx context.Context, modID ModID, reqEditors ...RequestEditorFn) (*DeleteModAvatarResponse, error)

	// CreateModAvatarWithBodyWithResponse request with any body
	CreateModAvatarWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModAvatarResponse, error)

	// DeleteModFromGroupWithBodyWithResponse request with any body
	DeleteModFromGroupWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteModFromGroupResponse, error)

	DeleteModFromGroupWithResponse(ctx context.Context, modID ModID, body DeleteModFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteModFromGroupResponse, error)

	// ListModGroupsWithResponse request
	ListModGroupsWithResponse(ctx context.Context, modID ModID, params *ListModGroupsParams, reqEditors ...RequestEditorFn) (*ListModGroupsResponse, error)

	// AttachModToGroupWithBodyWithResponse request with any body
	AttachModToGroupWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachModToGroupResponse, error)

	AttachModToGroupWithResponse(ctx context.Context, modID ModID, body AttachModToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachModToGroupResponse, error)

	// PermitModGroupWithBodyWithResponse request with any body
	PermitModGroupWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitModGroupResponse, error)

	PermitModGroupWithResponse(ctx context.Context, modID ModID, body PermitModGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitModGroupResponse, error)

	// DeleteModFromUserWithBodyWithResponse request with any body
	DeleteModFromUserWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteModFromUserResponse, error)

	DeleteModFromUserWithResponse(ctx context.Context, modID ModID, body DeleteModFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteModFromUserResponse, error)

	// ListModUsersWithResponse request
	ListModUsersWithResponse(ctx context.Context, modID ModID, params *ListModUsersParams, reqEditors ...RequestEditorFn) (*ListModUsersResponse, error)

	// AttachModToUserWithBodyWithResponse request with any body
	AttachModToUserWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachModToUserResponse, error)

	AttachModToUserWithResponse(ctx context.Context, modID ModID, body AttachModToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachModToUserResponse, error)

	// PermitModUserWithBodyWithResponse request with any body
	PermitModUserWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitModUserResponse, error)

	PermitModUserWithResponse(ctx context.Context, modID ModID, body PermitModUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitModUserResponse, error)

	// ListVersionsWithResponse request
	ListVersionsWithResponse(ctx context.Context, modID ModID, params *ListVersionsParams, reqEditors ...RequestEditorFn) (*ListVersionsResponse, error)

	// CreateVersionWithBodyWithResponse request with any body
	CreateVersionWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVersionResponse, error)

	CreateVersionWithResponse(ctx context.Context, modID ModID, body CreateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVersionResponse, error)

	// DeleteVersionWithResponse request
	DeleteVersionWithResponse(ctx context.Context, modID ModID, versionID VersionID, reqEditors ...RequestEditorFn) (*DeleteVersionResponse, error)

	// ShowVersionWithResponse request
	ShowVersionWithResponse(ctx context.Context, modID ModID, versionID VersionID, reqEditors ...RequestEditorFn) (*ShowVersionResponse, error)

	// UpdateVersionWithBodyWithResponse request with any body
	UpdateVersionWithBodyWithResponse(ctx context.Context, modID ModID, versionID VersionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVersionResponse, error)

	UpdateVersionWithResponse(ctx context.Context, modID ModID, versionID VersionID, body UpdateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVersionResponse, error)

	// DeleteVersionFromBuildWithBodyWithResponse request with any body
	DeleteVersionFromBuildWithBodyWithResponse(ctx context.Context, modID ModID, versionID VersionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVersionFromBuildResponse, error)

	DeleteVersionFromBuildWithResponse(ctx context.Context, modID ModID, versionID VersionID, body DeleteVersionFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVersionFromBuildResponse, error)

	// ListVersionBuildsWithResponse request
	ListVersionBuildsWithResponse(ctx context.Context, modID ModID, versionID VersionID, params *ListVersionBuildsParams, reqEditors ...RequestEditorFn) (*ListVersionBuildsResponse, error)

	// AttachVersionToBuildWithBodyWithResponse request with any body
	AttachVersionToBuildWithBodyWithResponse(ctx context.Context, modID ModID, versionID VersionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachVersionToBuildResponse, error)

	AttachVersionToBuildWithResponse(ctx context.Context, modID ModID, versionID VersionID, body AttachVersionToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachVersionToBuildResponse, error)

	// ListNeoforgesWithResponse request
	ListNeoforgesWithResponse(ctx context.Context, params *ListNeoforgesParams, reqEditors ...RequestEditorFn) (*ListNeoforgesResponse, error)

	// UpdateNeoforgeWithResponse request
	UpdateNeoforgeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateNeoforgeResponse, error)

	// DeleteNeoforgeFromBuildWithBodyWithResponse request with any body
	DeleteNeoforgeFromBuildWithBodyWithResponse(ctx context.Context, neoforgeID NeoforgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteNeoforgeFromBuildResponse, error)

	DeleteNeoforgeFromBuildWithResponse(ctx context.Context, neoforgeID NeoforgeID, body DeleteNeoforgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteNeoforgeFromBuildResponse, error)

	// ListNeoforgeBuildsWithResponse request
	ListNeoforgeBuildsWithResponse(ctx context.Context, neoforgeID NeoforgeID, params *ListNeoforgeBuildsParams, reqEditors ...RequestEditorFn) (*ListNeoforgeBuildsResponse, error)

	// AttachNeoforgeToBuildWithBodyWithResponse request with any body
	AttachNeoforgeToBuildWithBodyWithResponse(ctx context.Context, neoforgeID NeoforgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachNeoforgeToBuildResponse, error)

	AttachNeoforgeToBuildWithResponse(ctx context.Context, neoforgeID NeoforgeID, body AttachNeoforgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachNeoforgeToBuildResponse, error)

	// ListPacksWithResponse request
	ListPacksWithResponse(ctx context.Context, params *ListPacksParams, reqEditors ...RequestEditorFn) (*ListPacksResponse, error)

	// CreatePackWithBodyWithResponse request with any body
	CreatePackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePackResponse, error)

	CreatePackWithResponse(ctx context.Context, body CreatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePackResponse, error)

	// DeletePackWithResponse request
	DeletePackWithResponse(ctx context.Context, packID PackID, reqEditors ...RequestEditorFn) (*DeletePackResponse, error)

	// ShowPackWithResponse request
	ShowPackWithResponse(ctx context.Context, packID PackID, reqEditors ...RequestEditorFn) (*ShowPackResponse, error)

	// UpdatePackWithBodyWithResponse request with any body
	UpdatePackWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePackResponse, error)

	UpdatePackWithResponse(ctx context.Context, packID PackID, body UpdatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePackResponse, error)

	// DeletePackAvatarWithResponse request
	DeletePackAvatarWithResponse(ctx context.Context, packID PackID, reqEditors ...RequestEditorFn) (*DeletePackAvatarResponse, error)

	// CreatePackAvatarWithBodyWithResponse request with any body
	CreatePackAvatarWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePackAvatarResponse, error)

	// ListBuildsWithResponse request
	ListBuildsWithResponse(ctx context.Context, packID PackID, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*ListBuildsResponse, error)

	// CreateBuildWithBodyWithResponse request with any body
	CreateBuildWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBuildResponse, error)

	CreateBuildWithResponse(ctx context.Context, packID PackID, body CreateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBuildResponse, error)

	// DeleteBuildWithResponse request
	DeleteBuildWithResponse(ctx context.Context, packID PackID, buildID BuildID, reqEditors ...RequestEditorFn) (*DeleteBuildResponse, error)

	// ShowBuildWithResponse request
	ShowBuildWithResponse(ctx context.Context, packID PackID, buildID BuildID, reqEditors ...RequestEditorFn) (*ShowBuildResponse, error)

	// UpdateBuildWithBodyWithResponse request with any body
	UpdateBuildWithBodyWithResponse(ctx context.Context, packID PackID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBuildResponse, error)

	UpdateBuildWithResponse(ctx context.Context, packID PackID, buildID BuildID, body UpdateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBuildResponse, error)

	// DeleteBuildFromVersionWithBodyWithResponse request with any body
	DeleteBuildFromVersionWithBodyWithResponse(ctx context.Context, packID PackID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteBuildFromVersionResponse, error)

	DeleteBuildFromVersionWithResponse(ctx context.Context, packID PackID, buildID BuildID, body DeleteBuildFromVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteBuildFromVersionResponse, error)

	// ListBuildVersionsWithResponse request
	ListBuildVersionsWithResponse(ctx context.Context, packID PackID, buildID BuildID, params *ListBuildVersionsParams, reqEditors ...RequestEditorFn) (*ListBuildVersionsResponse, error)

	// AttachBuildToVersionWithBodyWithResponse request with any body
	AttachBuildToVersionWithBodyWithResponse(ctx context.Context, packID PackID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachBuildToVersionResponse, error)

	AttachBuildToVersionWithResponse(ctx context.Context, packID PackID, buildID BuildID, body AttachBuildToVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachBuildToVersionResponse, error)

	// DeletePackFromGroupWithBodyWithResponse request with any body
	DeletePackFromGroupWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePackFromGroupResponse, error)

	DeletePackFromGroupWithResponse(ctx context.Context, packID PackID, body DeletePackFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePackFromGroupResponse, error)

	// ListPackGroupsWithResponse request
	ListPackGroupsWithResponse(ctx context.Context, packID PackID, params *ListPackGroupsParams, reqEditors ...RequestEditorFn) (*ListPackGroupsResponse, error)

	// AttachPackToGroupWithBodyWithResponse request with any body
	AttachPackToGroupWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachPackToGroupResponse, error)

	AttachPackToGroupWithResponse(ctx context.Context, packID PackID, body AttachPackToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachPackToGroupResponse, error)

	// PermitPackGroupWithBodyWithResponse request with any body
	PermitPackGroupWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitPackGroupResponse, error)

	PermitPackGroupWithResponse(ctx context.Context, packID PackID, body PermitPackGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitPackGroupResponse, error)

	// DeletePackFromUserWithBodyWithResponse request with any body
	DeletePackFromUserWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePackFromUserResponse, error)

	DeletePackFromUserWithResponse(ctx context.Context, packID PackID, body DeletePackFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePackFromUserResponse, error)

	// ListPackUsersWithResponse request
	ListPackUsersWithResponse(ctx context.Context, packID PackID, params *ListPackUsersParams, reqEditors ...RequestEditorFn) (*ListPackUsersResponse, error)

	// AttachPackToUserWithBodyWithResponse request with any body
	AttachPackToUserWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachPackToUserResponse, error)

	AttachPackToUserWithResponse(ctx context.Context, packID PackID, body AttachPackToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachPackToUserResponse, error)

	// PermitPackUserWithBodyWithResponse request with any body
	PermitPackUserWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitPackUserResponse, error)

	PermitPackUserWithResponse(ctx context.Context, packID PackID, body PermitPackUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitPackUserResponse, error)

	// ShowProfileWithResponse request
	ShowProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ShowProfileResponse, error)

	// UpdateProfileWithBodyWithResponse request with any body
	UpdateProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error)

	UpdateProfileWithResponse(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error)

	// TokenProfileWithResponse request
	TokenProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TokenProfileResponse, error)

	// ListQuiltsWithResponse request
	ListQuiltsWithResponse(ctx context.Context, params *ListQuiltsParams, reqEditors ...RequestEditorFn) (*ListQuiltsResponse, error)

	// UpdateQuiltWithResponse request
	UpdateQuiltWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateQuiltResponse, error)

	// DeleteQuiltFromBuildWithBodyWithResponse request with any body
	DeleteQuiltFromBuildWithBodyWithResponse(ctx context.Context, quiltID QuiltID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteQuiltFromBuildResponse, error)

	DeleteQuiltFromBuildWithResponse(ctx context.Context, quiltID QuiltID, body DeleteQuiltFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteQuiltFromBuildResponse, error)

	// ListQuiltBuildsWithResponse request
	ListQuiltBuildsWithResponse(ctx context.Context, quiltID QuiltID, params *ListQuiltBuildsParams, reqEditors ...RequestEditorFn) (*ListQuiltBuildsResponse, error)

	// AttachQuiltToBuildWithBodyWithResponse request with any body
	AttachQuiltToBuildWithBodyWithResponse(ctx context.Context, quiltID QuiltID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachQuiltToBuildResponse, error)

	AttachQuiltToBuildWithResponse(ctx context.Context, quiltID QuiltID, body AttachQuiltToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachQuiltToBuildResponse, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// ShowUserWithResponse request
	ShowUserWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*ShowUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, userID UserID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// DeleteUserFromGroupWithBodyWithResponse request with any body
	DeleteUserFromGroupWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromGroupResponse, error)

	DeleteUserFromGroupWithResponse(ctx context.Context, userID UserID, body DeleteUserFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromGroupResponse, error)

	// ListUserGroupsWithResponse request
	ListUserGroupsWithResponse(ctx context.Context, userID UserID, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*ListUserGroupsResponse, error)

	// AttachUserToGroupWithBodyWithResponse request with any body
	AttachUserToGroupWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToGroupResponse, error)

	AttachUserToGroupWithResponse(ctx context.Context, userID UserID, body AttachUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToGroupResponse, error)

	// PermitUserGroupWithBodyWithResponse request with any body
	PermitUserGroupWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserGroupResponse, error)

	PermitUserGroupWithResponse(ctx context.Context, userID UserID, body PermitUserGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserGroupResponse, error)

	// DeleteUserFromModWithBodyWithResponse request with any body
	DeleteUserFromModWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromModResponse, error)

	DeleteUserFromModWithResponse(ctx context.Context, userID UserID, body DeleteUserFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromModResponse, error)

	// ListUserModsWithResponse request
	ListUserModsWithResponse(ctx context.Context, userID UserID, params *ListUserModsParams, reqEditors ...RequestEditorFn) (*ListUserModsResponse, error)

	// AttachUserToModWithBodyWithResponse request with any body
	AttachUserToModWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToModResponse, error)

	AttachUserToModWithResponse(ctx context.Context, userID UserID, body AttachUserToModJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToModResponse, error)

	// PermitUserModWithBodyWithResponse request with any body
	PermitUserModWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserModResponse, error)

	PermitUserModWithResponse(ctx context.Context, userID UserID, body PermitUserModJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserModResponse, error)

	// DeleteUserFromPackWithBodyWithResponse request with any body
	DeleteUserFromPackWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromPackResponse, error)

	DeleteUserFromPackWithResponse(ctx context.Context, userID UserID, body DeleteUserFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromPackResponse, error)

	// ListUserPacksWithResponse request
	ListUserPacksWithResponse(ctx context.Context, userID UserID, params *ListUserPacksParams, reqEditors ...RequestEditorFn) (*ListUserPacksResponse, error)

	// AttachUserToPackWithBodyWithResponse request with any body
	AttachUserToPackWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToPackResponse, error)

	AttachUserToPackWithResponse(ctx context.Context, userID UserID, body AttachUserToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToPackResponse, error)

	// PermitUserPackWithBodyWithResponse request with any body
	PermitUserPackWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserPackResponse, error)

	PermitUserPackWithResponse(ctx context.Context, userID UserID, body PermitUserPackJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserPackResponse, error)
}

type LoginAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginResponse
	JSON400      *BadRequestError
	JSON401      *BadCredentialsError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r LoginAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProvidersResponse
}

// Status returns HTTPResponse.Status
func (r ListProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RedirectAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
	JSON400      *BadRequestError
	JSON401      *InvalidTokenError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RedirectAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RedirectAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefreshResponse
	JSON401      *InvalidTokenError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RefreshAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyResponse
	JSON401      *InvalidTokenError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r VerifyAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CallbackProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CallbackProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CallbackProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RequestProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RequestProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RequestProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFabricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FabricsResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListFabricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFabricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFabricResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
	JSON503      *RemoteUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdateFabricResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFabricResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFabricFromBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteFabricFromBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFabricFromBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFabricBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FabricBuildsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListFabricBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFabricBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachFabricToBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachFabricToBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachFabricToBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListForgesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ForgesResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListForgesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListForgesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateForgeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
	JSON503      *RemoteUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdateForgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateForgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteForgeFromBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteForgeFromBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteForgeFromBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListForgeBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ForgeBuildsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListForgeBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListForgeBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachForgeToBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachForgeToBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachForgeToBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupsResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupFromModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteGroupFromModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupFromModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupModsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupModsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListGroupModsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupModsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachGroupToModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachGroupToModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachGroupToModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitGroupModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitGroupModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitGroupModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupFromPackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteGroupFromPackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupFromPackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupPacksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupPacksResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListGroupPacksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupPacksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachGroupToPackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachGroupToPackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachGroupToPackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitGroupPackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitGroupPackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitGroupPackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupFromUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteGroupFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGroupUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupUsersResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListGroupUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachGroupToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachGroupToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachGroupToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitGroupUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitGroupUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitGroupUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMinecraftsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MinecraftsResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListMinecraftsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMinecraftsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMinecraftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
	JSON503      *RemoteUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdateMinecraftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMinecraftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMinecraftFromBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteMinecraftFromBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMinecraftFromBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMinecraftBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MinecraftBuildsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListMinecraftBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMinecraftBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachMinecraftToBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachMinecraftToBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachMinecraftToBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModsResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListModsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteModAvatarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModAvatarResponse
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteModAvatarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteModAvatarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateModAvatarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModAvatarResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateModAvatarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateModAvatarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteModFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteModFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteModFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModGroupsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListModGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachModToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachModToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachModToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitModGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitModGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitModGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteModFromUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteModFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteModFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModUsersResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListModUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachModToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachModToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachModToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitModUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitModUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitModUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVersionFromBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteVersionFromBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVersionFromBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVersionBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionBuildsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListVersionBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVersionBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachVersionToBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachVersionToBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachVersionToBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNeoforgesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NeoforgesResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListNeoforgesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNeoforgesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNeoforgeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
	JSON503      *RemoteUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdateNeoforgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNeoforgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNeoforgeFromBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteNeoforgeFromBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNeoforgeFromBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNeoforgeBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NeoforgeBuildsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListNeoforgeBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNeoforgeBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachNeoforgeToBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachNeoforgeToBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachNeoforgeToBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPacksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PacksResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListPacksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPacksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreatePackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeletePackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowPackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowPackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowPackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdatePackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePackAvatarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackAvatarResponse
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeletePackAvatarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePackAvatarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePackAvatarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackAvatarResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreatePackAvatarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePackAvatarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBuildFromVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteBuildFromVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBuildFromVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBuildVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildVersionsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListBuildVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBuildVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachBuildToVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachBuildToVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachBuildToVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePackFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeletePackFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePackFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPackGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackGroupsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListPackGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPackGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachPackToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachPackToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachPackToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitPackGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitPackGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitPackGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePackFromUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeletePackFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePackFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPackUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackUsersResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListPackUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPackUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachPackToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachPackToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachPackToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitPackUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitPackUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitPackUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfileResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfileResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokenProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r TokenProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokenProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListQuiltsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuiltsResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListQuiltsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListQuiltsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateQuiltResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
	JSON503      *RemoteUnavailableError
}

// Status returns HTTPResponse.Status
func (r UpdateQuiltResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateQuiltResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteQuiltFromBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteQuiltFromBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteQuiltFromBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListQuiltBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuiltBuildsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListQuiltBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListQuiltBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachQuiltToBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachQuiltToBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachQuiltToBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersResponse
	JSON403      *NotAuthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *ActionFailedError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ShowUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteUserFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserGroupsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListUserGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachUserToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachUserToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachUserToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitUserGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitUserGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitUserGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserFromModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteUserFromModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserFromModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserModsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserModsResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListUserModsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserModsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachUserToModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachUserToModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachUserToModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitUserModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitUserModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitUserModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserFromPackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteUserFromPackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserFromPackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserPacksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserPacksResponse
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListUserPacksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserPacksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachUserToPackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *AlreadyAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AttachUserToPackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachUserToPackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitUserPackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SuccessMessage
	JSON400      *BadRequestError
	JSON403      *NotAuthorizedError
	JSON404      *NotFoundError
	JSON412      *NotAttachedError
	JSON422      *ValidationError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PermitUserPackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitUserPackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// LoginAuthWithBodyWithResponse request with arbitrary body returning *LoginAuthResponse
func (c *ClientWithResponses) LoginAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginAuthResponse, error) {
	rsp, err := c.LoginAuthWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginAuthResponse(rsp)
}

func (c *ClientWithResponses) LoginAuthWithResponse(ctx context.Context, body LoginAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginAuthResponse, error) {
	rsp, err := c.LoginAuth(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginAuthResponse(rsp)
}

// ListProvidersWithResponse request returning *ListProvidersResponse
func (c *ClientWithResponses) ListProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListProvidersResponse, error) {
	rsp, err := c.ListProviders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProvidersResponse(rsp)
}

// RedirectAuthWithBodyWithResponse request with arbitrary body returning *RedirectAuthResponse
func (c *ClientWithResponses) RedirectAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RedirectAuthResponse, error) {
	rsp, err := c.RedirectAuthWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRedirectAuthResponse(rsp)
}

func (c *ClientWithResponses) RedirectAuthWithResponse(ctx context.Context, body RedirectAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*RedirectAuthResponse, error) {
	rsp, err := c.RedirectAuth(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRedirectAuthResponse(rsp)
}

// RefreshAuthWithResponse request returning *RefreshAuthResponse
func (c *ClientWithResponses) RefreshAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RefreshAuthResponse, error) {
	rsp, err := c.RefreshAuth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshAuthResponse(rsp)
}

// VerifyAuthWithResponse request returning *VerifyAuthResponse
func (c *ClientWithResponses) VerifyAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VerifyAuthResponse, error) {
	rsp, err := c.VerifyAuth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyAuthResponse(rsp)
}

// CallbackProviderWithResponse request returning *CallbackProviderResponse
func (c *ClientWithResponses) CallbackProviderWithResponse(ctx context.Context, provider AuthProviderParam, params *CallbackProviderParams, reqEditors ...RequestEditorFn) (*CallbackProviderResponse, error) {
	rsp, err := c.CallbackProvider(ctx, provider, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCallbackProviderResponse(rsp)
}

// RequestProviderWithResponse request returning *RequestProviderResponse
func (c *ClientWithResponses) RequestProviderWithResponse(ctx context.Context, provider AuthProviderParam, reqEditors ...RequestEditorFn) (*RequestProviderResponse, error) {
	rsp, err := c.RequestProvider(ctx, provider, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRequestProviderResponse(rsp)
}

// ListFabricsWithResponse request returning *ListFabricsResponse
func (c *ClientWithResponses) ListFabricsWithResponse(ctx context.Context, params *ListFabricsParams, reqEditors ...RequestEditorFn) (*ListFabricsResponse, error) {
	rsp, err := c.ListFabrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFabricsResponse(rsp)
}

// UpdateFabricWithResponse request returning *UpdateFabricResponse
func (c *ClientWithResponses) UpdateFabricWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateFabricResponse, error) {
	rsp, err := c.UpdateFabric(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFabricResponse(rsp)
}

// DeleteFabricFromBuildWithBodyWithResponse request with arbitrary body returning *DeleteFabricFromBuildResponse
func (c *ClientWithResponses) DeleteFabricFromBuildWithBodyWithResponse(ctx context.Context, fabricID FabricID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteFabricFromBuildResponse, error) {
	rsp, err := c.DeleteFabricFromBuildWithBody(ctx, fabricID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFabricFromBuildResponse(rsp)
}

func (c *ClientWithResponses) DeleteFabricFromBuildWithResponse(ctx context.Context, fabricID FabricID, body DeleteFabricFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteFabricFromBuildResponse, error) {
	rsp, err := c.DeleteFabricFromBuild(ctx, fabricID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFabricFromBuildResponse(rsp)
}

// ListFabricBuildsWithResponse request returning *ListFabricBuildsResponse
func (c *ClientWithResponses) ListFabricBuildsWithResponse(ctx context.Context, fabricID FabricID, params *ListFabricBuildsParams, reqEditors ...RequestEditorFn) (*ListFabricBuildsResponse, error) {
	rsp, err := c.ListFabricBuilds(ctx, fabricID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFabricBuildsResponse(rsp)
}

// AttachFabricToBuildWithBodyWithResponse request with arbitrary body returning *AttachFabricToBuildResponse
func (c *ClientWithResponses) AttachFabricToBuildWithBodyWithResponse(ctx context.Context, fabricID FabricID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachFabricToBuildResponse, error) {
	rsp, err := c.AttachFabricToBuildWithBody(ctx, fabricID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachFabricToBuildResponse(rsp)
}

func (c *ClientWithResponses) AttachFabricToBuildWithResponse(ctx context.Context, fabricID FabricID, body AttachFabricToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachFabricToBuildResponse, error) {
	rsp, err := c.AttachFabricToBuild(ctx, fabricID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachFabricToBuildResponse(rsp)
}

// ListForgesWithResponse request returning *ListForgesResponse
func (c *ClientWithResponses) ListForgesWithResponse(ctx context.Context, params *ListForgesParams, reqEditors ...RequestEditorFn) (*ListForgesResponse, error) {
	rsp, err := c.ListForges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListForgesResponse(rsp)
}

// UpdateForgeWithResponse request returning *UpdateForgeResponse
func (c *ClientWithResponses) UpdateForgeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateForgeResponse, error) {
	rsp, err := c.UpdateForge(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateForgeResponse(rsp)
}

// DeleteForgeFromBuildWithBodyWithResponse request with arbitrary body returning *DeleteForgeFromBuildResponse
func (c *ClientWithResponses) DeleteForgeFromBuildWithBodyWithResponse(ctx context.Context, forgeID ForgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteForgeFromBuildResponse, error) {
	rsp, err := c.DeleteForgeFromBuildWithBody(ctx, forgeID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteForgeFromBuildResponse(rsp)
}

func (c *ClientWithResponses) DeleteForgeFromBuildWithResponse(ctx context.Context, forgeID ForgeID, body DeleteForgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteForgeFromBuildResponse, error) {
	rsp, err := c.DeleteForgeFromBuild(ctx, forgeID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteForgeFromBuildResponse(rsp)
}

// ListForgeBuildsWithResponse request returning *ListForgeBuildsResponse
func (c *ClientWithResponses) ListForgeBuildsWithResponse(ctx context.Context, forgeID ForgeID, params *ListForgeBuildsParams, reqEditors ...RequestEditorFn) (*ListForgeBuildsResponse, error) {
	rsp, err := c.ListForgeBuilds(ctx, forgeID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListForgeBuildsResponse(rsp)
}

// AttachForgeToBuildWithBodyWithResponse request with arbitrary body returning *AttachForgeToBuildResponse
func (c *ClientWithResponses) AttachForgeToBuildWithBodyWithResponse(ctx context.Context, forgeID ForgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachForgeToBuildResponse, error) {
	rsp, err := c.AttachForgeToBuildWithBody(ctx, forgeID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachForgeToBuildResponse(rsp)
}

func (c *ClientWithResponses) AttachForgeToBuildWithResponse(ctx context.Context, forgeID ForgeID, body AttachForgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachForgeToBuildResponse, error) {
	rsp, err := c.AttachForgeToBuild(ctx, forgeID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachForgeToBuildResponse(rsp)
}

// ListGroupsWithResponse request returning *ListGroupsResponse
func (c *ClientWithResponses) ListGroupsWithResponse(ctx context.Context, params *ListGroupsParams, reqEditors ...RequestEditorFn) (*ListGroupsResponse, error) {
	rsp, err := c.ListGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupsResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, groupID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// ShowGroupWithResponse request returning *ShowGroupResponse
func (c *ClientWithResponses) ShowGroupWithResponse(ctx context.Context, groupID GroupID, reqEditors ...RequestEditorFn) (*ShowGroupResponse, error) {
	rsp, err := c.ShowGroup(ctx, groupID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowGroupResponse(rsp)
}

// UpdateGroupWithBodyWithResponse request with arbitrary body returning *UpdateGroupResponse
func (c *ClientWithResponses) UpdateGroupWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroupWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateGroupWithResponse(ctx context.Context, groupID GroupID, body UpdateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupResponse, error) {
	rsp, err := c.UpdateGroup(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupResponse(rsp)
}

// DeleteGroupFromModWithBodyWithResponse request with arbitrary body returning *DeleteGroupFromModResponse
func (c *ClientWithResponses) DeleteGroupFromModWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGroupFromModResponse, error) {
	rsp, err := c.DeleteGroupFromModWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupFromModResponse(rsp)
}

func (c *ClientWithResponses) DeleteGroupFromModWithResponse(ctx context.Context, groupID GroupID, body DeleteGroupFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGroupFromModResponse, error) {
	rsp, err := c.DeleteGroupFromMod(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupFromModResponse(rsp)
}

// ListGroupModsWithResponse request returning *ListGroupModsResponse
func (c *ClientWithResponses) ListGroupModsWithResponse(ctx context.Context, groupID GroupID, params *ListGroupModsParams, reqEditors ...RequestEditorFn) (*ListGroupModsResponse, error) {
	rsp, err := c.ListGroupMods(ctx, groupID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupModsResponse(rsp)
}

// AttachGroupToModWithBodyWithResponse request with arbitrary body returning *AttachGroupToModResponse
func (c *ClientWithResponses) AttachGroupToModWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachGroupToModResponse, error) {
	rsp, err := c.AttachGroupToModWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachGroupToModResponse(rsp)
}

func (c *ClientWithResponses) AttachGroupToModWithResponse(ctx context.Context, groupID GroupID, body AttachGroupToModJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachGroupToModResponse, error) {
	rsp, err := c.AttachGroupToMod(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachGroupToModResponse(rsp)
}

// PermitGroupModWithBodyWithResponse request with arbitrary body returning *PermitGroupModResponse
func (c *ClientWithResponses) PermitGroupModWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitGroupModResponse, error) {
	rsp, err := c.PermitGroupModWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitGroupModResponse(rsp)
}

func (c *ClientWithResponses) PermitGroupModWithResponse(ctx context.Context, groupID GroupID, body PermitGroupModJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitGroupModResponse, error) {
	rsp, err := c.PermitGroupMod(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitGroupModResponse(rsp)
}

// DeleteGroupFromPackWithBodyWithResponse request with arbitrary body returning *DeleteGroupFromPackResponse
func (c *ClientWithResponses) DeleteGroupFromPackWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGroupFromPackResponse, error) {
	rsp, err := c.DeleteGroupFromPackWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupFromPackResponse(rsp)
}

func (c *ClientWithResponses) DeleteGroupFromPackWithResponse(ctx context.Context, groupID GroupID, body DeleteGroupFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGroupFromPackResponse, error) {
	rsp, err := c.DeleteGroupFromPack(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupFromPackResponse(rsp)
}

// ListGroupPacksWithResponse request returning *ListGroupPacksResponse
func (c *ClientWithResponses) ListGroupPacksWithResponse(ctx context.Context, groupID GroupID, params *ListGroupPacksParams, reqEditors ...RequestEditorFn) (*ListGroupPacksResponse, error) {
	rsp, err := c.ListGroupPacks(ctx, groupID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupPacksResponse(rsp)
}

// AttachGroupToPackWithBodyWithResponse request with arbitrary body returning *AttachGroupToPackResponse
func (c *ClientWithResponses) AttachGroupToPackWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachGroupToPackResponse, error) {
	rsp, err := c.AttachGroupToPackWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachGroupToPackResponse(rsp)
}

func (c *ClientWithResponses) AttachGroupToPackWithResponse(ctx context.Context, groupID GroupID, body AttachGroupToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachGroupToPackResponse, error) {
	rsp, err := c.AttachGroupToPack(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachGroupToPackResponse(rsp)
}

// PermitGroupPackWithBodyWithResponse request with arbitrary body returning *PermitGroupPackResponse
func (c *ClientWithResponses) PermitGroupPackWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitGroupPackResponse, error) {
	rsp, err := c.PermitGroupPackWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitGroupPackResponse(rsp)
}

func (c *ClientWithResponses) PermitGroupPackWithResponse(ctx context.Context, groupID GroupID, body PermitGroupPackJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitGroupPackResponse, error) {
	rsp, err := c.PermitGroupPack(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitGroupPackResponse(rsp)
}

// DeleteGroupFromUserWithBodyWithResponse request with arbitrary body returning *DeleteGroupFromUserResponse
func (c *ClientWithResponses) DeleteGroupFromUserWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteGroupFromUserResponse, error) {
	rsp, err := c.DeleteGroupFromUserWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupFromUserResponse(rsp)
}

func (c *ClientWithResponses) DeleteGroupFromUserWithResponse(ctx context.Context, groupID GroupID, body DeleteGroupFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteGroupFromUserResponse, error) {
	rsp, err := c.DeleteGroupFromUser(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupFromUserResponse(rsp)
}

// ListGroupUsersWithResponse request returning *ListGroupUsersResponse
func (c *ClientWithResponses) ListGroupUsersWithResponse(ctx context.Context, groupID GroupID, params *ListGroupUsersParams, reqEditors ...RequestEditorFn) (*ListGroupUsersResponse, error) {
	rsp, err := c.ListGroupUsers(ctx, groupID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupUsersResponse(rsp)
}

// AttachGroupToUserWithBodyWithResponse request with arbitrary body returning *AttachGroupToUserResponse
func (c *ClientWithResponses) AttachGroupToUserWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachGroupToUserResponse, error) {
	rsp, err := c.AttachGroupToUserWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachGroupToUserResponse(rsp)
}

func (c *ClientWithResponses) AttachGroupToUserWithResponse(ctx context.Context, groupID GroupID, body AttachGroupToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachGroupToUserResponse, error) {
	rsp, err := c.AttachGroupToUser(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachGroupToUserResponse(rsp)
}

// PermitGroupUserWithBodyWithResponse request with arbitrary body returning *PermitGroupUserResponse
func (c *ClientWithResponses) PermitGroupUserWithBodyWithResponse(ctx context.Context, groupID GroupID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitGroupUserResponse, error) {
	rsp, err := c.PermitGroupUserWithBody(ctx, groupID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitGroupUserResponse(rsp)
}

func (c *ClientWithResponses) PermitGroupUserWithResponse(ctx context.Context, groupID GroupID, body PermitGroupUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitGroupUserResponse, error) {
	rsp, err := c.PermitGroupUser(ctx, groupID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitGroupUserResponse(rsp)
}

// ListMinecraftsWithResponse request returning *ListMinecraftsResponse
func (c *ClientWithResponses) ListMinecraftsWithResponse(ctx context.Context, params *ListMinecraftsParams, reqEditors ...RequestEditorFn) (*ListMinecraftsResponse, error) {
	rsp, err := c.ListMinecrafts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMinecraftsResponse(rsp)
}

// UpdateMinecraftWithResponse request returning *UpdateMinecraftResponse
func (c *ClientWithResponses) UpdateMinecraftWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateMinecraftResponse, error) {
	rsp, err := c.UpdateMinecraft(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMinecraftResponse(rsp)
}

// DeleteMinecraftFromBuildWithBodyWithResponse request with arbitrary body returning *DeleteMinecraftFromBuildResponse
func (c *ClientWithResponses) DeleteMinecraftFromBuildWithBodyWithResponse(ctx context.Context, minecraftID MinecraftID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteMinecraftFromBuildResponse, error) {
	rsp, err := c.DeleteMinecraftFromBuildWithBody(ctx, minecraftID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMinecraftFromBuildResponse(rsp)
}

func (c *ClientWithResponses) DeleteMinecraftFromBuildWithResponse(ctx context.Context, minecraftID MinecraftID, body DeleteMinecraftFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteMinecraftFromBuildResponse, error) {
	rsp, err := c.DeleteMinecraftFromBuild(ctx, minecraftID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMinecraftFromBuildResponse(rsp)
}

// ListMinecraftBuildsWithResponse request returning *ListMinecraftBuildsResponse
func (c *ClientWithResponses) ListMinecraftBuildsWithResponse(ctx context.Context, minecraftID MinecraftID, params *ListMinecraftBuildsParams, reqEditors ...RequestEditorFn) (*ListMinecraftBuildsResponse, error) {
	rsp, err := c.ListMinecraftBuilds(ctx, minecraftID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMinecraftBuildsResponse(rsp)
}

// AttachMinecraftToBuildWithBodyWithResponse request with arbitrary body returning *AttachMinecraftToBuildResponse
func (c *ClientWithResponses) AttachMinecraftToBuildWithBodyWithResponse(ctx context.Context, minecraftID MinecraftID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachMinecraftToBuildResponse, error) {
	rsp, err := c.AttachMinecraftToBuildWithBody(ctx, minecraftID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachMinecraftToBuildResponse(rsp)
}

func (c *ClientWithResponses) AttachMinecraftToBuildWithResponse(ctx context.Context, minecraftID MinecraftID, body AttachMinecraftToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachMinecraftToBuildResponse, error) {
	rsp, err := c.AttachMinecraftToBuild(ctx, minecraftID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachMinecraftToBuildResponse(rsp)
}

// ListModsWithResponse request returning *ListModsResponse
func (c *ClientWithResponses) ListModsWithResponse(ctx context.Context, params *ListModsParams, reqEditors ...RequestEditorFn) (*ListModsResponse, error) {
	rsp, err := c.ListMods(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModsResponse(rsp)
}

// CreateModWithBodyWithResponse request with arbitrary body returning *CreateModResponse
func (c *ClientWithResponses) CreateModWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModResponse, error) {
	rsp, err := c.CreateModWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModResponse(rsp)
}

func (c *ClientWithResponses) CreateModWithResponse(ctx context.Context, body CreateModJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModResponse, error) {
	rsp, err := c.CreateMod(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModResponse(rsp)
}

// DeleteModWithResponse request returning *DeleteModResponse
func (c *ClientWithResponses) DeleteModWithResponse(ctx context.Context, modID ModID, reqEditors ...RequestEditorFn) (*DeleteModResponse, error) {
	rsp, err := c.DeleteMod(ctx, modID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModResponse(rsp)
}

// ShowModWithResponse request returning *ShowModResponse
func (c *ClientWithResponses) ShowModWithResponse(ctx context.Context, modID ModID, reqEditors ...RequestEditorFn) (*ShowModResponse, error) {
	rsp, err := c.ShowMod(ctx, modID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowModResponse(rsp)
}

// UpdateModWithBodyWithResponse request with arbitrary body returning *UpdateModResponse
func (c *ClientWithResponses) UpdateModWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateModResponse, error) {
	rsp, err := c.UpdateModWithBody(ctx, modID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateModResponse(rsp)
}

func (c *ClientWithResponses) UpdateModWithResponse(ctx context.Context, modID ModID, body UpdateModJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateModResponse, error) {
	rsp, err := c.UpdateMod(ctx, modID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateModResponse(rsp)
}

// DeleteModAvatarWithResponse request returning *DeleteModAvatarResponse
func (c *ClientWithResponses) DeleteModAvatarWithResponse(ctx context.Context, modID ModID, reqEditors ...RequestEditorFn) (*DeleteModAvatarResponse, error) {
	rsp, err := c.DeleteModAvatar(ctx, modID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModAvatarResponse(rsp)
}

// CreateModAvatarWithBodyWithResponse request with arbitrary body returning *CreateModAvatarResponse
func (c *ClientWithResponses) CreateModAvatarWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModAvatarResponse, error) {
	rsp, err := c.CreateModAvatarWithBody(ctx, modID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModAvatarResponse(rsp)
}

// DeleteModFromGroupWithBodyWithResponse request with arbitrary body returning *DeleteModFromGroupResponse
func (c *ClientWithResponses) DeleteModFromGroupWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteModFromGroupResponse, error) {
	rsp, err := c.DeleteModFromGroupWithBody(ctx, modID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModFromGroupResponse(rsp)
}

func (c *ClientWithResponses) DeleteModFromGroupWithResponse(ctx context.Context, modID ModID, body DeleteModFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteModFromGroupResponse, error) {
	rsp, err := c.DeleteModFromGroup(ctx, modID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModFromGroupResponse(rsp)
}

// ListModGroupsWithResponse request returning *ListModGroupsResponse
func (c *ClientWithResponses) ListModGroupsWithResponse(ctx context.Context, modID ModID, params *ListModGroupsParams, reqEditors ...RequestEditorFn) (*ListModGroupsResponse, error) {
	rsp, err := c.ListModGroups(ctx, modID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModGroupsResponse(rsp)
}

// AttachModToGroupWithBodyWithResponse request with arbitrary body returning *AttachModToGroupResponse
func (c *ClientWithResponses) AttachModToGroupWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachModToGroupResponse, error) {
	rsp, err := c.AttachModToGroupWithBody(ctx, modID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachModToGroupResponse(rsp)
}

func (c *ClientWithResponses) AttachModToGroupWithResponse(ctx context.Context, modID ModID, body AttachModToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachModToGroupResponse, error) {
	rsp, err := c.AttachModToGroup(ctx, modID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachModToGroupResponse(rsp)
}

// PermitModGroupWithBodyWithResponse request with arbitrary body returning *PermitModGroupResponse
func (c *ClientWithResponses) PermitModGroupWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitModGroupResponse, error) {
	rsp, err := c.PermitModGroupWithBody(ctx, modID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitModGroupResponse(rsp)
}

func (c *ClientWithResponses) PermitModGroupWithResponse(ctx context.Context, modID ModID, body PermitModGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitModGroupResponse, error) {
	rsp, err := c.PermitModGroup(ctx, modID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitModGroupResponse(rsp)
}

// DeleteModFromUserWithBodyWithResponse request with arbitrary body returning *DeleteModFromUserResponse
func (c *ClientWithResponses) DeleteModFromUserWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteModFromUserResponse, error) {
	rsp, err := c.DeleteModFromUserWithBody(ctx, modID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModFromUserResponse(rsp)
}

func (c *ClientWithResponses) DeleteModFromUserWithResponse(ctx context.Context, modID ModID, body DeleteModFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteModFromUserResponse, error) {
	rsp, err := c.DeleteModFromUser(ctx, modID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModFromUserResponse(rsp)
}

// ListModUsersWithResponse request returning *ListModUsersResponse
func (c *ClientWithResponses) ListModUsersWithResponse(ctx context.Context, modID ModID, params *ListModUsersParams, reqEditors ...RequestEditorFn) (*ListModUsersResponse, error) {
	rsp, err := c.ListModUsers(ctx, modID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModUsersResponse(rsp)
}

// AttachModToUserWithBodyWithResponse request with arbitrary body returning *AttachModToUserResponse
func (c *ClientWithResponses) AttachModToUserWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachModToUserResponse, error) {
	rsp, err := c.AttachModToUserWithBody(ctx, modID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachModToUserResponse(rsp)
}

func (c *ClientWithResponses) AttachModToUserWithResponse(ctx context.Context, modID ModID, body AttachModToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachModToUserResponse, error) {
	rsp, err := c.AttachModToUser(ctx, modID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachModToUserResponse(rsp)
}

// PermitModUserWithBodyWithResponse request with arbitrary body returning *PermitModUserResponse
func (c *ClientWithResponses) PermitModUserWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitModUserResponse, error) {
	rsp, err := c.PermitModUserWithBody(ctx, modID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitModUserResponse(rsp)
}

func (c *ClientWithResponses) PermitModUserWithResponse(ctx context.Context, modID ModID, body PermitModUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitModUserResponse, error) {
	rsp, err := c.PermitModUser(ctx, modID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitModUserResponse(rsp)
}

// ListVersionsWithResponse request returning *ListVersionsResponse
func (c *ClientWithResponses) ListVersionsWithResponse(ctx context.Context, modID ModID, params *ListVersionsParams, reqEditors ...RequestEditorFn) (*ListVersionsResponse, error) {
	rsp, err := c.ListVersions(ctx, modID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVersionsResponse(rsp)
}

// CreateVersionWithBodyWithResponse request with arbitrary body returning *CreateVersionResponse
func (c *ClientWithResponses) CreateVersionWithBodyWithResponse(ctx context.Context, modID ModID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVersionResponse, error) {
	rsp, err := c.CreateVersionWithBody(ctx, modID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVersionResponse(rsp)
}

func (c *ClientWithResponses) CreateVersionWithResponse(ctx context.Context, modID ModID, body CreateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVersionResponse, error) {
	rsp, err := c.CreateVersion(ctx, modID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVersionResponse(rsp)
}

// DeleteVersionWithResponse request returning *DeleteVersionResponse
func (c *ClientWithResponses) DeleteVersionWithResponse(ctx context.Context, modID ModID, versionID VersionID, reqEditors ...RequestEditorFn) (*DeleteVersionResponse, error) {
	rsp, err := c.DeleteVersion(ctx, modID, versionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVersionResponse(rsp)
}

// ShowVersionWithResponse request returning *ShowVersionResponse
func (c *ClientWithResponses) ShowVersionWithResponse(ctx context.Context, modID ModID, versionID VersionID, reqEditors ...RequestEditorFn) (*ShowVersionResponse, error) {
	rsp, err := c.ShowVersion(ctx, modID, versionID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowVersionResponse(rsp)
}

// UpdateVersionWithBodyWithResponse request with arbitrary body returning *UpdateVersionResponse
func (c *ClientWithResponses) UpdateVersionWithBodyWithResponse(ctx context.Context, modID ModID, versionID VersionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVersionResponse, error) {
	rsp, err := c.UpdateVersionWithBody(ctx, modID, versionID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVersionResponse(rsp)
}

func (c *ClientWithResponses) UpdateVersionWithResponse(ctx context.Context, modID ModID, versionID VersionID, body UpdateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVersionResponse, error) {
	rsp, err := c.UpdateVersion(ctx, modID, versionID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVersionResponse(rsp)
}

// DeleteVersionFromBuildWithBodyWithResponse request with arbitrary body returning *DeleteVersionFromBuildResponse
func (c *ClientWithResponses) DeleteVersionFromBuildWithBodyWithResponse(ctx context.Context, modID ModID, versionID VersionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVersionFromBuildResponse, error) {
	rsp, err := c.DeleteVersionFromBuildWithBody(ctx, modID, versionID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVersionFromBuildResponse(rsp)
}

func (c *ClientWithResponses) DeleteVersionFromBuildWithResponse(ctx context.Context, modID ModID, versionID VersionID, body DeleteVersionFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVersionFromBuildResponse, error) {
	rsp, err := c.DeleteVersionFromBuild(ctx, modID, versionID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVersionFromBuildResponse(rsp)
}

// ListVersionBuildsWithResponse request returning *ListVersionBuildsResponse
func (c *ClientWithResponses) ListVersionBuildsWithResponse(ctx context.Context, modID ModID, versionID VersionID, params *ListVersionBuildsParams, reqEditors ...RequestEditorFn) (*ListVersionBuildsResponse, error) {
	rsp, err := c.ListVersionBuilds(ctx, modID, versionID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVersionBuildsResponse(rsp)
}

// AttachVersionToBuildWithBodyWithResponse request with arbitrary body returning *AttachVersionToBuildResponse
func (c *ClientWithResponses) AttachVersionToBuildWithBodyWithResponse(ctx context.Context, modID ModID, versionID VersionID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachVersionToBuildResponse, error) {
	rsp, err := c.AttachVersionToBuildWithBody(ctx, modID, versionID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachVersionToBuildResponse(rsp)
}

func (c *ClientWithResponses) AttachVersionToBuildWithResponse(ctx context.Context, modID ModID, versionID VersionID, body AttachVersionToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachVersionToBuildResponse, error) {
	rsp, err := c.AttachVersionToBuild(ctx, modID, versionID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachVersionToBuildResponse(rsp)
}

// ListNeoforgesWithResponse request returning *ListNeoforgesResponse
func (c *ClientWithResponses) ListNeoforgesWithResponse(ctx context.Context, params *ListNeoforgesParams, reqEditors ...RequestEditorFn) (*ListNeoforgesResponse, error) {
	rsp, err := c.ListNeoforges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNeoforgesResponse(rsp)
}

// UpdateNeoforgeWithResponse request returning *UpdateNeoforgeResponse
func (c *ClientWithResponses) UpdateNeoforgeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateNeoforgeResponse, error) {
	rsp, err := c.UpdateNeoforge(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNeoforgeResponse(rsp)
}

// DeleteNeoforgeFromBuildWithBodyWithResponse request with arbitrary body returning *DeleteNeoforgeFromBuildResponse
func (c *ClientWithResponses) DeleteNeoforgeFromBuildWithBodyWithResponse(ctx context.Context, neoforgeID NeoforgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteNeoforgeFromBuildResponse, error) {
	rsp, err := c.DeleteNeoforgeFromBuildWithBody(ctx, neoforgeID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNeoforgeFromBuildResponse(rsp)
}

func (c *ClientWithResponses) DeleteNeoforgeFromBuildWithResponse(ctx context.Context, neoforgeID NeoforgeID, body DeleteNeoforgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteNeoforgeFromBuildResponse, error) {
	rsp, err := c.DeleteNeoforgeFromBuild(ctx, neoforgeID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNeoforgeFromBuildResponse(rsp)
}

// ListNeoforgeBuildsWithResponse request returning *ListNeoforgeBuildsResponse
func (c *ClientWithResponses) ListNeoforgeBuildsWithResponse(ctx context.Context, neoforgeID NeoforgeID, params *ListNeoforgeBuildsParams, reqEditors ...RequestEditorFn) (*ListNeoforgeBuildsResponse, error) {
	rsp, err := c.ListNeoforgeBuilds(ctx, neoforgeID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNeoforgeBuildsResponse(rsp)
}

// AttachNeoforgeToBuildWithBodyWithResponse request with arbitrary body returning *AttachNeoforgeToBuildResponse
func (c *ClientWithResponses) AttachNeoforgeToBuildWithBodyWithResponse(ctx context.Context, neoforgeID NeoforgeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachNeoforgeToBuildResponse, error) {
	rsp, err := c.AttachNeoforgeToBuildWithBody(ctx, neoforgeID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachNeoforgeToBuildResponse(rsp)
}

func (c *ClientWithResponses) AttachNeoforgeToBuildWithResponse(ctx context.Context, neoforgeID NeoforgeID, body AttachNeoforgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachNeoforgeToBuildResponse, error) {
	rsp, err := c.AttachNeoforgeToBuild(ctx, neoforgeID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachNeoforgeToBuildResponse(rsp)
}

// ListPacksWithResponse request returning *ListPacksResponse
func (c *ClientWithResponses) ListPacksWithResponse(ctx context.Context, params *ListPacksParams, reqEditors ...RequestEditorFn) (*ListPacksResponse, error) {
	rsp, err := c.ListPacks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPacksResponse(rsp)
}

// CreatePackWithBodyWithResponse request with arbitrary body returning *CreatePackResponse
func (c *ClientWithResponses) CreatePackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePackResponse, error) {
	rsp, err := c.CreatePackWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePackResponse(rsp)
}

func (c *ClientWithResponses) CreatePackWithResponse(ctx context.Context, body CreatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePackResponse, error) {
	rsp, err := c.CreatePack(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePackResponse(rsp)
}

// DeletePackWithResponse request returning *DeletePackResponse
func (c *ClientWithResponses) DeletePackWithResponse(ctx context.Context, packID PackID, reqEditors ...RequestEditorFn) (*DeletePackResponse, error) {
	rsp, err := c.DeletePack(ctx, packID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackResponse(rsp)
}

// ShowPackWithResponse request returning *ShowPackResponse
func (c *ClientWithResponses) ShowPackWithResponse(ctx context.Context, packID PackID, reqEditors ...RequestEditorFn) (*ShowPackResponse, error) {
	rsp, err := c.ShowPack(ctx, packID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowPackResponse(rsp)
}

// UpdatePackWithBodyWithResponse request with arbitrary body returning *UpdatePackResponse
func (c *ClientWithResponses) UpdatePackWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePackResponse, error) {
	rsp, err := c.UpdatePackWithBody(ctx, packID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePackResponse(rsp)
}

func (c *ClientWithResponses) UpdatePackWithResponse(ctx context.Context, packID PackID, body UpdatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePackResponse, error) {
	rsp, err := c.UpdatePack(ctx, packID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePackResponse(rsp)
}

// DeletePackAvatarWithResponse request returning *DeletePackAvatarResponse
func (c *ClientWithResponses) DeletePackAvatarWithResponse(ctx context.Context, packID PackID, reqEditors ...RequestEditorFn) (*DeletePackAvatarResponse, error) {
	rsp, err := c.DeletePackAvatar(ctx, packID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackAvatarResponse(rsp)
}

// CreatePackAvatarWithBodyWithResponse request with arbitrary body returning *CreatePackAvatarResponse
func (c *ClientWithResponses) CreatePackAvatarWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePackAvatarResponse, error) {
	rsp, err := c.CreatePackAvatarWithBody(ctx, packID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePackAvatarResponse(rsp)
}

// ListBuildsWithResponse request returning *ListBuildsResponse
func (c *ClientWithResponses) ListBuildsWithResponse(ctx context.Context, packID PackID, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*ListBuildsResponse, error) {
	rsp, err := c.ListBuilds(ctx, packID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBuildsResponse(rsp)
}

// CreateBuildWithBodyWithResponse request with arbitrary body returning *CreateBuildResponse
func (c *ClientWithResponses) CreateBuildWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBuildResponse, error) {
	rsp, err := c.CreateBuildWithBody(ctx, packID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBuildResponse(rsp)
}

func (c *ClientWithResponses) CreateBuildWithResponse(ctx context.Context, packID PackID, body CreateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBuildResponse, error) {
	rsp, err := c.CreateBuild(ctx, packID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBuildResponse(rsp)
}

// DeleteBuildWithResponse request returning *DeleteBuildResponse
func (c *ClientWithResponses) DeleteBuildWithResponse(ctx context.Context, packID PackID, buildID BuildID, reqEditors ...RequestEditorFn) (*DeleteBuildResponse, error) {
	rsp, err := c.DeleteBuild(ctx, packID, buildID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBuildResponse(rsp)
}

// ShowBuildWithResponse request returning *ShowBuildResponse
func (c *ClientWithResponses) ShowBuildWithResponse(ctx context.Context, packID PackID, buildID BuildID, reqEditors ...RequestEditorFn) (*ShowBuildResponse, error) {
	rsp, err := c.ShowBuild(ctx, packID, buildID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowBuildResponse(rsp)
}

// UpdateBuildWithBodyWithResponse request with arbitrary body returning *UpdateBuildResponse
func (c *ClientWithResponses) UpdateBuildWithBodyWithResponse(ctx context.Context, packID PackID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBuildResponse, error) {
	rsp, err := c.UpdateBuildWithBody(ctx, packID, buildID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBuildResponse(rsp)
}

func (c *ClientWithResponses) UpdateBuildWithResponse(ctx context.Context, packID PackID, buildID BuildID, body UpdateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBuildResponse, error) {
	rsp, err := c.UpdateBuild(ctx, packID, buildID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBuildResponse(rsp)
}

// DeleteBuildFromVersionWithBodyWithResponse request with arbitrary body returning *DeleteBuildFromVersionResponse
func (c *ClientWithResponses) DeleteBuildFromVersionWithBodyWithResponse(ctx context.Context, packID PackID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteBuildFromVersionResponse, error) {
	rsp, err := c.DeleteBuildFromVersionWithBody(ctx, packID, buildID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBuildFromVersionResponse(rsp)
}

func (c *ClientWithResponses) DeleteBuildFromVersionWithResponse(ctx context.Context, packID PackID, buildID BuildID, body DeleteBuildFromVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteBuildFromVersionResponse, error) {
	rsp, err := c.DeleteBuildFromVersion(ctx, packID, buildID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBuildFromVersionResponse(rsp)
}

// ListBuildVersionsWithResponse request returning *ListBuildVersionsResponse
func (c *ClientWithResponses) ListBuildVersionsWithResponse(ctx context.Context, packID PackID, buildID BuildID, params *ListBuildVersionsParams, reqEditors ...RequestEditorFn) (*ListBuildVersionsResponse, error) {
	rsp, err := c.ListBuildVersions(ctx, packID, buildID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBuildVersionsResponse(rsp)
}

// AttachBuildToVersionWithBodyWithResponse request with arbitrary body returning *AttachBuildToVersionResponse
func (c *ClientWithResponses) AttachBuildToVersionWithBodyWithResponse(ctx context.Context, packID PackID, buildID BuildID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachBuildToVersionResponse, error) {
	rsp, err := c.AttachBuildToVersionWithBody(ctx, packID, buildID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachBuildToVersionResponse(rsp)
}

func (c *ClientWithResponses) AttachBuildToVersionWithResponse(ctx context.Context, packID PackID, buildID BuildID, body AttachBuildToVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachBuildToVersionResponse, error) {
	rsp, err := c.AttachBuildToVersion(ctx, packID, buildID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachBuildToVersionResponse(rsp)
}

// DeletePackFromGroupWithBodyWithResponse request with arbitrary body returning *DeletePackFromGroupResponse
func (c *ClientWithResponses) DeletePackFromGroupWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePackFromGroupResponse, error) {
	rsp, err := c.DeletePackFromGroupWithBody(ctx, packID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackFromGroupResponse(rsp)
}

func (c *ClientWithResponses) DeletePackFromGroupWithResponse(ctx context.Context, packID PackID, body DeletePackFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePackFromGroupResponse, error) {
	rsp, err := c.DeletePackFromGroup(ctx, packID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackFromGroupResponse(rsp)
}

// ListPackGroupsWithResponse request returning *ListPackGroupsResponse
func (c *ClientWithResponses) ListPackGroupsWithResponse(ctx context.Context, packID PackID, params *ListPackGroupsParams, reqEditors ...RequestEditorFn) (*ListPackGroupsResponse, error) {
	rsp, err := c.ListPackGroups(ctx, packID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPackGroupsResponse(rsp)
}

// AttachPackToGroupWithBodyWithResponse request with arbitrary body returning *AttachPackToGroupResponse
func (c *ClientWithResponses) AttachPackToGroupWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachPackToGroupResponse, error) {
	rsp, err := c.AttachPackToGroupWithBody(ctx, packID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPackToGroupResponse(rsp)
}

func (c *ClientWithResponses) AttachPackToGroupWithResponse(ctx context.Context, packID PackID, body AttachPackToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachPackToGroupResponse, error) {
	rsp, err := c.AttachPackToGroup(ctx, packID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPackToGroupResponse(rsp)
}

// PermitPackGroupWithBodyWithResponse request with arbitrary body returning *PermitPackGroupResponse
func (c *ClientWithResponses) PermitPackGroupWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitPackGroupResponse, error) {
	rsp, err := c.PermitPackGroupWithBody(ctx, packID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitPackGroupResponse(rsp)
}

func (c *ClientWithResponses) PermitPackGroupWithResponse(ctx context.Context, packID PackID, body PermitPackGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitPackGroupResponse, error) {
	rsp, err := c.PermitPackGroup(ctx, packID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitPackGroupResponse(rsp)
}

// DeletePackFromUserWithBodyWithResponse request with arbitrary body returning *DeletePackFromUserResponse
func (c *ClientWithResponses) DeletePackFromUserWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePackFromUserResponse, error) {
	rsp, err := c.DeletePackFromUserWithBody(ctx, packID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackFromUserResponse(rsp)
}

func (c *ClientWithResponses) DeletePackFromUserWithResponse(ctx context.Context, packID PackID, body DeletePackFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePackFromUserResponse, error) {
	rsp, err := c.DeletePackFromUser(ctx, packID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackFromUserResponse(rsp)
}

// ListPackUsersWithResponse request returning *ListPackUsersResponse
func (c *ClientWithResponses) ListPackUsersWithResponse(ctx context.Context, packID PackID, params *ListPackUsersParams, reqEditors ...RequestEditorFn) (*ListPackUsersResponse, error) {
	rsp, err := c.ListPackUsers(ctx, packID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPackUsersResponse(rsp)
}

// AttachPackToUserWithBodyWithResponse request with arbitrary body returning *AttachPackToUserResponse
func (c *ClientWithResponses) AttachPackToUserWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachPackToUserResponse, error) {
	rsp, err := c.AttachPackToUserWithBody(ctx, packID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPackToUserResponse(rsp)
}

func (c *ClientWithResponses) AttachPackToUserWithResponse(ctx context.Context, packID PackID, body AttachPackToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachPackToUserResponse, error) {
	rsp, err := c.AttachPackToUser(ctx, packID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPackToUserResponse(rsp)
}

// PermitPackUserWithBodyWithResponse request with arbitrary body returning *PermitPackUserResponse
func (c *ClientWithResponses) PermitPackUserWithBodyWithResponse(ctx context.Context, packID PackID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitPackUserResponse, error) {
	rsp, err := c.PermitPackUserWithBody(ctx, packID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitPackUserResponse(rsp)
}

func (c *ClientWithResponses) PermitPackUserWithResponse(ctx context.Context, packID PackID, body PermitPackUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitPackUserResponse, error) {
	rsp, err := c.PermitPackUser(ctx, packID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitPackUserResponse(rsp)
}

// ShowProfileWithResponse request returning *ShowProfileResponse
func (c *ClientWithResponses) ShowProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ShowProfileResponse, error) {
	rsp, err := c.ShowProfile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowProfileResponse(rsp)
}

// UpdateProfileWithBodyWithResponse request with arbitrary body returning *UpdateProfileResponse
func (c *ClientWithResponses) UpdateProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error) {
	rsp, err := c.UpdateProfileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProfileResponse(rsp)
}

func (c *ClientWithResponses) UpdateProfileWithResponse(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error) {
	rsp, err := c.UpdateProfile(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProfileResponse(rsp)
}

// TokenProfileWithResponse request returning *TokenProfileResponse
func (c *ClientWithResponses) TokenProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TokenProfileResponse, error) {
	rsp, err := c.TokenProfile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenProfileResponse(rsp)
}

// ListQuiltsWithResponse request returning *ListQuiltsResponse
func (c *ClientWithResponses) ListQuiltsWithResponse(ctx context.Context, params *ListQuiltsParams, reqEditors ...RequestEditorFn) (*ListQuiltsResponse, error) {
	rsp, err := c.ListQuilts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListQuiltsResponse(rsp)
}

// UpdateQuiltWithResponse request returning *UpdateQuiltResponse
func (c *ClientWithResponses) UpdateQuiltWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateQuiltResponse, error) {
	rsp, err := c.UpdateQuilt(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateQuiltResponse(rsp)
}

// DeleteQuiltFromBuildWithBodyWithResponse request with arbitrary body returning *DeleteQuiltFromBuildResponse
func (c *ClientWithResponses) DeleteQuiltFromBuildWithBodyWithResponse(ctx context.Context, quiltID QuiltID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteQuiltFromBuildResponse, error) {
	rsp, err := c.DeleteQuiltFromBuildWithBody(ctx, quiltID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteQuiltFromBuildResponse(rsp)
}

func (c *ClientWithResponses) DeleteQuiltFromBuildWithResponse(ctx context.Context, quiltID QuiltID, body DeleteQuiltFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteQuiltFromBuildResponse, error) {
	rsp, err := c.DeleteQuiltFromBuild(ctx, quiltID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteQuiltFromBuildResponse(rsp)
}

// ListQuiltBuildsWithResponse request returning *ListQuiltBuildsResponse
func (c *ClientWithResponses) ListQuiltBuildsWithResponse(ctx context.Context, quiltID QuiltID, params *ListQuiltBuildsParams, reqEditors ...RequestEditorFn) (*ListQuiltBuildsResponse, error) {
	rsp, err := c.ListQuiltBuilds(ctx, quiltID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListQuiltBuildsResponse(rsp)
}

// AttachQuiltToBuildWithBodyWithResponse request with arbitrary body returning *AttachQuiltToBuildResponse
func (c *ClientWithResponses) AttachQuiltToBuildWithBodyWithResponse(ctx context.Context, quiltID QuiltID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachQuiltToBuildResponse, error) {
	rsp, err := c.AttachQuiltToBuildWithBody(ctx, quiltID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachQuiltToBuildResponse(rsp)
}

func (c *ClientWithResponses) AttachQuiltToBuildWithResponse(ctx context.Context, quiltID QuiltID, body AttachQuiltToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachQuiltToBuildResponse, error) {
	rsp, err := c.AttachQuiltToBuild(ctx, quiltID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachQuiltToBuildResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// ShowUserWithResponse request returning *ShowUserResponse
func (c *ClientWithResponses) ShowUserWithResponse(ctx context.Context, userID UserID, reqEditors ...RequestEditorFn) (*ShowUserResponse, error) {
	rsp, err := c.ShowUser(ctx, userID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, userID UserID, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// DeleteUserFromGroupWithBodyWithResponse request with arbitrary body returning *DeleteUserFromGroupResponse
func (c *ClientWithResponses) DeleteUserFromGroupWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromGroupResponse, error) {
	rsp, err := c.DeleteUserFromGroupWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromGroupResponse(rsp)
}

func (c *ClientWithResponses) DeleteUserFromGroupWithResponse(ctx context.Context, userID UserID, body DeleteUserFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromGroupResponse, error) {
	rsp, err := c.DeleteUserFromGroup(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromGroupResponse(rsp)
}

// ListUserGroupsWithResponse request returning *ListUserGroupsResponse
func (c *ClientWithResponses) ListUserGroupsWithResponse(ctx context.Context, userID UserID, params *ListUserGroupsParams, reqEditors ...RequestEditorFn) (*ListUserGroupsResponse, error) {
	rsp, err := c.ListUserGroups(ctx, userID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserGroupsResponse(rsp)
}

// AttachUserToGroupWithBodyWithResponse request with arbitrary body returning *AttachUserToGroupResponse
func (c *ClientWithResponses) AttachUserToGroupWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToGroupResponse, error) {
	rsp, err := c.AttachUserToGroupWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToGroupResponse(rsp)
}

func (c *ClientWithResponses) AttachUserToGroupWithResponse(ctx context.Context, userID UserID, body AttachUserToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToGroupResponse, error) {
	rsp, err := c.AttachUserToGroup(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToGroupResponse(rsp)
}

// PermitUserGroupWithBodyWithResponse request with arbitrary body returning *PermitUserGroupResponse
func (c *ClientWithResponses) PermitUserGroupWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserGroupResponse, error) {
	rsp, err := c.PermitUserGroupWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserGroupResponse(rsp)
}

func (c *ClientWithResponses) PermitUserGroupWithResponse(ctx context.Context, userID UserID, body PermitUserGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserGroupResponse, error) {
	rsp, err := c.PermitUserGroup(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserGroupResponse(rsp)
}

// DeleteUserFromModWithBodyWithResponse request with arbitrary body returning *DeleteUserFromModResponse
func (c *ClientWithResponses) DeleteUserFromModWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromModResponse, error) {
	rsp, err := c.DeleteUserFromModWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromModResponse(rsp)
}

func (c *ClientWithResponses) DeleteUserFromModWithResponse(ctx context.Context, userID UserID, body DeleteUserFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromModResponse, error) {
	rsp, err := c.DeleteUserFromMod(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromModResponse(rsp)
}

// ListUserModsWithResponse request returning *ListUserModsResponse
func (c *ClientWithResponses) ListUserModsWithResponse(ctx context.Context, userID UserID, params *ListUserModsParams, reqEditors ...RequestEditorFn) (*ListUserModsResponse, error) {
	rsp, err := c.ListUserMods(ctx, userID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserModsResponse(rsp)
}

// AttachUserToModWithBodyWithResponse request with arbitrary body returning *AttachUserToModResponse
func (c *ClientWithResponses) AttachUserToModWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToModResponse, error) {
	rsp, err := c.AttachUserToModWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToModResponse(rsp)
}

func (c *ClientWithResponses) AttachUserToModWithResponse(ctx context.Context, userID UserID, body AttachUserToModJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToModResponse, error) {
	rsp, err := c.AttachUserToMod(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToModResponse(rsp)
}

// PermitUserModWithBodyWithResponse request with arbitrary body returning *PermitUserModResponse
func (c *ClientWithResponses) PermitUserModWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserModResponse, error) {
	rsp, err := c.PermitUserModWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserModResponse(rsp)
}

func (c *ClientWithResponses) PermitUserModWithResponse(ctx context.Context, userID UserID, body PermitUserModJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserModResponse, error) {
	rsp, err := c.PermitUserMod(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserModResponse(rsp)
}

// DeleteUserFromPackWithBodyWithResponse request with arbitrary body returning *DeleteUserFromPackResponse
func (c *ClientWithResponses) DeleteUserFromPackWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromPackResponse, error) {
	rsp, err := c.DeleteUserFromPackWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromPackResponse(rsp)
}

func (c *ClientWithResponses) DeleteUserFromPackWithResponse(ctx context.Context, userID UserID, body DeleteUserFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromPackResponse, error) {
	rsp, err := c.DeleteUserFromPack(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromPackResponse(rsp)
}

// ListUserPacksWithResponse request returning *ListUserPacksResponse
func (c *ClientWithResponses) ListUserPacksWithResponse(ctx context.Context, userID UserID, params *ListUserPacksParams, reqEditors ...RequestEditorFn) (*ListUserPacksResponse, error) {
	rsp, err := c.ListUserPacks(ctx, userID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserPacksResponse(rsp)
}

// AttachUserToPackWithBodyWithResponse request with arbitrary body returning *AttachUserToPackResponse
func (c *ClientWithResponses) AttachUserToPackWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToPackResponse, error) {
	rsp, err := c.AttachUserToPackWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToPackResponse(rsp)
}

func (c *ClientWithResponses) AttachUserToPackWithResponse(ctx context.Context, userID UserID, body AttachUserToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToPackResponse, error) {
	rsp, err := c.AttachUserToPack(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToPackResponse(rsp)
}

// PermitUserPackWithBodyWithResponse request with arbitrary body returning *PermitUserPackResponse
func (c *ClientWithResponses) PermitUserPackWithBodyWithResponse(ctx context.Context, userID UserID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserPackResponse, error) {
	rsp, err := c.PermitUserPackWithBody(ctx, userID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserPackResponse(rsp)
}

func (c *ClientWithResponses) PermitUserPackWithResponse(ctx context.Context, userID UserID, body PermitUserPackJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserPackResponse, error) {
	rsp, err := c.PermitUserPack(ctx, userID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserPackResponse(rsp)
}

// ParseLoginAuthResponse parses an HTTP response from a LoginAuthWithResponse call
func ParseLoginAuthResponse(rsp *http.Response) (*LoginAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BadCredentialsError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListProvidersResponse parses an HTTP response from a ListProvidersWithResponse call
func ParseListProvidersResponse(rsp *http.Response) (*ListProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProvidersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRedirectAuthResponse parses an HTTP response from a RedirectAuthWithResponse call
func ParseRedirectAuthResponse(rsp *http.Response) (*RedirectAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RedirectAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest InvalidTokenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRefreshAuthResponse parses an HTTP response from a RefreshAuthWithResponse call
func ParseRefreshAuthResponse(rsp *http.Response) (*RefreshAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefreshResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest InvalidTokenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseVerifyAuthResponse parses an HTTP response from a VerifyAuthWithResponse call
func ParseVerifyAuthResponse(rsp *http.Response) (*VerifyAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest InvalidTokenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCallbackProviderResponse parses an HTTP response from a CallbackProviderWithResponse call
func ParseCallbackProviderResponse(rsp *http.Response) (*CallbackProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CallbackProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRequestProviderResponse parses an HTTP response from a RequestProviderWithResponse call
func ParseRequestProviderResponse(rsp *http.Response) (*RequestProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RequestProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListFabricsResponse parses an HTTP response from a ListFabricsWithResponse call
func ParseListFabricsResponse(rsp *http.Response) (*ListFabricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFabricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FabricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateFabricResponse parses an HTTP response from a UpdateFabricWithResponse call
func ParseUpdateFabricResponse(rsp *http.Response) (*UpdateFabricResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFabricResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest RemoteUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteFabricFromBuildResponse parses an HTTP response from a DeleteFabricFromBuildWithResponse call
func ParseDeleteFabricFromBuildResponse(rsp *http.Response) (*DeleteFabricFromBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFabricFromBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListFabricBuildsResponse parses an HTTP response from a ListFabricBuildsWithResponse call
func ParseListFabricBuildsResponse(rsp *http.Response) (*ListFabricBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFabricBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FabricBuildsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachFabricToBuildResponse parses an HTTP response from a AttachFabricToBuildWithResponse call
func ParseAttachFabricToBuildResponse(rsp *http.Response) (*AttachFabricToBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachFabricToBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListForgesResponse parses an HTTP response from a ListForgesWithResponse call
func ParseListForgesResponse(rsp *http.Response) (*ListForgesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListForgesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ForgesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateForgeResponse parses an HTTP response from a UpdateForgeWithResponse call
func ParseUpdateForgeResponse(rsp *http.Response) (*UpdateForgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateForgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest RemoteUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteForgeFromBuildResponse parses an HTTP response from a DeleteForgeFromBuildWithResponse call
func ParseDeleteForgeFromBuildResponse(rsp *http.Response) (*DeleteForgeFromBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteForgeFromBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListForgeBuildsResponse parses an HTTP response from a ListForgeBuildsWithResponse call
func ParseListForgeBuildsResponse(rsp *http.Response) (*ListForgeBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListForgeBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ForgeBuildsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachForgeToBuildResponse parses an HTTP response from a AttachForgeToBuildWithResponse call
func ParseAttachForgeToBuildResponse(rsp *http.Response) (*AttachForgeToBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachForgeToBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListGroupsResponse parses an HTTP response from a ListGroupsWithResponse call
func ParseListGroupsResponse(rsp *http.Response) (*ListGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowGroupResponse parses an HTTP response from a ShowGroupWithResponse call
func ParseShowGroupResponse(rsp *http.Response) (*ShowGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateGroupResponse parses an HTTP response from a UpdateGroupWithResponse call
func ParseUpdateGroupResponse(rsp *http.Response) (*UpdateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteGroupFromModResponse parses an HTTP response from a DeleteGroupFromModWithResponse call
func ParseDeleteGroupFromModResponse(rsp *http.Response) (*DeleteGroupFromModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupFromModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListGroupModsResponse parses an HTTP response from a ListGroupModsWithResponse call
func ParseListGroupModsResponse(rsp *http.Response) (*ListGroupModsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupModsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupModsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachGroupToModResponse parses an HTTP response from a AttachGroupToModWithResponse call
func ParseAttachGroupToModResponse(rsp *http.Response) (*AttachGroupToModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachGroupToModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitGroupModResponse parses an HTTP response from a PermitGroupModWithResponse call
func ParsePermitGroupModResponse(rsp *http.Response) (*PermitGroupModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitGroupModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteGroupFromPackResponse parses an HTTP response from a DeleteGroupFromPackWithResponse call
func ParseDeleteGroupFromPackResponse(rsp *http.Response) (*DeleteGroupFromPackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupFromPackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListGroupPacksResponse parses an HTTP response from a ListGroupPacksWithResponse call
func ParseListGroupPacksResponse(rsp *http.Response) (*ListGroupPacksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupPacksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupPacksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachGroupToPackResponse parses an HTTP response from a AttachGroupToPackWithResponse call
func ParseAttachGroupToPackResponse(rsp *http.Response) (*AttachGroupToPackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachGroupToPackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitGroupPackResponse parses an HTTP response from a PermitGroupPackWithResponse call
func ParsePermitGroupPackResponse(rsp *http.Response) (*PermitGroupPackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitGroupPackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteGroupFromUserResponse parses an HTTP response from a DeleteGroupFromUserWithResponse call
func ParseDeleteGroupFromUserResponse(rsp *http.Response) (*DeleteGroupFromUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListGroupUsersResponse parses an HTTP response from a ListGroupUsersWithResponse call
func ParseListGroupUsersResponse(rsp *http.Response) (*ListGroupUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupUsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachGroupToUserResponse parses an HTTP response from a AttachGroupToUserWithResponse call
func ParseAttachGroupToUserResponse(rsp *http.Response) (*AttachGroupToUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachGroupToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitGroupUserResponse parses an HTTP response from a PermitGroupUserWithResponse call
func ParsePermitGroupUserResponse(rsp *http.Response) (*PermitGroupUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitGroupUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListMinecraftsResponse parses an HTTP response from a ListMinecraftsWithResponse call
func ParseListMinecraftsResponse(rsp *http.Response) (*ListMinecraftsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMinecraftsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MinecraftsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateMinecraftResponse parses an HTTP response from a UpdateMinecraftWithResponse call
func ParseUpdateMinecraftResponse(rsp *http.Response) (*UpdateMinecraftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMinecraftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest RemoteUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteMinecraftFromBuildResponse parses an HTTP response from a DeleteMinecraftFromBuildWithResponse call
func ParseDeleteMinecraftFromBuildResponse(rsp *http.Response) (*DeleteMinecraftFromBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMinecraftFromBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListMinecraftBuildsResponse parses an HTTP response from a ListMinecraftBuildsWithResponse call
func ParseListMinecraftBuildsResponse(rsp *http.Response) (*ListMinecraftBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMinecraftBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MinecraftBuildsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachMinecraftToBuildResponse parses an HTTP response from a AttachMinecraftToBuildWithResponse call
func ParseAttachMinecraftToBuildResponse(rsp *http.Response) (*AttachMinecraftToBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachMinecraftToBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListModsResponse parses an HTTP response from a ListModsWithResponse call
func ParseListModsResponse(rsp *http.Response) (*ListModsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateModResponse parses an HTTP response from a CreateModWithResponse call
func ParseCreateModResponse(rsp *http.Response) (*CreateModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteModResponse parses an HTTP response from a DeleteModWithResponse call
func ParseDeleteModResponse(rsp *http.Response) (*DeleteModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowModResponse parses an HTTP response from a ShowModWithResponse call
func ParseShowModResponse(rsp *http.Response) (*ShowModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateModResponse parses an HTTP response from a UpdateModWithResponse call
func ParseUpdateModResponse(rsp *http.Response) (*UpdateModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteModAvatarResponse parses an HTTP response from a DeleteModAvatarWithResponse call
func ParseDeleteModAvatarResponse(rsp *http.Response) (*DeleteModAvatarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteModAvatarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModAvatarResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateModAvatarResponse parses an HTTP response from a CreateModAvatarWithResponse call
func ParseCreateModAvatarResponse(rsp *http.Response) (*CreateModAvatarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateModAvatarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModAvatarResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteModFromGroupResponse parses an HTTP response from a DeleteModFromGroupWithResponse call
func ParseDeleteModFromGroupResponse(rsp *http.Response) (*DeleteModFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteModFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListModGroupsResponse parses an HTTP response from a ListModGroupsWithResponse call
func ParseListModGroupsResponse(rsp *http.Response) (*ListModGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModGroupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachModToGroupResponse parses an HTTP response from a AttachModToGroupWithResponse call
func ParseAttachModToGroupResponse(rsp *http.Response) (*AttachModToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachModToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitModGroupResponse parses an HTTP response from a PermitModGroupWithResponse call
func ParsePermitModGroupResponse(rsp *http.Response) (*PermitModGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitModGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteModFromUserResponse parses an HTTP response from a DeleteModFromUserWithResponse call
func ParseDeleteModFromUserResponse(rsp *http.Response) (*DeleteModFromUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteModFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListModUsersResponse parses an HTTP response from a ListModUsersWithResponse call
func ParseListModUsersResponse(rsp *http.Response) (*ListModUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModUsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachModToUserResponse parses an HTTP response from a AttachModToUserWithResponse call
func ParseAttachModToUserResponse(rsp *http.Response) (*AttachModToUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachModToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitModUserResponse parses an HTTP response from a PermitModUserWithResponse call
func ParsePermitModUserResponse(rsp *http.Response) (*PermitModUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitModUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListVersionsResponse parses an HTTP response from a ListVersionsWithResponse call
func ParseListVersionsResponse(rsp *http.Response) (*ListVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateVersionResponse parses an HTTP response from a CreateVersionWithResponse call
func ParseCreateVersionResponse(rsp *http.Response) (*CreateVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVersionResponse parses an HTTP response from a DeleteVersionWithResponse call
func ParseDeleteVersionResponse(rsp *http.Response) (*DeleteVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowVersionResponse parses an HTTP response from a ShowVersionWithResponse call
func ParseShowVersionResponse(rsp *http.Response) (*ShowVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateVersionResponse parses an HTTP response from a UpdateVersionWithResponse call
func ParseUpdateVersionResponse(rsp *http.Response) (*UpdateVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteVersionFromBuildResponse parses an HTTP response from a DeleteVersionFromBuildWithResponse call
func ParseDeleteVersionFromBuildResponse(rsp *http.Response) (*DeleteVersionFromBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVersionFromBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListVersionBuildsResponse parses an HTTP response from a ListVersionBuildsWithResponse call
func ParseListVersionBuildsResponse(rsp *http.Response) (*ListVersionBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVersionBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionBuildsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachVersionToBuildResponse parses an HTTP response from a AttachVersionToBuildWithResponse call
func ParseAttachVersionToBuildResponse(rsp *http.Response) (*AttachVersionToBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachVersionToBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListNeoforgesResponse parses an HTTP response from a ListNeoforgesWithResponse call
func ParseListNeoforgesResponse(rsp *http.Response) (*ListNeoforgesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNeoforgesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NeoforgesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateNeoforgeResponse parses an HTTP response from a UpdateNeoforgeWithResponse call
func ParseUpdateNeoforgeResponse(rsp *http.Response) (*UpdateNeoforgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNeoforgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest RemoteUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteNeoforgeFromBuildResponse parses an HTTP response from a DeleteNeoforgeFromBuildWithResponse call
func ParseDeleteNeoforgeFromBuildResponse(rsp *http.Response) (*DeleteNeoforgeFromBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNeoforgeFromBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListNeoforgeBuildsResponse parses an HTTP response from a ListNeoforgeBuildsWithResponse call
func ParseListNeoforgeBuildsResponse(rsp *http.Response) (*ListNeoforgeBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNeoforgeBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NeoforgeBuildsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachNeoforgeToBuildResponse parses an HTTP response from a AttachNeoforgeToBuildWithResponse call
func ParseAttachNeoforgeToBuildResponse(rsp *http.Response) (*AttachNeoforgeToBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachNeoforgeToBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPacksResponse parses an HTTP response from a ListPacksWithResponse call
func ParseListPacksResponse(rsp *http.Response) (*ListPacksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPacksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PacksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePackResponse parses an HTTP response from a CreatePackWithResponse call
func ParseCreatePackResponse(rsp *http.Response) (*CreatePackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePackResponse parses an HTTP response from a DeletePackWithResponse call
func ParseDeletePackResponse(rsp *http.Response) (*DeletePackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowPackResponse parses an HTTP response from a ShowPackWithResponse call
func ParseShowPackResponse(rsp *http.Response) (*ShowPackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowPackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdatePackResponse parses an HTTP response from a UpdatePackWithResponse call
func ParseUpdatePackResponse(rsp *http.Response) (*UpdatePackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePackAvatarResponse parses an HTTP response from a DeletePackAvatarWithResponse call
func ParseDeletePackAvatarResponse(rsp *http.Response) (*DeletePackAvatarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePackAvatarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackAvatarResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePackAvatarResponse parses an HTTP response from a CreatePackAvatarWithResponse call
func ParseCreatePackAvatarResponse(rsp *http.Response) (*CreatePackAvatarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePackAvatarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackAvatarResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBuildsResponse parses an HTTP response from a ListBuildsWithResponse call
func ParseListBuildsResponse(rsp *http.Response) (*ListBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateBuildResponse parses an HTTP response from a CreateBuildWithResponse call
func ParseCreateBuildResponse(rsp *http.Response) (*CreateBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBuildResponse parses an HTTP response from a DeleteBuildWithResponse call
func ParseDeleteBuildResponse(rsp *http.Response) (*DeleteBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowBuildResponse parses an HTTP response from a ShowBuildWithResponse call
func ParseShowBuildResponse(rsp *http.Response) (*ShowBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateBuildResponse parses an HTTP response from a UpdateBuildWithResponse call
func ParseUpdateBuildResponse(rsp *http.Response) (*UpdateBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteBuildFromVersionResponse parses an HTTP response from a DeleteBuildFromVersionWithResponse call
func ParseDeleteBuildFromVersionResponse(rsp *http.Response) (*DeleteBuildFromVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBuildFromVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListBuildVersionsResponse parses an HTTP response from a ListBuildVersionsWithResponse call
func ParseListBuildVersionsResponse(rsp *http.Response) (*ListBuildVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBuildVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildVersionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachBuildToVersionResponse parses an HTTP response from a AttachBuildToVersionWithResponse call
func ParseAttachBuildToVersionResponse(rsp *http.Response) (*AttachBuildToVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachBuildToVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePackFromGroupResponse parses an HTTP response from a DeletePackFromGroupWithResponse call
func ParseDeletePackFromGroupResponse(rsp *http.Response) (*DeletePackFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePackFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPackGroupsResponse parses an HTTP response from a ListPackGroupsWithResponse call
func ParseListPackGroupsResponse(rsp *http.Response) (*ListPackGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPackGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackGroupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachPackToGroupResponse parses an HTTP response from a AttachPackToGroupWithResponse call
func ParseAttachPackToGroupResponse(rsp *http.Response) (*AttachPackToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachPackToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitPackGroupResponse parses an HTTP response from a PermitPackGroupWithResponse call
func ParsePermitPackGroupResponse(rsp *http.Response) (*PermitPackGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitPackGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePackFromUserResponse parses an HTTP response from a DeletePackFromUserWithResponse call
func ParseDeletePackFromUserResponse(rsp *http.Response) (*DeletePackFromUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePackFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListPackUsersResponse parses an HTTP response from a ListPackUsersWithResponse call
func ParseListPackUsersResponse(rsp *http.Response) (*ListPackUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPackUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackUsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachPackToUserResponse parses an HTTP response from a AttachPackToUserWithResponse call
func ParseAttachPackToUserResponse(rsp *http.Response) (*AttachPackToUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachPackToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitPackUserResponse parses an HTTP response from a PermitPackUserWithResponse call
func ParsePermitPackUserResponse(rsp *http.Response) (*PermitPackUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitPackUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowProfileResponse parses an HTTP response from a ShowProfileWithResponse call
func ParseShowProfileResponse(rsp *http.Response) (*ShowProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateProfileResponse parses an HTTP response from a UpdateProfileWithResponse call
func ParseUpdateProfileResponse(rsp *http.Response) (*UpdateProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTokenProfileResponse parses an HTTP response from a TokenProfileWithResponse call
func ParseTokenProfileResponse(rsp *http.Response) (*TokenProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokenProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListQuiltsResponse parses an HTTP response from a ListQuiltsWithResponse call
func ParseListQuiltsResponse(rsp *http.Response) (*ListQuiltsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListQuiltsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuiltsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateQuiltResponse parses an HTTP response from a UpdateQuiltWithResponse call
func ParseUpdateQuiltResponse(rsp *http.Response) (*UpdateQuiltResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateQuiltResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest RemoteUnavailableError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseDeleteQuiltFromBuildResponse parses an HTTP response from a DeleteQuiltFromBuildWithResponse call
func ParseDeleteQuiltFromBuildResponse(rsp *http.Response) (*DeleteQuiltFromBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteQuiltFromBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListQuiltBuildsResponse parses an HTTP response from a ListQuiltBuildsWithResponse call
func ParseListQuiltBuildsResponse(rsp *http.Response) (*ListQuiltBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListQuiltBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuiltBuildsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachQuiltToBuildResponse parses an HTTP response from a AttachQuiltToBuildWithResponse call
func ParseAttachQuiltToBuildResponse(rsp *http.Response) (*AttachQuiltToBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachQuiltToBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ActionFailedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseShowUserResponse parses an HTTP response from a ShowUserWithResponse call
func ParseShowUserResponse(rsp *http.Response) (*ShowUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserFromGroupResponse parses an HTTP response from a DeleteUserFromGroupWithResponse call
func ParseDeleteUserFromGroupResponse(rsp *http.Response) (*DeleteUserFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUserGroupsResponse parses an HTTP response from a ListUserGroupsWithResponse call
func ParseListUserGroupsResponse(rsp *http.Response) (*ListUserGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserGroupsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachUserToGroupResponse parses an HTTP response from a AttachUserToGroupWithResponse call
func ParseAttachUserToGroupResponse(rsp *http.Response) (*AttachUserToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachUserToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitUserGroupResponse parses an HTTP response from a PermitUserGroupWithResponse call
func ParsePermitUserGroupResponse(rsp *http.Response) (*PermitUserGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitUserGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserFromModResponse parses an HTTP response from a DeleteUserFromModWithResponse call
func ParseDeleteUserFromModResponse(rsp *http.Response) (*DeleteUserFromModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserFromModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUserModsResponse parses an HTTP response from a ListUserModsWithResponse call
func ParseListUserModsResponse(rsp *http.Response) (*ListUserModsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserModsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserModsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachUserToModResponse parses an HTTP response from a AttachUserToModWithResponse call
func ParseAttachUserToModResponse(rsp *http.Response) (*AttachUserToModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachUserToModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitUserModResponse parses an HTTP response from a PermitUserModWithResponse call
func ParsePermitUserModResponse(rsp *http.Response) (*PermitUserModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitUserModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserFromPackResponse parses an HTTP response from a DeleteUserFromPackWithResponse call
func ParseDeleteUserFromPackResponse(rsp *http.Response) (*DeleteUserFromPackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserFromPackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListUserPacksResponse parses an HTTP response from a ListUserPacksWithResponse call
func ParseListUserPacksResponse(rsp *http.Response) (*ListUserPacksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserPacksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserPacksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAttachUserToPackResponse parses an HTTP response from a AttachUserToPackWithResponse call
func ParseAttachUserToPackResponse(rsp *http.Response) (*AttachUserToPackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachUserToPackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest AlreadyAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePermitUserPackResponse parses an HTTP response from a PermitUserPackWithResponse call
func ParsePermitUserPackResponse(rsp *http.Response) (*PermitUserPackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitUserPackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SuccessMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotAuthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest NotAttachedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
