// Package kleister provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package kleister

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	BasicScopes  = "Basic.Scopes"
	BearerScopes = "Bearer.Scopes"
	CookieScopes = "Cookie.Scopes"
	HeaderScopes = "Header.Scopes"
)

// Defines values for ModTeamParamsPerm.
const (
	ModTeamParamsPermAdmin ModTeamParamsPerm = "admin"
	ModTeamParamsPermOwner ModTeamParamsPerm = "owner"
	ModTeamParamsPermUser  ModTeamParamsPerm = "user"
)

var (
	// ErrModTeamParamsPerm defines an error if an invalid value gets mapped.
	ErrModTeamParamsPerm = fmt.Errorf("invalid type for ModTeamParamsPerm")

	stringToModTeamParamsPerm = map[string]ModTeamParamsPerm{
		"admin": ModTeamParamsPermAdmin,
		"owner": ModTeamParamsPermOwner,
		"user":  ModTeamParamsPermUser,
	}
)

// ToModTeamParamsPerm acts as a helper to map a string to the defined enum.
func ToModTeamParamsPerm(val string) (ModTeamParamsPerm, error) {
	if res, ok := stringToModTeamParamsPerm[val]; ok {
		return res, nil
	}

	return ModTeamParamsPerm(""), ErrModTeamParamsPerm
}

// Defines values for ModUserParamsPerm.
const (
	ModUserParamsPermAdmin ModUserParamsPerm = "admin"
	ModUserParamsPermOwner ModUserParamsPerm = "owner"
	ModUserParamsPermUser  ModUserParamsPerm = "user"
)

var (
	// ErrModUserParamsPerm defines an error if an invalid value gets mapped.
	ErrModUserParamsPerm = fmt.Errorf("invalid type for ModUserParamsPerm")

	stringToModUserParamsPerm = map[string]ModUserParamsPerm{
		"admin": ModUserParamsPermAdmin,
		"owner": ModUserParamsPermOwner,
		"user":  ModUserParamsPermUser,
	}
)

// ToModUserParamsPerm acts as a helper to map a string to the defined enum.
func ToModUserParamsPerm(val string) (ModUserParamsPerm, error) {
	if res, ok := stringToModUserParamsPerm[val]; ok {
		return res, nil
	}

	return ModUserParamsPerm(""), ErrModUserParamsPerm
}

// Defines values for PackTeamParamsPerm.
const (
	PackTeamParamsPermAdmin PackTeamParamsPerm = "admin"
	PackTeamParamsPermOwner PackTeamParamsPerm = "owner"
	PackTeamParamsPermUser  PackTeamParamsPerm = "user"
)

var (
	// ErrPackTeamParamsPerm defines an error if an invalid value gets mapped.
	ErrPackTeamParamsPerm = fmt.Errorf("invalid type for PackTeamParamsPerm")

	stringToPackTeamParamsPerm = map[string]PackTeamParamsPerm{
		"admin": PackTeamParamsPermAdmin,
		"owner": PackTeamParamsPermOwner,
		"user":  PackTeamParamsPermUser,
	}
)

// ToPackTeamParamsPerm acts as a helper to map a string to the defined enum.
func ToPackTeamParamsPerm(val string) (PackTeamParamsPerm, error) {
	if res, ok := stringToPackTeamParamsPerm[val]; ok {
		return res, nil
	}

	return PackTeamParamsPerm(""), ErrPackTeamParamsPerm
}

// Defines values for PackUserParamsPerm.
const (
	PackUserParamsPermAdmin PackUserParamsPerm = "admin"
	PackUserParamsPermOwner PackUserParamsPerm = "owner"
	PackUserParamsPermUser  PackUserParamsPerm = "user"
)

var (
	// ErrPackUserParamsPerm defines an error if an invalid value gets mapped.
	ErrPackUserParamsPerm = fmt.Errorf("invalid type for PackUserParamsPerm")

	stringToPackUserParamsPerm = map[string]PackUserParamsPerm{
		"admin": PackUserParamsPermAdmin,
		"owner": PackUserParamsPermOwner,
		"user":  PackUserParamsPermUser,
	}
)

// ToPackUserParamsPerm acts as a helper to map a string to the defined enum.
func ToPackUserParamsPerm(val string) (PackUserParamsPerm, error) {
	if res, ok := stringToPackUserParamsPerm[val]; ok {
		return res, nil
	}

	return PackUserParamsPerm(""), ErrPackUserParamsPerm
}

// Defines values for TeamModPerm.
const (
	TeamModPermAdmin TeamModPerm = "admin"
	TeamModPermOwner TeamModPerm = "owner"
	TeamModPermUser  TeamModPerm = "user"
)

var (
	// ErrTeamModPerm defines an error if an invalid value gets mapped.
	ErrTeamModPerm = fmt.Errorf("invalid type for TeamModPerm")

	stringToTeamModPerm = map[string]TeamModPerm{
		"admin": TeamModPermAdmin,
		"owner": TeamModPermOwner,
		"user":  TeamModPermUser,
	}
)

// ToTeamModPerm acts as a helper to map a string to the defined enum.
func ToTeamModPerm(val string) (TeamModPerm, error) {
	if res, ok := stringToTeamModPerm[val]; ok {
		return res, nil
	}

	return TeamModPerm(""), ErrTeamModPerm
}

// Defines values for TeamModParamsPerm.
const (
	TeamModParamsPermAdmin TeamModParamsPerm = "admin"
	TeamModParamsPermOwner TeamModParamsPerm = "owner"
	TeamModParamsPermUser  TeamModParamsPerm = "user"
)

var (
	// ErrTeamModParamsPerm defines an error if an invalid value gets mapped.
	ErrTeamModParamsPerm = fmt.Errorf("invalid type for TeamModParamsPerm")

	stringToTeamModParamsPerm = map[string]TeamModParamsPerm{
		"admin": TeamModParamsPermAdmin,
		"owner": TeamModParamsPermOwner,
		"user":  TeamModParamsPermUser,
	}
)

// ToTeamModParamsPerm acts as a helper to map a string to the defined enum.
func ToTeamModParamsPerm(val string) (TeamModParamsPerm, error) {
	if res, ok := stringToTeamModParamsPerm[val]; ok {
		return res, nil
	}

	return TeamModParamsPerm(""), ErrTeamModParamsPerm
}

// Defines values for TeamPackPerm.
const (
	TeamPackPermAdmin TeamPackPerm = "admin"
	TeamPackPermOwner TeamPackPerm = "owner"
	TeamPackPermUser  TeamPackPerm = "user"
)

var (
	// ErrTeamPackPerm defines an error if an invalid value gets mapped.
	ErrTeamPackPerm = fmt.Errorf("invalid type for TeamPackPerm")

	stringToTeamPackPerm = map[string]TeamPackPerm{
		"admin": TeamPackPermAdmin,
		"owner": TeamPackPermOwner,
		"user":  TeamPackPermUser,
	}
)

// ToTeamPackPerm acts as a helper to map a string to the defined enum.
func ToTeamPackPerm(val string) (TeamPackPerm, error) {
	if res, ok := stringToTeamPackPerm[val]; ok {
		return res, nil
	}

	return TeamPackPerm(""), ErrTeamPackPerm
}

// Defines values for TeamPackParamsPerm.
const (
	TeamPackParamsPermAdmin TeamPackParamsPerm = "admin"
	TeamPackParamsPermOwner TeamPackParamsPerm = "owner"
	TeamPackParamsPermUser  TeamPackParamsPerm = "user"
)

var (
	// ErrTeamPackParamsPerm defines an error if an invalid value gets mapped.
	ErrTeamPackParamsPerm = fmt.Errorf("invalid type for TeamPackParamsPerm")

	stringToTeamPackParamsPerm = map[string]TeamPackParamsPerm{
		"admin": TeamPackParamsPermAdmin,
		"owner": TeamPackParamsPermOwner,
		"user":  TeamPackParamsPermUser,
	}
)

// ToTeamPackParamsPerm acts as a helper to map a string to the defined enum.
func ToTeamPackParamsPerm(val string) (TeamPackParamsPerm, error) {
	if res, ok := stringToTeamPackParamsPerm[val]; ok {
		return res, nil
	}

	return TeamPackParamsPerm(""), ErrTeamPackParamsPerm
}

// Defines values for TeamUserParamsPerm.
const (
	TeamUserParamsPermAdmin TeamUserParamsPerm = "admin"
	TeamUserParamsPermOwner TeamUserParamsPerm = "owner"
	TeamUserParamsPermUser  TeamUserParamsPerm = "user"
)

var (
	// ErrTeamUserParamsPerm defines an error if an invalid value gets mapped.
	ErrTeamUserParamsPerm = fmt.Errorf("invalid type for TeamUserParamsPerm")

	stringToTeamUserParamsPerm = map[string]TeamUserParamsPerm{
		"admin": TeamUserParamsPermAdmin,
		"owner": TeamUserParamsPermOwner,
		"user":  TeamUserParamsPermUser,
	}
)

// ToTeamUserParamsPerm acts as a helper to map a string to the defined enum.
func ToTeamUserParamsPerm(val string) (TeamUserParamsPerm, error) {
	if res, ok := stringToTeamUserParamsPerm[val]; ok {
		return res, nil
	}

	return TeamUserParamsPerm(""), ErrTeamUserParamsPerm
}

// Defines values for UserModPerm.
const (
	UserModPermAdmin UserModPerm = "admin"
	UserModPermOwner UserModPerm = "owner"
	UserModPermUser  UserModPerm = "user"
)

var (
	// ErrUserModPerm defines an error if an invalid value gets mapped.
	ErrUserModPerm = fmt.Errorf("invalid type for UserModPerm")

	stringToUserModPerm = map[string]UserModPerm{
		"admin": UserModPermAdmin,
		"owner": UserModPermOwner,
		"user":  UserModPermUser,
	}
)

// ToUserModPerm acts as a helper to map a string to the defined enum.
func ToUserModPerm(val string) (UserModPerm, error) {
	if res, ok := stringToUserModPerm[val]; ok {
		return res, nil
	}

	return UserModPerm(""), ErrUserModPerm
}

// Defines values for UserModParamsPerm.
const (
	UserModParamsPermAdmin UserModParamsPerm = "admin"
	UserModParamsPermOwner UserModParamsPerm = "owner"
	UserModParamsPermUser  UserModParamsPerm = "user"
)

var (
	// ErrUserModParamsPerm defines an error if an invalid value gets mapped.
	ErrUserModParamsPerm = fmt.Errorf("invalid type for UserModParamsPerm")

	stringToUserModParamsPerm = map[string]UserModParamsPerm{
		"admin": UserModParamsPermAdmin,
		"owner": UserModParamsPermOwner,
		"user":  UserModParamsPermUser,
	}
)

// ToUserModParamsPerm acts as a helper to map a string to the defined enum.
func ToUserModParamsPerm(val string) (UserModParamsPerm, error) {
	if res, ok := stringToUserModParamsPerm[val]; ok {
		return res, nil
	}

	return UserModParamsPerm(""), ErrUserModParamsPerm
}

// Defines values for UserPackPerm.
const (
	UserPackPermAdmin UserPackPerm = "admin"
	UserPackPermOwner UserPackPerm = "owner"
	UserPackPermUser  UserPackPerm = "user"
)

var (
	// ErrUserPackPerm defines an error if an invalid value gets mapped.
	ErrUserPackPerm = fmt.Errorf("invalid type for UserPackPerm")

	stringToUserPackPerm = map[string]UserPackPerm{
		"admin": UserPackPermAdmin,
		"owner": UserPackPermOwner,
		"user":  UserPackPermUser,
	}
)

// ToUserPackPerm acts as a helper to map a string to the defined enum.
func ToUserPackPerm(val string) (UserPackPerm, error) {
	if res, ok := stringToUserPackPerm[val]; ok {
		return res, nil
	}

	return UserPackPerm(""), ErrUserPackPerm
}

// Defines values for UserPackParamsPerm.
const (
	UserPackParamsPermAdmin UserPackParamsPerm = "admin"
	UserPackParamsPermOwner UserPackParamsPerm = "owner"
	UserPackParamsPermUser  UserPackParamsPerm = "user"
)

var (
	// ErrUserPackParamsPerm defines an error if an invalid value gets mapped.
	ErrUserPackParamsPerm = fmt.Errorf("invalid type for UserPackParamsPerm")

	stringToUserPackParamsPerm = map[string]UserPackParamsPerm{
		"admin": UserPackParamsPermAdmin,
		"owner": UserPackParamsPermOwner,
		"user":  UserPackParamsPermUser,
	}
)

// ToUserPackParamsPerm acts as a helper to map a string to the defined enum.
func ToUserPackParamsPerm(val string) (UserPackParamsPerm, error) {
	if res, ok := stringToUserPackParamsPerm[val]; ok {
		return res, nil
	}

	return UserPackParamsPerm(""), ErrUserPackParamsPerm
}

// Defines values for UserTeamPerm.
const (
	UserTeamPermAdmin UserTeamPerm = "admin"
	UserTeamPermOwner UserTeamPerm = "owner"
	UserTeamPermUser  UserTeamPerm = "user"
)

var (
	// ErrUserTeamPerm defines an error if an invalid value gets mapped.
	ErrUserTeamPerm = fmt.Errorf("invalid type for UserTeamPerm")

	stringToUserTeamPerm = map[string]UserTeamPerm{
		"admin": UserTeamPermAdmin,
		"owner": UserTeamPermOwner,
		"user":  UserTeamPermUser,
	}
)

// ToUserTeamPerm acts as a helper to map a string to the defined enum.
func ToUserTeamPerm(val string) (UserTeamPerm, error) {
	if res, ok := stringToUserTeamPerm[val]; ok {
		return res, nil
	}

	return UserTeamPerm(""), ErrUserTeamPerm
}

// Defines values for UserTeamParamsPerm.
const (
	UserTeamParamsPermAdmin UserTeamParamsPerm = "admin"
	UserTeamParamsPermOwner UserTeamParamsPerm = "owner"
	UserTeamParamsPermUser  UserTeamParamsPerm = "user"
)

var (
	// ErrUserTeamParamsPerm defines an error if an invalid value gets mapped.
	ErrUserTeamParamsPerm = fmt.Errorf("invalid type for UserTeamParamsPerm")

	stringToUserTeamParamsPerm = map[string]UserTeamParamsPerm{
		"admin": UserTeamParamsPermAdmin,
		"owner": UserTeamParamsPermOwner,
		"user":  UserTeamParamsPermUser,
	}
)

// ToUserTeamParamsPerm acts as a helper to map a string to the defined enum.
func ToUserTeamParamsPerm(val string) (UserTeamParamsPerm, error) {
	if res, ok := stringToUserTeamParamsPerm[val]; ok {
		return res, nil
	}

	return UserTeamParamsPerm(""), ErrUserTeamParamsPerm
}

// Defines values for ListFabricBuildsParamsSort.
const (
	ListFabricBuildsParamsSortBuildName   ListFabricBuildsParamsSort = "build_name"
	ListFabricBuildsParamsSortBuildPublic ListFabricBuildsParamsSort = "build_public"
	ListFabricBuildsParamsSortPackName    ListFabricBuildsParamsSort = "pack_name"
	ListFabricBuildsParamsSortPackSlug    ListFabricBuildsParamsSort = "pack_slug"
)

var (
	// ErrListFabricBuildsParamsSort defines an error if an invalid value gets mapped.
	ErrListFabricBuildsParamsSort = fmt.Errorf("invalid type for ListFabricBuildsParamsSort")

	stringToListFabricBuildsParamsSort = map[string]ListFabricBuildsParamsSort{
		"build_name":   ListFabricBuildsParamsSortBuildName,
		"build_public": ListFabricBuildsParamsSortBuildPublic,
		"pack_name":    ListFabricBuildsParamsSortPackName,
		"pack_slug":    ListFabricBuildsParamsSortPackSlug,
	}
)

// ToListFabricBuildsParamsSort acts as a helper to map a string to the defined enum.
func ToListFabricBuildsParamsSort(val string) (ListFabricBuildsParamsSort, error) {
	if res, ok := stringToListFabricBuildsParamsSort[val]; ok {
		return res, nil
	}

	return ListFabricBuildsParamsSort(""), ErrListFabricBuildsParamsSort
}

// Defines values for ListFabricBuildsParamsOrder.
const (
	ListFabricBuildsParamsOrderAsc  ListFabricBuildsParamsOrder = "asc"
	ListFabricBuildsParamsOrderDesc ListFabricBuildsParamsOrder = "desc"
)

var (
	// ErrListFabricBuildsParamsOrder defines an error if an invalid value gets mapped.
	ErrListFabricBuildsParamsOrder = fmt.Errorf("invalid type for ListFabricBuildsParamsOrder")

	stringToListFabricBuildsParamsOrder = map[string]ListFabricBuildsParamsOrder{
		"asc":  ListFabricBuildsParamsOrderAsc,
		"desc": ListFabricBuildsParamsOrderDesc,
	}
)

// ToListFabricBuildsParamsOrder acts as a helper to map a string to the defined enum.
func ToListFabricBuildsParamsOrder(val string) (ListFabricBuildsParamsOrder, error) {
	if res, ok := stringToListFabricBuildsParamsOrder[val]; ok {
		return res, nil
	}

	return ListFabricBuildsParamsOrder(""), ErrListFabricBuildsParamsOrder
}

// Defines values for ListForgeBuildsParamsSort.
const (
	ListForgeBuildsParamsSortBuildName   ListForgeBuildsParamsSort = "build_name"
	ListForgeBuildsParamsSortBuildPublic ListForgeBuildsParamsSort = "build_public"
	ListForgeBuildsParamsSortPackName    ListForgeBuildsParamsSort = "pack_name"
	ListForgeBuildsParamsSortPackSlug    ListForgeBuildsParamsSort = "pack_slug"
)

var (
	// ErrListForgeBuildsParamsSort defines an error if an invalid value gets mapped.
	ErrListForgeBuildsParamsSort = fmt.Errorf("invalid type for ListForgeBuildsParamsSort")

	stringToListForgeBuildsParamsSort = map[string]ListForgeBuildsParamsSort{
		"build_name":   ListForgeBuildsParamsSortBuildName,
		"build_public": ListForgeBuildsParamsSortBuildPublic,
		"pack_name":    ListForgeBuildsParamsSortPackName,
		"pack_slug":    ListForgeBuildsParamsSortPackSlug,
	}
)

// ToListForgeBuildsParamsSort acts as a helper to map a string to the defined enum.
func ToListForgeBuildsParamsSort(val string) (ListForgeBuildsParamsSort, error) {
	if res, ok := stringToListForgeBuildsParamsSort[val]; ok {
		return res, nil
	}

	return ListForgeBuildsParamsSort(""), ErrListForgeBuildsParamsSort
}

// Defines values for ListForgeBuildsParamsOrder.
const (
	ListForgeBuildsParamsOrderAsc  ListForgeBuildsParamsOrder = "asc"
	ListForgeBuildsParamsOrderDesc ListForgeBuildsParamsOrder = "desc"
)

var (
	// ErrListForgeBuildsParamsOrder defines an error if an invalid value gets mapped.
	ErrListForgeBuildsParamsOrder = fmt.Errorf("invalid type for ListForgeBuildsParamsOrder")

	stringToListForgeBuildsParamsOrder = map[string]ListForgeBuildsParamsOrder{
		"asc":  ListForgeBuildsParamsOrderAsc,
		"desc": ListForgeBuildsParamsOrderDesc,
	}
)

// ToListForgeBuildsParamsOrder acts as a helper to map a string to the defined enum.
func ToListForgeBuildsParamsOrder(val string) (ListForgeBuildsParamsOrder, error) {
	if res, ok := stringToListForgeBuildsParamsOrder[val]; ok {
		return res, nil
	}

	return ListForgeBuildsParamsOrder(""), ErrListForgeBuildsParamsOrder
}

// Defines values for ListMinecraftBuildsParamsSort.
const (
	ListMinecraftBuildsParamsSortBuildName   ListMinecraftBuildsParamsSort = "build_name"
	ListMinecraftBuildsParamsSortBuildPublic ListMinecraftBuildsParamsSort = "build_public"
	ListMinecraftBuildsParamsSortPackName    ListMinecraftBuildsParamsSort = "pack_name"
	ListMinecraftBuildsParamsSortPackSlug    ListMinecraftBuildsParamsSort = "pack_slug"
)

var (
	// ErrListMinecraftBuildsParamsSort defines an error if an invalid value gets mapped.
	ErrListMinecraftBuildsParamsSort = fmt.Errorf("invalid type for ListMinecraftBuildsParamsSort")

	stringToListMinecraftBuildsParamsSort = map[string]ListMinecraftBuildsParamsSort{
		"build_name":   ListMinecraftBuildsParamsSortBuildName,
		"build_public": ListMinecraftBuildsParamsSortBuildPublic,
		"pack_name":    ListMinecraftBuildsParamsSortPackName,
		"pack_slug":    ListMinecraftBuildsParamsSortPackSlug,
	}
)

// ToListMinecraftBuildsParamsSort acts as a helper to map a string to the defined enum.
func ToListMinecraftBuildsParamsSort(val string) (ListMinecraftBuildsParamsSort, error) {
	if res, ok := stringToListMinecraftBuildsParamsSort[val]; ok {
		return res, nil
	}

	return ListMinecraftBuildsParamsSort(""), ErrListMinecraftBuildsParamsSort
}

// Defines values for ListMinecraftBuildsParamsOrder.
const (
	ListMinecraftBuildsParamsOrderAsc  ListMinecraftBuildsParamsOrder = "asc"
	ListMinecraftBuildsParamsOrderDesc ListMinecraftBuildsParamsOrder = "desc"
)

var (
	// ErrListMinecraftBuildsParamsOrder defines an error if an invalid value gets mapped.
	ErrListMinecraftBuildsParamsOrder = fmt.Errorf("invalid type for ListMinecraftBuildsParamsOrder")

	stringToListMinecraftBuildsParamsOrder = map[string]ListMinecraftBuildsParamsOrder{
		"asc":  ListMinecraftBuildsParamsOrderAsc,
		"desc": ListMinecraftBuildsParamsOrderDesc,
	}
)

// ToListMinecraftBuildsParamsOrder acts as a helper to map a string to the defined enum.
func ToListMinecraftBuildsParamsOrder(val string) (ListMinecraftBuildsParamsOrder, error) {
	if res, ok := stringToListMinecraftBuildsParamsOrder[val]; ok {
		return res, nil
	}

	return ListMinecraftBuildsParamsOrder(""), ErrListMinecraftBuildsParamsOrder
}

// Defines values for ListModsParamsSort.
const (
	ListModsParamsSortName   ListModsParamsSort = "name"
	ListModsParamsSortPublic ListModsParamsSort = "public"
	ListModsParamsSortSlug   ListModsParamsSort = "slug"
)

var (
	// ErrListModsParamsSort defines an error if an invalid value gets mapped.
	ErrListModsParamsSort = fmt.Errorf("invalid type for ListModsParamsSort")

	stringToListModsParamsSort = map[string]ListModsParamsSort{
		"name":   ListModsParamsSortName,
		"public": ListModsParamsSortPublic,
		"slug":   ListModsParamsSortSlug,
	}
)

// ToListModsParamsSort acts as a helper to map a string to the defined enum.
func ToListModsParamsSort(val string) (ListModsParamsSort, error) {
	if res, ok := stringToListModsParamsSort[val]; ok {
		return res, nil
	}

	return ListModsParamsSort(""), ErrListModsParamsSort
}

// Defines values for ListModsParamsOrder.
const (
	ListModsParamsOrderAsc  ListModsParamsOrder = "asc"
	ListModsParamsOrderDesc ListModsParamsOrder = "desc"
)

var (
	// ErrListModsParamsOrder defines an error if an invalid value gets mapped.
	ErrListModsParamsOrder = fmt.Errorf("invalid type for ListModsParamsOrder")

	stringToListModsParamsOrder = map[string]ListModsParamsOrder{
		"asc":  ListModsParamsOrderAsc,
		"desc": ListModsParamsOrderDesc,
	}
)

// ToListModsParamsOrder acts as a helper to map a string to the defined enum.
func ToListModsParamsOrder(val string) (ListModsParamsOrder, error) {
	if res, ok := stringToListModsParamsOrder[val]; ok {
		return res, nil
	}

	return ListModsParamsOrder(""), ErrListModsParamsOrder
}

// Defines values for ListModTeamsParamsSort.
const (
	ListModTeamsParamsSortName ListModTeamsParamsSort = "name"
	ListModTeamsParamsSortSlug ListModTeamsParamsSort = "slug"
)

var (
	// ErrListModTeamsParamsSort defines an error if an invalid value gets mapped.
	ErrListModTeamsParamsSort = fmt.Errorf("invalid type for ListModTeamsParamsSort")

	stringToListModTeamsParamsSort = map[string]ListModTeamsParamsSort{
		"name": ListModTeamsParamsSortName,
		"slug": ListModTeamsParamsSortSlug,
	}
)

// ToListModTeamsParamsSort acts as a helper to map a string to the defined enum.
func ToListModTeamsParamsSort(val string) (ListModTeamsParamsSort, error) {
	if res, ok := stringToListModTeamsParamsSort[val]; ok {
		return res, nil
	}

	return ListModTeamsParamsSort(""), ErrListModTeamsParamsSort
}

// Defines values for ListModTeamsParamsOrder.
const (
	ListModTeamsParamsOrderAsc  ListModTeamsParamsOrder = "asc"
	ListModTeamsParamsOrderDesc ListModTeamsParamsOrder = "desc"
)

var (
	// ErrListModTeamsParamsOrder defines an error if an invalid value gets mapped.
	ErrListModTeamsParamsOrder = fmt.Errorf("invalid type for ListModTeamsParamsOrder")

	stringToListModTeamsParamsOrder = map[string]ListModTeamsParamsOrder{
		"asc":  ListModTeamsParamsOrderAsc,
		"desc": ListModTeamsParamsOrderDesc,
	}
)

// ToListModTeamsParamsOrder acts as a helper to map a string to the defined enum.
func ToListModTeamsParamsOrder(val string) (ListModTeamsParamsOrder, error) {
	if res, ok := stringToListModTeamsParamsOrder[val]; ok {
		return res, nil
	}

	return ListModTeamsParamsOrder(""), ErrListModTeamsParamsOrder
}

// Defines values for ListModUsersParamsSort.
const (
	ListModUsersParamsSortActive   ListModUsersParamsSort = "active"
	ListModUsersParamsSortAdmin    ListModUsersParamsSort = "admin"
	ListModUsersParamsSortEmail    ListModUsersParamsSort = "email"
	ListModUsersParamsSortFullname ListModUsersParamsSort = "fullname"
	ListModUsersParamsSortUsername ListModUsersParamsSort = "username"
)

var (
	// ErrListModUsersParamsSort defines an error if an invalid value gets mapped.
	ErrListModUsersParamsSort = fmt.Errorf("invalid type for ListModUsersParamsSort")

	stringToListModUsersParamsSort = map[string]ListModUsersParamsSort{
		"active":   ListModUsersParamsSortActive,
		"admin":    ListModUsersParamsSortAdmin,
		"email":    ListModUsersParamsSortEmail,
		"fullname": ListModUsersParamsSortFullname,
		"username": ListModUsersParamsSortUsername,
	}
)

// ToListModUsersParamsSort acts as a helper to map a string to the defined enum.
func ToListModUsersParamsSort(val string) (ListModUsersParamsSort, error) {
	if res, ok := stringToListModUsersParamsSort[val]; ok {
		return res, nil
	}

	return ListModUsersParamsSort(""), ErrListModUsersParamsSort
}

// Defines values for ListModUsersParamsOrder.
const (
	ListModUsersParamsOrderAsc  ListModUsersParamsOrder = "asc"
	ListModUsersParamsOrderDesc ListModUsersParamsOrder = "desc"
)

var (
	// ErrListModUsersParamsOrder defines an error if an invalid value gets mapped.
	ErrListModUsersParamsOrder = fmt.Errorf("invalid type for ListModUsersParamsOrder")

	stringToListModUsersParamsOrder = map[string]ListModUsersParamsOrder{
		"asc":  ListModUsersParamsOrderAsc,
		"desc": ListModUsersParamsOrderDesc,
	}
)

// ToListModUsersParamsOrder acts as a helper to map a string to the defined enum.
func ToListModUsersParamsOrder(val string) (ListModUsersParamsOrder, error) {
	if res, ok := stringToListModUsersParamsOrder[val]; ok {
		return res, nil
	}

	return ListModUsersParamsOrder(""), ErrListModUsersParamsOrder
}

// Defines values for ListVersionsParamsSort.
const (
	ListVersionsParamsSortName   ListVersionsParamsSort = "name"
	ListVersionsParamsSortPublic ListVersionsParamsSort = "public"
)

var (
	// ErrListVersionsParamsSort defines an error if an invalid value gets mapped.
	ErrListVersionsParamsSort = fmt.Errorf("invalid type for ListVersionsParamsSort")

	stringToListVersionsParamsSort = map[string]ListVersionsParamsSort{
		"name":   ListVersionsParamsSortName,
		"public": ListVersionsParamsSortPublic,
	}
)

// ToListVersionsParamsSort acts as a helper to map a string to the defined enum.
func ToListVersionsParamsSort(val string) (ListVersionsParamsSort, error) {
	if res, ok := stringToListVersionsParamsSort[val]; ok {
		return res, nil
	}

	return ListVersionsParamsSort(""), ErrListVersionsParamsSort
}

// Defines values for ListVersionsParamsOrder.
const (
	ListVersionsParamsOrderAsc  ListVersionsParamsOrder = "asc"
	ListVersionsParamsOrderDesc ListVersionsParamsOrder = "desc"
)

var (
	// ErrListVersionsParamsOrder defines an error if an invalid value gets mapped.
	ErrListVersionsParamsOrder = fmt.Errorf("invalid type for ListVersionsParamsOrder")

	stringToListVersionsParamsOrder = map[string]ListVersionsParamsOrder{
		"asc":  ListVersionsParamsOrderAsc,
		"desc": ListVersionsParamsOrderDesc,
	}
)

// ToListVersionsParamsOrder acts as a helper to map a string to the defined enum.
func ToListVersionsParamsOrder(val string) (ListVersionsParamsOrder, error) {
	if res, ok := stringToListVersionsParamsOrder[val]; ok {
		return res, nil
	}

	return ListVersionsParamsOrder(""), ErrListVersionsParamsOrder
}

// Defines values for ListVersionBuildsParamsSort.
const (
	ListVersionBuildsParamsSortName   ListVersionBuildsParamsSort = "name"
	ListVersionBuildsParamsSortPublic ListVersionBuildsParamsSort = "public"
)

var (
	// ErrListVersionBuildsParamsSort defines an error if an invalid value gets mapped.
	ErrListVersionBuildsParamsSort = fmt.Errorf("invalid type for ListVersionBuildsParamsSort")

	stringToListVersionBuildsParamsSort = map[string]ListVersionBuildsParamsSort{
		"name":   ListVersionBuildsParamsSortName,
		"public": ListVersionBuildsParamsSortPublic,
	}
)

// ToListVersionBuildsParamsSort acts as a helper to map a string to the defined enum.
func ToListVersionBuildsParamsSort(val string) (ListVersionBuildsParamsSort, error) {
	if res, ok := stringToListVersionBuildsParamsSort[val]; ok {
		return res, nil
	}

	return ListVersionBuildsParamsSort(""), ErrListVersionBuildsParamsSort
}

// Defines values for ListVersionBuildsParamsOrder.
const (
	ListVersionBuildsParamsOrderAsc  ListVersionBuildsParamsOrder = "asc"
	ListVersionBuildsParamsOrderDesc ListVersionBuildsParamsOrder = "desc"
)

var (
	// ErrListVersionBuildsParamsOrder defines an error if an invalid value gets mapped.
	ErrListVersionBuildsParamsOrder = fmt.Errorf("invalid type for ListVersionBuildsParamsOrder")

	stringToListVersionBuildsParamsOrder = map[string]ListVersionBuildsParamsOrder{
		"asc":  ListVersionBuildsParamsOrderAsc,
		"desc": ListVersionBuildsParamsOrderDesc,
	}
)

// ToListVersionBuildsParamsOrder acts as a helper to map a string to the defined enum.
func ToListVersionBuildsParamsOrder(val string) (ListVersionBuildsParamsOrder, error) {
	if res, ok := stringToListVersionBuildsParamsOrder[val]; ok {
		return res, nil
	}

	return ListVersionBuildsParamsOrder(""), ErrListVersionBuildsParamsOrder
}

// Defines values for ListNeoforgeBuildsParamsSort.
const (
	ListNeoforgeBuildsParamsSortBuildName   ListNeoforgeBuildsParamsSort = "build_name"
	ListNeoforgeBuildsParamsSortBuildPublic ListNeoforgeBuildsParamsSort = "build_public"
	ListNeoforgeBuildsParamsSortPackName    ListNeoforgeBuildsParamsSort = "pack_name"
	ListNeoforgeBuildsParamsSortPackSlug    ListNeoforgeBuildsParamsSort = "pack_slug"
)

var (
	// ErrListNeoforgeBuildsParamsSort defines an error if an invalid value gets mapped.
	ErrListNeoforgeBuildsParamsSort = fmt.Errorf("invalid type for ListNeoforgeBuildsParamsSort")

	stringToListNeoforgeBuildsParamsSort = map[string]ListNeoforgeBuildsParamsSort{
		"build_name":   ListNeoforgeBuildsParamsSortBuildName,
		"build_public": ListNeoforgeBuildsParamsSortBuildPublic,
		"pack_name":    ListNeoforgeBuildsParamsSortPackName,
		"pack_slug":    ListNeoforgeBuildsParamsSortPackSlug,
	}
)

// ToListNeoforgeBuildsParamsSort acts as a helper to map a string to the defined enum.
func ToListNeoforgeBuildsParamsSort(val string) (ListNeoforgeBuildsParamsSort, error) {
	if res, ok := stringToListNeoforgeBuildsParamsSort[val]; ok {
		return res, nil
	}

	return ListNeoforgeBuildsParamsSort(""), ErrListNeoforgeBuildsParamsSort
}

// Defines values for ListNeoforgeBuildsParamsOrder.
const (
	ListNeoforgeBuildsParamsOrderAsc  ListNeoforgeBuildsParamsOrder = "asc"
	ListNeoforgeBuildsParamsOrderDesc ListNeoforgeBuildsParamsOrder = "desc"
)

var (
	// ErrListNeoforgeBuildsParamsOrder defines an error if an invalid value gets mapped.
	ErrListNeoforgeBuildsParamsOrder = fmt.Errorf("invalid type for ListNeoforgeBuildsParamsOrder")

	stringToListNeoforgeBuildsParamsOrder = map[string]ListNeoforgeBuildsParamsOrder{
		"asc":  ListNeoforgeBuildsParamsOrderAsc,
		"desc": ListNeoforgeBuildsParamsOrderDesc,
	}
)

// ToListNeoforgeBuildsParamsOrder acts as a helper to map a string to the defined enum.
func ToListNeoforgeBuildsParamsOrder(val string) (ListNeoforgeBuildsParamsOrder, error) {
	if res, ok := stringToListNeoforgeBuildsParamsOrder[val]; ok {
		return res, nil
	}

	return ListNeoforgeBuildsParamsOrder(""), ErrListNeoforgeBuildsParamsOrder
}

// Defines values for ListPacksParamsSort.
const (
	ListPacksParamsSortName   ListPacksParamsSort = "name"
	ListPacksParamsSortPublic ListPacksParamsSort = "public"
	ListPacksParamsSortSlug   ListPacksParamsSort = "slug"
)

var (
	// ErrListPacksParamsSort defines an error if an invalid value gets mapped.
	ErrListPacksParamsSort = fmt.Errorf("invalid type for ListPacksParamsSort")

	stringToListPacksParamsSort = map[string]ListPacksParamsSort{
		"name":   ListPacksParamsSortName,
		"public": ListPacksParamsSortPublic,
		"slug":   ListPacksParamsSortSlug,
	}
)

// ToListPacksParamsSort acts as a helper to map a string to the defined enum.
func ToListPacksParamsSort(val string) (ListPacksParamsSort, error) {
	if res, ok := stringToListPacksParamsSort[val]; ok {
		return res, nil
	}

	return ListPacksParamsSort(""), ErrListPacksParamsSort
}

// Defines values for ListPacksParamsOrder.
const (
	ListPacksParamsOrderAsc  ListPacksParamsOrder = "asc"
	ListPacksParamsOrderDesc ListPacksParamsOrder = "desc"
)

var (
	// ErrListPacksParamsOrder defines an error if an invalid value gets mapped.
	ErrListPacksParamsOrder = fmt.Errorf("invalid type for ListPacksParamsOrder")

	stringToListPacksParamsOrder = map[string]ListPacksParamsOrder{
		"asc":  ListPacksParamsOrderAsc,
		"desc": ListPacksParamsOrderDesc,
	}
)

// ToListPacksParamsOrder acts as a helper to map a string to the defined enum.
func ToListPacksParamsOrder(val string) (ListPacksParamsOrder, error) {
	if res, ok := stringToListPacksParamsOrder[val]; ok {
		return res, nil
	}

	return ListPacksParamsOrder(""), ErrListPacksParamsOrder
}

// Defines values for ListBuildsParamsSort.
const (
	ListBuildsParamsSortName   ListBuildsParamsSort = "name"
	ListBuildsParamsSortPublic ListBuildsParamsSort = "public"
)

var (
	// ErrListBuildsParamsSort defines an error if an invalid value gets mapped.
	ErrListBuildsParamsSort = fmt.Errorf("invalid type for ListBuildsParamsSort")

	stringToListBuildsParamsSort = map[string]ListBuildsParamsSort{
		"name":   ListBuildsParamsSortName,
		"public": ListBuildsParamsSortPublic,
	}
)

// ToListBuildsParamsSort acts as a helper to map a string to the defined enum.
func ToListBuildsParamsSort(val string) (ListBuildsParamsSort, error) {
	if res, ok := stringToListBuildsParamsSort[val]; ok {
		return res, nil
	}

	return ListBuildsParamsSort(""), ErrListBuildsParamsSort
}

// Defines values for ListBuildsParamsOrder.
const (
	ListBuildsParamsOrderAsc  ListBuildsParamsOrder = "asc"
	ListBuildsParamsOrderDesc ListBuildsParamsOrder = "desc"
)

var (
	// ErrListBuildsParamsOrder defines an error if an invalid value gets mapped.
	ErrListBuildsParamsOrder = fmt.Errorf("invalid type for ListBuildsParamsOrder")

	stringToListBuildsParamsOrder = map[string]ListBuildsParamsOrder{
		"asc":  ListBuildsParamsOrderAsc,
		"desc": ListBuildsParamsOrderDesc,
	}
)

// ToListBuildsParamsOrder acts as a helper to map a string to the defined enum.
func ToListBuildsParamsOrder(val string) (ListBuildsParamsOrder, error) {
	if res, ok := stringToListBuildsParamsOrder[val]; ok {
		return res, nil
	}

	return ListBuildsParamsOrder(""), ErrListBuildsParamsOrder
}

// Defines values for ListBuildVersionsParamsSort.
const (
	ListBuildVersionsParamsSortName   ListBuildVersionsParamsSort = "name"
	ListBuildVersionsParamsSortPublic ListBuildVersionsParamsSort = "public"
)

var (
	// ErrListBuildVersionsParamsSort defines an error if an invalid value gets mapped.
	ErrListBuildVersionsParamsSort = fmt.Errorf("invalid type for ListBuildVersionsParamsSort")

	stringToListBuildVersionsParamsSort = map[string]ListBuildVersionsParamsSort{
		"name":   ListBuildVersionsParamsSortName,
		"public": ListBuildVersionsParamsSortPublic,
	}
)

// ToListBuildVersionsParamsSort acts as a helper to map a string to the defined enum.
func ToListBuildVersionsParamsSort(val string) (ListBuildVersionsParamsSort, error) {
	if res, ok := stringToListBuildVersionsParamsSort[val]; ok {
		return res, nil
	}

	return ListBuildVersionsParamsSort(""), ErrListBuildVersionsParamsSort
}

// Defines values for ListBuildVersionsParamsOrder.
const (
	ListBuildVersionsParamsOrderAsc  ListBuildVersionsParamsOrder = "asc"
	ListBuildVersionsParamsOrderDesc ListBuildVersionsParamsOrder = "desc"
)

var (
	// ErrListBuildVersionsParamsOrder defines an error if an invalid value gets mapped.
	ErrListBuildVersionsParamsOrder = fmt.Errorf("invalid type for ListBuildVersionsParamsOrder")

	stringToListBuildVersionsParamsOrder = map[string]ListBuildVersionsParamsOrder{
		"asc":  ListBuildVersionsParamsOrderAsc,
		"desc": ListBuildVersionsParamsOrderDesc,
	}
)

// ToListBuildVersionsParamsOrder acts as a helper to map a string to the defined enum.
func ToListBuildVersionsParamsOrder(val string) (ListBuildVersionsParamsOrder, error) {
	if res, ok := stringToListBuildVersionsParamsOrder[val]; ok {
		return res, nil
	}

	return ListBuildVersionsParamsOrder(""), ErrListBuildVersionsParamsOrder
}

// Defines values for ListPackTeamsParamsSort.
const (
	ListPackTeamsParamsSortName ListPackTeamsParamsSort = "name"
	ListPackTeamsParamsSortSlug ListPackTeamsParamsSort = "slug"
)

var (
	// ErrListPackTeamsParamsSort defines an error if an invalid value gets mapped.
	ErrListPackTeamsParamsSort = fmt.Errorf("invalid type for ListPackTeamsParamsSort")

	stringToListPackTeamsParamsSort = map[string]ListPackTeamsParamsSort{
		"name": ListPackTeamsParamsSortName,
		"slug": ListPackTeamsParamsSortSlug,
	}
)

// ToListPackTeamsParamsSort acts as a helper to map a string to the defined enum.
func ToListPackTeamsParamsSort(val string) (ListPackTeamsParamsSort, error) {
	if res, ok := stringToListPackTeamsParamsSort[val]; ok {
		return res, nil
	}

	return ListPackTeamsParamsSort(""), ErrListPackTeamsParamsSort
}

// Defines values for ListPackTeamsParamsOrder.
const (
	ListPackTeamsParamsOrderAsc  ListPackTeamsParamsOrder = "asc"
	ListPackTeamsParamsOrderDesc ListPackTeamsParamsOrder = "desc"
)

var (
	// ErrListPackTeamsParamsOrder defines an error if an invalid value gets mapped.
	ErrListPackTeamsParamsOrder = fmt.Errorf("invalid type for ListPackTeamsParamsOrder")

	stringToListPackTeamsParamsOrder = map[string]ListPackTeamsParamsOrder{
		"asc":  ListPackTeamsParamsOrderAsc,
		"desc": ListPackTeamsParamsOrderDesc,
	}
)

// ToListPackTeamsParamsOrder acts as a helper to map a string to the defined enum.
func ToListPackTeamsParamsOrder(val string) (ListPackTeamsParamsOrder, error) {
	if res, ok := stringToListPackTeamsParamsOrder[val]; ok {
		return res, nil
	}

	return ListPackTeamsParamsOrder(""), ErrListPackTeamsParamsOrder
}

// Defines values for ListPackUsersParamsSort.
const (
	ListPackUsersParamsSortActive   ListPackUsersParamsSort = "active"
	ListPackUsersParamsSortAdmin    ListPackUsersParamsSort = "admin"
	ListPackUsersParamsSortEmail    ListPackUsersParamsSort = "email"
	ListPackUsersParamsSortFullname ListPackUsersParamsSort = "fullname"
	ListPackUsersParamsSortUsername ListPackUsersParamsSort = "username"
)

var (
	// ErrListPackUsersParamsSort defines an error if an invalid value gets mapped.
	ErrListPackUsersParamsSort = fmt.Errorf("invalid type for ListPackUsersParamsSort")

	stringToListPackUsersParamsSort = map[string]ListPackUsersParamsSort{
		"active":   ListPackUsersParamsSortActive,
		"admin":    ListPackUsersParamsSortAdmin,
		"email":    ListPackUsersParamsSortEmail,
		"fullname": ListPackUsersParamsSortFullname,
		"username": ListPackUsersParamsSortUsername,
	}
)

// ToListPackUsersParamsSort acts as a helper to map a string to the defined enum.
func ToListPackUsersParamsSort(val string) (ListPackUsersParamsSort, error) {
	if res, ok := stringToListPackUsersParamsSort[val]; ok {
		return res, nil
	}

	return ListPackUsersParamsSort(""), ErrListPackUsersParamsSort
}

// Defines values for ListPackUsersParamsOrder.
const (
	ListPackUsersParamsOrderAsc  ListPackUsersParamsOrder = "asc"
	ListPackUsersParamsOrderDesc ListPackUsersParamsOrder = "desc"
)

var (
	// ErrListPackUsersParamsOrder defines an error if an invalid value gets mapped.
	ErrListPackUsersParamsOrder = fmt.Errorf("invalid type for ListPackUsersParamsOrder")

	stringToListPackUsersParamsOrder = map[string]ListPackUsersParamsOrder{
		"asc":  ListPackUsersParamsOrderAsc,
		"desc": ListPackUsersParamsOrderDesc,
	}
)

// ToListPackUsersParamsOrder acts as a helper to map a string to the defined enum.
func ToListPackUsersParamsOrder(val string) (ListPackUsersParamsOrder, error) {
	if res, ok := stringToListPackUsersParamsOrder[val]; ok {
		return res, nil
	}

	return ListPackUsersParamsOrder(""), ErrListPackUsersParamsOrder
}

// Defines values for ListQuiltBuildsParamsSort.
const (
	BuildName   ListQuiltBuildsParamsSort = "build_name"
	BuildPublic ListQuiltBuildsParamsSort = "build_public"
	PackName    ListQuiltBuildsParamsSort = "pack_name"
	PackSlug    ListQuiltBuildsParamsSort = "pack_slug"
)

var (
	// ErrListQuiltBuildsParamsSort defines an error if an invalid value gets mapped.
	ErrListQuiltBuildsParamsSort = fmt.Errorf("invalid type for ListQuiltBuildsParamsSort")

	stringToListQuiltBuildsParamsSort = map[string]ListQuiltBuildsParamsSort{
		"build_name":   BuildName,
		"build_public": BuildPublic,
		"pack_name":    PackName,
		"pack_slug":    PackSlug,
	}
)

// ToListQuiltBuildsParamsSort acts as a helper to map a string to the defined enum.
func ToListQuiltBuildsParamsSort(val string) (ListQuiltBuildsParamsSort, error) {
	if res, ok := stringToListQuiltBuildsParamsSort[val]; ok {
		return res, nil
	}

	return ListQuiltBuildsParamsSort(""), ErrListQuiltBuildsParamsSort
}

// Defines values for ListQuiltBuildsParamsOrder.
const (
	ListQuiltBuildsParamsOrderAsc  ListQuiltBuildsParamsOrder = "asc"
	ListQuiltBuildsParamsOrderDesc ListQuiltBuildsParamsOrder = "desc"
)

var (
	// ErrListQuiltBuildsParamsOrder defines an error if an invalid value gets mapped.
	ErrListQuiltBuildsParamsOrder = fmt.Errorf("invalid type for ListQuiltBuildsParamsOrder")

	stringToListQuiltBuildsParamsOrder = map[string]ListQuiltBuildsParamsOrder{
		"asc":  ListQuiltBuildsParamsOrderAsc,
		"desc": ListQuiltBuildsParamsOrderDesc,
	}
)

// ToListQuiltBuildsParamsOrder acts as a helper to map a string to the defined enum.
func ToListQuiltBuildsParamsOrder(val string) (ListQuiltBuildsParamsOrder, error) {
	if res, ok := stringToListQuiltBuildsParamsOrder[val]; ok {
		return res, nil
	}

	return ListQuiltBuildsParamsOrder(""), ErrListQuiltBuildsParamsOrder
}

// Defines values for ListTeamsParamsSort.
const (
	ListTeamsParamsSortName ListTeamsParamsSort = "name"
	ListTeamsParamsSortSlug ListTeamsParamsSort = "slug"
)

var (
	// ErrListTeamsParamsSort defines an error if an invalid value gets mapped.
	ErrListTeamsParamsSort = fmt.Errorf("invalid type for ListTeamsParamsSort")

	stringToListTeamsParamsSort = map[string]ListTeamsParamsSort{
		"name": ListTeamsParamsSortName,
		"slug": ListTeamsParamsSortSlug,
	}
)

// ToListTeamsParamsSort acts as a helper to map a string to the defined enum.
func ToListTeamsParamsSort(val string) (ListTeamsParamsSort, error) {
	if res, ok := stringToListTeamsParamsSort[val]; ok {
		return res, nil
	}

	return ListTeamsParamsSort(""), ErrListTeamsParamsSort
}

// Defines values for ListTeamsParamsOrder.
const (
	ListTeamsParamsOrderAsc  ListTeamsParamsOrder = "asc"
	ListTeamsParamsOrderDesc ListTeamsParamsOrder = "desc"
)

var (
	// ErrListTeamsParamsOrder defines an error if an invalid value gets mapped.
	ErrListTeamsParamsOrder = fmt.Errorf("invalid type for ListTeamsParamsOrder")

	stringToListTeamsParamsOrder = map[string]ListTeamsParamsOrder{
		"asc":  ListTeamsParamsOrderAsc,
		"desc": ListTeamsParamsOrderDesc,
	}
)

// ToListTeamsParamsOrder acts as a helper to map a string to the defined enum.
func ToListTeamsParamsOrder(val string) (ListTeamsParamsOrder, error) {
	if res, ok := stringToListTeamsParamsOrder[val]; ok {
		return res, nil
	}

	return ListTeamsParamsOrder(""), ErrListTeamsParamsOrder
}

// Defines values for ListTeamModsParamsSort.
const (
	ListTeamModsParamsSortName   ListTeamModsParamsSort = "name"
	ListTeamModsParamsSortPublic ListTeamModsParamsSort = "public"
	ListTeamModsParamsSortSlug   ListTeamModsParamsSort = "slug"
)

var (
	// ErrListTeamModsParamsSort defines an error if an invalid value gets mapped.
	ErrListTeamModsParamsSort = fmt.Errorf("invalid type for ListTeamModsParamsSort")

	stringToListTeamModsParamsSort = map[string]ListTeamModsParamsSort{
		"name":   ListTeamModsParamsSortName,
		"public": ListTeamModsParamsSortPublic,
		"slug":   ListTeamModsParamsSortSlug,
	}
)

// ToListTeamModsParamsSort acts as a helper to map a string to the defined enum.
func ToListTeamModsParamsSort(val string) (ListTeamModsParamsSort, error) {
	if res, ok := stringToListTeamModsParamsSort[val]; ok {
		return res, nil
	}

	return ListTeamModsParamsSort(""), ErrListTeamModsParamsSort
}

// Defines values for ListTeamModsParamsOrder.
const (
	ListTeamModsParamsOrderAsc  ListTeamModsParamsOrder = "asc"
	ListTeamModsParamsOrderDesc ListTeamModsParamsOrder = "desc"
)

var (
	// ErrListTeamModsParamsOrder defines an error if an invalid value gets mapped.
	ErrListTeamModsParamsOrder = fmt.Errorf("invalid type for ListTeamModsParamsOrder")

	stringToListTeamModsParamsOrder = map[string]ListTeamModsParamsOrder{
		"asc":  ListTeamModsParamsOrderAsc,
		"desc": ListTeamModsParamsOrderDesc,
	}
)

// ToListTeamModsParamsOrder acts as a helper to map a string to the defined enum.
func ToListTeamModsParamsOrder(val string) (ListTeamModsParamsOrder, error) {
	if res, ok := stringToListTeamModsParamsOrder[val]; ok {
		return res, nil
	}

	return ListTeamModsParamsOrder(""), ErrListTeamModsParamsOrder
}

// Defines values for ListTeamPacksParamsSort.
const (
	ListTeamPacksParamsSortName   ListTeamPacksParamsSort = "name"
	ListTeamPacksParamsSortPublic ListTeamPacksParamsSort = "public"
	ListTeamPacksParamsSortSlug   ListTeamPacksParamsSort = "slug"
)

var (
	// ErrListTeamPacksParamsSort defines an error if an invalid value gets mapped.
	ErrListTeamPacksParamsSort = fmt.Errorf("invalid type for ListTeamPacksParamsSort")

	stringToListTeamPacksParamsSort = map[string]ListTeamPacksParamsSort{
		"name":   ListTeamPacksParamsSortName,
		"public": ListTeamPacksParamsSortPublic,
		"slug":   ListTeamPacksParamsSortSlug,
	}
)

// ToListTeamPacksParamsSort acts as a helper to map a string to the defined enum.
func ToListTeamPacksParamsSort(val string) (ListTeamPacksParamsSort, error) {
	if res, ok := stringToListTeamPacksParamsSort[val]; ok {
		return res, nil
	}

	return ListTeamPacksParamsSort(""), ErrListTeamPacksParamsSort
}

// Defines values for ListTeamPacksParamsOrder.
const (
	ListTeamPacksParamsOrderAsc  ListTeamPacksParamsOrder = "asc"
	ListTeamPacksParamsOrderDesc ListTeamPacksParamsOrder = "desc"
)

var (
	// ErrListTeamPacksParamsOrder defines an error if an invalid value gets mapped.
	ErrListTeamPacksParamsOrder = fmt.Errorf("invalid type for ListTeamPacksParamsOrder")

	stringToListTeamPacksParamsOrder = map[string]ListTeamPacksParamsOrder{
		"asc":  ListTeamPacksParamsOrderAsc,
		"desc": ListTeamPacksParamsOrderDesc,
	}
)

// ToListTeamPacksParamsOrder acts as a helper to map a string to the defined enum.
func ToListTeamPacksParamsOrder(val string) (ListTeamPacksParamsOrder, error) {
	if res, ok := stringToListTeamPacksParamsOrder[val]; ok {
		return res, nil
	}

	return ListTeamPacksParamsOrder(""), ErrListTeamPacksParamsOrder
}

// Defines values for ListTeamUsersParamsSort.
const (
	ListTeamUsersParamsSortActive   ListTeamUsersParamsSort = "active"
	ListTeamUsersParamsSortAdmin    ListTeamUsersParamsSort = "admin"
	ListTeamUsersParamsSortEmail    ListTeamUsersParamsSort = "email"
	ListTeamUsersParamsSortFullname ListTeamUsersParamsSort = "fullname"
	ListTeamUsersParamsSortUsername ListTeamUsersParamsSort = "username"
)

var (
	// ErrListTeamUsersParamsSort defines an error if an invalid value gets mapped.
	ErrListTeamUsersParamsSort = fmt.Errorf("invalid type for ListTeamUsersParamsSort")

	stringToListTeamUsersParamsSort = map[string]ListTeamUsersParamsSort{
		"active":   ListTeamUsersParamsSortActive,
		"admin":    ListTeamUsersParamsSortAdmin,
		"email":    ListTeamUsersParamsSortEmail,
		"fullname": ListTeamUsersParamsSortFullname,
		"username": ListTeamUsersParamsSortUsername,
	}
)

// ToListTeamUsersParamsSort acts as a helper to map a string to the defined enum.
func ToListTeamUsersParamsSort(val string) (ListTeamUsersParamsSort, error) {
	if res, ok := stringToListTeamUsersParamsSort[val]; ok {
		return res, nil
	}

	return ListTeamUsersParamsSort(""), ErrListTeamUsersParamsSort
}

// Defines values for ListTeamUsersParamsOrder.
const (
	ListTeamUsersParamsOrderAsc  ListTeamUsersParamsOrder = "asc"
	ListTeamUsersParamsOrderDesc ListTeamUsersParamsOrder = "desc"
)

var (
	// ErrListTeamUsersParamsOrder defines an error if an invalid value gets mapped.
	ErrListTeamUsersParamsOrder = fmt.Errorf("invalid type for ListTeamUsersParamsOrder")

	stringToListTeamUsersParamsOrder = map[string]ListTeamUsersParamsOrder{
		"asc":  ListTeamUsersParamsOrderAsc,
		"desc": ListTeamUsersParamsOrderDesc,
	}
)

// ToListTeamUsersParamsOrder acts as a helper to map a string to the defined enum.
func ToListTeamUsersParamsOrder(val string) (ListTeamUsersParamsOrder, error) {
	if res, ok := stringToListTeamUsersParamsOrder[val]; ok {
		return res, nil
	}

	return ListTeamUsersParamsOrder(""), ErrListTeamUsersParamsOrder
}

// Defines values for ListUsersParamsSort.
const (
	Active   ListUsersParamsSort = "active"
	Admin    ListUsersParamsSort = "admin"
	Email    ListUsersParamsSort = "email"
	Fullname ListUsersParamsSort = "fullname"
	Username ListUsersParamsSort = "username"
)

var (
	// ErrListUsersParamsSort defines an error if an invalid value gets mapped.
	ErrListUsersParamsSort = fmt.Errorf("invalid type for ListUsersParamsSort")

	stringToListUsersParamsSort = map[string]ListUsersParamsSort{
		"active":   Active,
		"admin":    Admin,
		"email":    Email,
		"fullname": Fullname,
		"username": Username,
	}
)

// ToListUsersParamsSort acts as a helper to map a string to the defined enum.
func ToListUsersParamsSort(val string) (ListUsersParamsSort, error) {
	if res, ok := stringToListUsersParamsSort[val]; ok {
		return res, nil
	}

	return ListUsersParamsSort(""), ErrListUsersParamsSort
}

// Defines values for ListUsersParamsOrder.
const (
	ListUsersParamsOrderAsc  ListUsersParamsOrder = "asc"
	ListUsersParamsOrderDesc ListUsersParamsOrder = "desc"
)

var (
	// ErrListUsersParamsOrder defines an error if an invalid value gets mapped.
	ErrListUsersParamsOrder = fmt.Errorf("invalid type for ListUsersParamsOrder")

	stringToListUsersParamsOrder = map[string]ListUsersParamsOrder{
		"asc":  ListUsersParamsOrderAsc,
		"desc": ListUsersParamsOrderDesc,
	}
)

// ToListUsersParamsOrder acts as a helper to map a string to the defined enum.
func ToListUsersParamsOrder(val string) (ListUsersParamsOrder, error) {
	if res, ok := stringToListUsersParamsOrder[val]; ok {
		return res, nil
	}

	return ListUsersParamsOrder(""), ErrListUsersParamsOrder
}

// Defines values for ListUserModsParamsSort.
const (
	ListUserModsParamsSortName   ListUserModsParamsSort = "name"
	ListUserModsParamsSortPublic ListUserModsParamsSort = "public"
	ListUserModsParamsSortSlug   ListUserModsParamsSort = "slug"
)

var (
	// ErrListUserModsParamsSort defines an error if an invalid value gets mapped.
	ErrListUserModsParamsSort = fmt.Errorf("invalid type for ListUserModsParamsSort")

	stringToListUserModsParamsSort = map[string]ListUserModsParamsSort{
		"name":   ListUserModsParamsSortName,
		"public": ListUserModsParamsSortPublic,
		"slug":   ListUserModsParamsSortSlug,
	}
)

// ToListUserModsParamsSort acts as a helper to map a string to the defined enum.
func ToListUserModsParamsSort(val string) (ListUserModsParamsSort, error) {
	if res, ok := stringToListUserModsParamsSort[val]; ok {
		return res, nil
	}

	return ListUserModsParamsSort(""), ErrListUserModsParamsSort
}

// Defines values for ListUserModsParamsOrder.
const (
	ListUserModsParamsOrderAsc  ListUserModsParamsOrder = "asc"
	ListUserModsParamsOrderDesc ListUserModsParamsOrder = "desc"
)

var (
	// ErrListUserModsParamsOrder defines an error if an invalid value gets mapped.
	ErrListUserModsParamsOrder = fmt.Errorf("invalid type for ListUserModsParamsOrder")

	stringToListUserModsParamsOrder = map[string]ListUserModsParamsOrder{
		"asc":  ListUserModsParamsOrderAsc,
		"desc": ListUserModsParamsOrderDesc,
	}
)

// ToListUserModsParamsOrder acts as a helper to map a string to the defined enum.
func ToListUserModsParamsOrder(val string) (ListUserModsParamsOrder, error) {
	if res, ok := stringToListUserModsParamsOrder[val]; ok {
		return res, nil
	}

	return ListUserModsParamsOrder(""), ErrListUserModsParamsOrder
}

// Defines values for ListUserPacksParamsSort.
const (
	ListUserPacksParamsSortName   ListUserPacksParamsSort = "name"
	ListUserPacksParamsSortPublic ListUserPacksParamsSort = "public"
	ListUserPacksParamsSortSlug   ListUserPacksParamsSort = "slug"
)

var (
	// ErrListUserPacksParamsSort defines an error if an invalid value gets mapped.
	ErrListUserPacksParamsSort = fmt.Errorf("invalid type for ListUserPacksParamsSort")

	stringToListUserPacksParamsSort = map[string]ListUserPacksParamsSort{
		"name":   ListUserPacksParamsSortName,
		"public": ListUserPacksParamsSortPublic,
		"slug":   ListUserPacksParamsSortSlug,
	}
)

// ToListUserPacksParamsSort acts as a helper to map a string to the defined enum.
func ToListUserPacksParamsSort(val string) (ListUserPacksParamsSort, error) {
	if res, ok := stringToListUserPacksParamsSort[val]; ok {
		return res, nil
	}

	return ListUserPacksParamsSort(""), ErrListUserPacksParamsSort
}

// Defines values for ListUserPacksParamsOrder.
const (
	ListUserPacksParamsOrderAsc  ListUserPacksParamsOrder = "asc"
	ListUserPacksParamsOrderDesc ListUserPacksParamsOrder = "desc"
)

var (
	// ErrListUserPacksParamsOrder defines an error if an invalid value gets mapped.
	ErrListUserPacksParamsOrder = fmt.Errorf("invalid type for ListUserPacksParamsOrder")

	stringToListUserPacksParamsOrder = map[string]ListUserPacksParamsOrder{
		"asc":  ListUserPacksParamsOrderAsc,
		"desc": ListUserPacksParamsOrderDesc,
	}
)

// ToListUserPacksParamsOrder acts as a helper to map a string to the defined enum.
func ToListUserPacksParamsOrder(val string) (ListUserPacksParamsOrder, error) {
	if res, ok := stringToListUserPacksParamsOrder[val]; ok {
		return res, nil
	}

	return ListUserPacksParamsOrder(""), ErrListUserPacksParamsOrder
}

// Defines values for ListUserTeamsParamsSort.
const (
	ListUserTeamsParamsSortName ListUserTeamsParamsSort = "name"
	ListUserTeamsParamsSortSlug ListUserTeamsParamsSort = "slug"
)

var (
	// ErrListUserTeamsParamsSort defines an error if an invalid value gets mapped.
	ErrListUserTeamsParamsSort = fmt.Errorf("invalid type for ListUserTeamsParamsSort")

	stringToListUserTeamsParamsSort = map[string]ListUserTeamsParamsSort{
		"name": ListUserTeamsParamsSortName,
		"slug": ListUserTeamsParamsSortSlug,
	}
)

// ToListUserTeamsParamsSort acts as a helper to map a string to the defined enum.
func ToListUserTeamsParamsSort(val string) (ListUserTeamsParamsSort, error) {
	if res, ok := stringToListUserTeamsParamsSort[val]; ok {
		return res, nil
	}

	return ListUserTeamsParamsSort(""), ErrListUserTeamsParamsSort
}

// Defines values for ListUserTeamsParamsOrder.
const (
	Asc  ListUserTeamsParamsOrder = "asc"
	Desc ListUserTeamsParamsOrder = "desc"
)

var (
	// ErrListUserTeamsParamsOrder defines an error if an invalid value gets mapped.
	ErrListUserTeamsParamsOrder = fmt.Errorf("invalid type for ListUserTeamsParamsOrder")

	stringToListUserTeamsParamsOrder = map[string]ListUserTeamsParamsOrder{
		"asc":  Asc,
		"desc": Desc,
	}
)

// ToListUserTeamsParamsOrder acts as a helper to map a string to the defined enum.
func ToListUserTeamsParamsOrder(val string) (ListUserTeamsParamsOrder, error) {
	if res, ok := stringToListUserTeamsParamsOrder[val]; ok {
		return res, nil
	}

	return ListUserTeamsParamsOrder(""), ErrListUserTeamsParamsOrder
}

// AuthLogin defines model for auth_login.
type AuthLogin struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// AuthToken defines model for auth_token.
type AuthToken struct {
	ExpiresAt *time.Time `json:"expires_at,omitempty"`
	Token     *string    `json:"token,omitempty"`
}

// AuthVerify defines model for auth_verify.
type AuthVerify struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Username  *string    `json:"username,omitempty"`
}

// Build Model to represent build
type Build struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Fabric Model to represent fabric
	Fabric   *Fabric `json:"fabric,omitempty"`
	FabricId *string `json:"fabric_id,omitempty"`

	// Forge Model to represent forge
	Forge   *Forge  `json:"forge,omitempty"`
	ForgeId *string `json:"forge_id,omitempty"`
	Id      *string `json:"id,omitempty"`
	Java    *string `json:"java,omitempty"`
	Latest  *bool   `json:"latest,omitempty"`
	Memory  *string `json:"memory,omitempty"`

	// Minecraft Model to represent minecraft
	Minecraft   *Minecraft `json:"minecraft,omitempty"`
	MinecraftId *string    `json:"minecraft_id,omitempty"`
	Name        *string    `json:"name,omitempty"`

	// Neoforge Model to represent neoforge
	Neoforge   *Neoforge `json:"neoforge,omitempty"`
	NeoforgeId *string   `json:"neoforge_id,omitempty"`

	// Pack Model to represent pack
	Pack   *Pack `json:"pack,omitempty"`
	Public *bool `json:"public,omitempty"`

	// Quilt Model to represent quilt
	Quilt       *Quilt     `json:"quilt,omitempty"`
	QuiltId     *string    `json:"quilt_id,omitempty"`
	Recommended *bool      `json:"recommended,omitempty"`
	Slug        *string    `json:"slug,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
}

// BuildVersion Model to represent build version
type BuildVersion struct {
	// Build Model to represent build
	Build     *Build     `json:"build,omitempty"`
	BuildId   string     `json:"build_id"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Version Model to represent version
	Version   *Version `json:"version,omitempty"`
	VersionId string   `json:"version_id"`
}

// BuildVersionParams Parameters to attach or unlink build version
type BuildVersionParams struct {
	Mod     string `json:"mod"`
	Version string `json:"version"`
}

// BuildVersions Model to represent build versions
type BuildVersions struct {
	// Build Model to represent build
	Build *Build `json:"build,omitempty"`

	// Pack Model to represent pack
	Pack     *Pack           `json:"pack,omitempty"`
	Total    *int64          `json:"total,omitempty"`
	Versions *[]BuildVersion `json:"versions,omitempty"`
}

// Builds Model to represent list of builds
type Builds struct {
	Builds *[]Build `json:"builds,omitempty"`

	// Pack Model to represent pack
	Pack  *Pack  `json:"pack,omitempty"`
	Total *int64 `json:"total,omitempty"`
}

// Fabric Model to represent fabric
type Fabric struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Id        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// FabricBuildParams Model to represent params for fabric builds
type FabricBuildParams struct {
	Build string `json:"build"`
	Pack  string `json:"pack"`
}

// FabricBuilds Model to represent fabric builds
type FabricBuilds struct {
	Builds *[]Build `json:"builds,omitempty"`

	// Fabric Model to represent fabric
	Fabric *Fabric `json:"fabric,omitempty"`
	Total  *int64  `json:"total,omitempty"`
}

// Fabrics Model to represent list of fabrics
type Fabrics struct {
	Total    *int64    `json:"total,omitempty"`
	Versions *[]Fabric `json:"versions,omitempty"`
}

// Forge Model to represent forge
type Forge struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Id        *string    `json:"id,omitempty"`
	Minecraft *string    `json:"minecraft,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// ForgeBuildParams Model to represent params for forge builds
type ForgeBuildParams struct {
	Build string `json:"build"`
	Pack  string `json:"pack"`
}

// ForgeBuilds Model to represent forge builds
type ForgeBuilds struct {
	Builds *[]Build `json:"builds,omitempty"`

	// Forge Model to represent forge
	Forge *Forge `json:"forge,omitempty"`
	Total *int64 `json:"total,omitempty"`
}

// Forges Model to represent list of forges
type Forges struct {
	Total    *int64   `json:"total,omitempty"`
	Versions *[]Forge `json:"versions,omitempty"`
}

// Minecraft Model to represent minecraft
type Minecraft struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Id        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Type      *string    `json:"type,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// MinecraftBuildParams Model to represent params for minecraft builds
type MinecraftBuildParams struct {
	Build string `json:"build"`
	Pack  string `json:"pack"`
}

// MinecraftBuilds Model to represent minecraft builds
type MinecraftBuilds struct {
	Builds *[]Build `json:"builds,omitempty"`

	// Minecraft Model to represent minecraft
	Minecraft *Minecraft `json:"minecraft,omitempty"`
	Total     *int64     `json:"total,omitempty"`
}

// Minecrafts Model to represent list of minecrafts
type Minecrafts struct {
	Total    *int64       `json:"total,omitempty"`
	Versions *[]Minecraft `json:"versions,omitempty"`
}

// Mod Model to represent mod
type Mod struct {
	Author      *string    `json:"author,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	Description *string    `json:"description,omitempty"`
	Donate      *string    `json:"donate,omitempty"`
	Id          *string    `json:"id,omitempty"`
	Name        *string    `json:"name,omitempty"`
	Public      *bool      `json:"public,omitempty"`
	Side        *string    `json:"side,omitempty"`
	Slug        *string    `json:"slug,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
	Website     *string    `json:"website,omitempty"`
}

// ModTeamParams Parameters to attach or unlink mod team
type ModTeamParams struct {
	Perm *ModTeamParamsPerm `json:"perm,omitempty"`
	Team string             `json:"team"`
}

// ModTeamParamsPerm defines model for ModTeamParams.Perm.
type ModTeamParamsPerm string

// ModTeams Model to represent mod teams
type ModTeams struct {
	// Mod Model to represent mod
	Mod   *Mod       `json:"mod,omitempty"`
	Teams *[]TeamMod `json:"teams,omitempty"`
	Total *int64     `json:"total,omitempty"`
}

// ModUserParams Parameters to attach or unlink mod user
type ModUserParams struct {
	Perm *ModUserParamsPerm `json:"perm,omitempty"`
	User string             `json:"user"`
}

// ModUserParamsPerm defines model for ModUserParams.Perm.
type ModUserParamsPerm string

// ModUsers Model to represent mod users
type ModUsers struct {
	// Mod Model to represent mod
	Mod   *Mod       `json:"mod,omitempty"`
	Total *int64     `json:"total,omitempty"`
	Users *[]UserMod `json:"users,omitempty"`
}

// Mods Model to represent list of mods
type Mods struct {
	Mods  *[]Mod `json:"mods,omitempty"`
	Total *int64 `json:"total,omitempty"`
}

// Neoforge Model to represent neoforge
type Neoforge struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Id        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// NeoforgeBuildParams Model to represent params for neoforge builds
type NeoforgeBuildParams struct {
	Build string `json:"build"`
	Pack  string `json:"pack"`
}

// NeoforgeBuilds Model to represent neoforge builds
type NeoforgeBuilds struct {
	Builds *[]Build `json:"builds,omitempty"`

	// Neoforge Model to represent neoforge
	Neoforge *Neoforge `json:"neoforge,omitempty"`
	Total    *int64    `json:"total,omitempty"`
}

// Neoforges Model to represent list of neoforges
type Neoforges struct {
	Total    *int64      `json:"total,omitempty"`
	Versions *[]Neoforge `json:"versions,omitempty"`
}

// Notification Generic response for errors and validations
type Notification struct {
	Errors  *[]Validation `json:"errors,omitempty"`
	Message *string       `json:"message,omitempty"`
	Status  *int          `json:"status,omitempty"`
}

// Pack Model to represent pack
type Pack struct {
	// Back Model to represent pack background
	Back      *PackBack  `json:"back,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Icon Model to represent pack icon
	Icon *PackIcon `json:"icon,omitempty"`
	Id   *string   `json:"id,omitempty"`

	// Logo Model to represent pack logo
	Logo      *PackLogo  `json:"logo,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Public    *bool      `json:"public,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	Website   *string    `json:"website,omitempty"`
}

// PackBack Model to represent pack background
type PackBack struct {
	ContentType *string    `json:"content_type,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	Id          *string    `json:"id,omitempty"`
	Md5         *string    `json:"md5,omitempty"`
	Path        *string    `json:"path,omitempty"`
	Slug        *string    `json:"slug,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
	Upload      *string    `json:"upload,omitempty"`
	Url         *string    `json:"url,omitempty"`
}

// PackIcon Model to represent pack icon
type PackIcon struct {
	ContentType *string    `json:"content_type,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	Id          *string    `json:"id,omitempty"`
	Md5         *string    `json:"md5,omitempty"`
	Path        *string    `json:"path,omitempty"`
	Slug        *string    `json:"slug,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
	Upload      *string    `json:"upload,omitempty"`
	Url         *string    `json:"url,omitempty"`
}

// PackLogo Model to represent pack logo
type PackLogo struct {
	ContentType *string    `json:"content_type,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	Id          *string    `json:"id,omitempty"`
	Md5         *string    `json:"md5,omitempty"`
	Path        *string    `json:"path,omitempty"`
	Slug        *string    `json:"slug,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
	Upload      *string    `json:"upload,omitempty"`
	Url         *string    `json:"url,omitempty"`
}

// PackTeamParams Parameters to attach or unlink pack team
type PackTeamParams struct {
	Perm *PackTeamParamsPerm `json:"perm,omitempty"`
	Team string              `json:"team"`
}

// PackTeamParamsPerm defines model for PackTeamParams.Perm.
type PackTeamParamsPerm string

// PackTeams Model to represent pack teams
type PackTeams struct {
	// Pack Model to represent pack
	Pack  *Pack       `json:"pack,omitempty"`
	Teams *[]TeamPack `json:"teams,omitempty"`
	Total *int64      `json:"total,omitempty"`
}

// PackUserParams Parameters to attach or unlink pack user
type PackUserParams struct {
	Perm *PackUserParamsPerm `json:"perm,omitempty"`
	User string              `json:"user"`
}

// PackUserParamsPerm defines model for PackUserParams.Perm.
type PackUserParamsPerm string

// PackUsers Model to represent pack users
type PackUsers struct {
	// Pack Model to represent pack
	Pack  *Pack       `json:"pack,omitempty"`
	Total *int64      `json:"total,omitempty"`
	Users *[]UserPack `json:"users,omitempty"`
}

// Packs Model to represent list of packs
type Packs struct {
	Packs *[]Pack `json:"packs,omitempty"`
	Total *int64  `json:"total,omitempty"`
}

// Profile Model to represent profile
type Profile struct {
	Active    *bool       `json:"active,omitempty"`
	Admin     *bool       `json:"admin,omitempty"`
	Auths     *[]UserAuth `json:"auths,omitempty"`
	CreatedAt *time.Time  `json:"created_at,omitempty"`
	Email     *string     `json:"email,omitempty"`
	Fullname  *string     `json:"fullname,omitempty"`
	Id        *string     `json:"id,omitempty"`
	Mods      *[]UserMod  `json:"mods,omitempty"`
	Packs     *[]UserPack `json:"packs,omitempty"`
	Password  *string     `json:"password,omitempty"`
	Profile   *string     `json:"profile,omitempty"`
	Teams     *[]UserTeam `json:"teams,omitempty"`
	UpdatedAt *time.Time  `json:"updated_at,omitempty"`
	Username  *string     `json:"username,omitempty"`
}

// Provider Model to represent auth provider
type Provider struct {
	Display *string `json:"display,omitempty"`
	Driver  *string `json:"driver,omitempty"`
	Icon    *string `json:"icon,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// Providers Model to represent list of auth providers
type Providers struct {
	Listing *[]Provider `json:"listing,omitempty"`
	Total   *int64      `json:"total,omitempty"`
}

// Quilt Model to represent quilt
type Quilt struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Id        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// QuiltBuildParams Model to represent params for quilt builds
type QuiltBuildParams struct {
	Build string `json:"build"`
	Pack  string `json:"pack"`
}

// QuiltBuilds Model to represent quilt builds
type QuiltBuilds struct {
	Builds *[]Build `json:"builds,omitempty"`

	// Quilt Model to represent quilt
	Quilt *Quilt `json:"quilt,omitempty"`
	Total *int64 `json:"total,omitempty"`
}

// Quilts Model to represent list of quilts
type Quilts struct {
	Total    *int64   `json:"total,omitempty"`
	Versions *[]Quilt `json:"versions,omitempty"`
}

// Team Model to represent team
type Team struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Id        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// TeamMod Model to represent team mod
type TeamMod struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Mod Model to represent mod
	Mod   *Mod         `json:"mod,omitempty"`
	ModId string       `json:"mod_id"`
	Perm  *TeamModPerm `json:"perm,omitempty"`

	// Team Model to represent team
	Team      *Team      `json:"team,omitempty"`
	TeamId    string     `json:"team_id"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// TeamModPerm defines model for TeamMod.Perm.
type TeamModPerm string

// TeamModParams Parameters to attach or unlink team mod
type TeamModParams struct {
	Mod  string             `json:"mod"`
	Perm *TeamModParamsPerm `json:"perm,omitempty"`
}

// TeamModParamsPerm defines model for TeamModParams.Perm.
type TeamModParamsPerm string

// TeamMods Model to represent team mods
type TeamMods struct {
	Mods *[]TeamMod `json:"mods,omitempty"`

	// Team Model to represent team
	Team  *Team  `json:"team,omitempty"`
	Total *int64 `json:"total,omitempty"`
}

// TeamPack Model to represent team pack
type TeamPack struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Pack Model to represent pack
	Pack   *Pack         `json:"pack,omitempty"`
	PackId string        `json:"pack_id"`
	Perm   *TeamPackPerm `json:"perm,omitempty"`

	// Team Model to represent team
	Team      *Team      `json:"team,omitempty"`
	TeamId    string     `json:"team_id"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// TeamPackPerm defines model for TeamPack.Perm.
type TeamPackPerm string

// TeamPackParams Parameters to attach or unlink team pack
type TeamPackParams struct {
	Pack string              `json:"pack"`
	Perm *TeamPackParamsPerm `json:"perm,omitempty"`
}

// TeamPackParamsPerm defines model for TeamPackParams.Perm.
type TeamPackParamsPerm string

// TeamPacks Model to represent team packs
type TeamPacks struct {
	Packs *[]TeamPack `json:"packs,omitempty"`

	// Team Model to represent team
	Team  *Team  `json:"team,omitempty"`
	Total *int64 `json:"total,omitempty"`
}

// TeamUserParams Parameters to attach or unlink team user
type TeamUserParams struct {
	Perm *TeamUserParamsPerm `json:"perm,omitempty"`
	User string              `json:"user"`
}

// TeamUserParamsPerm defines model for TeamUserParams.Perm.
type TeamUserParamsPerm string

// TeamUsers Model to represent team users
type TeamUsers struct {
	// Team Model to represent team
	Team  *Team       `json:"team,omitempty"`
	Total *int64      `json:"total,omitempty"`
	Users *[]UserTeam `json:"users,omitempty"`
}

// Teams Model to represent list of teams
type Teams struct {
	Teams *[]Team `json:"teams,omitempty"`
	Total *int64  `json:"total,omitempty"`
}

// User Model to represent user
type User struct {
	Active    *bool       `json:"active,omitempty"`
	Admin     *bool       `json:"admin,omitempty"`
	Auths     *[]UserAuth `json:"auths,omitempty"`
	CreatedAt *time.Time  `json:"created_at,omitempty"`
	Email     *string     `json:"email,omitempty"`
	Fullname  *string     `json:"fullname,omitempty"`
	Id        *string     `json:"id,omitempty"`
	Password  *string     `json:"password,omitempty"`
	Profile   *string     `json:"profile,omitempty"`
	UpdatedAt *time.Time  `json:"updated_at,omitempty"`
	Username  *string     `json:"username,omitempty"`
}

// UserAuth Model to represent user auth
type UserAuth struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Provider  *string    `json:"provider,omitempty"`
	Ref       *string    `json:"ref,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// UserMod Model to represent user mod
type UserMod struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Mod Model to represent mod
	Mod       *Mod         `json:"mod,omitempty"`
	ModId     string       `json:"mod_id"`
	Perm      *UserModPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time   `json:"updated_at,omitempty"`

	// User Model to represent user
	User   *User  `json:"user,omitempty"`
	UserId string `json:"user_id"`
}

// UserModPerm defines model for UserMod.Perm.
type UserModPerm string

// UserModParams Parameters to attach or unlink user mod
type UserModParams struct {
	Mod  string             `json:"mod"`
	Perm *UserModParamsPerm `json:"perm,omitempty"`
}

// UserModParamsPerm defines model for UserModParams.Perm.
type UserModParamsPerm string

// UserMods Model to represent user mods
type UserMods struct {
	Mods  *[]UserMod `json:"mods,omitempty"`
	Total *int64     `json:"total,omitempty"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

// UserPack Model to represent user pack
type UserPack struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Pack Model to represent pack
	Pack      *Pack         `json:"pack,omitempty"`
	PackId    string        `json:"pack_id"`
	Perm      *UserPackPerm `json:"perm,omitempty"`
	UpdatedAt *time.Time    `json:"updated_at,omitempty"`

	// User Model to represent user
	User   *User  `json:"user,omitempty"`
	UserId string `json:"user_id"`
}

// UserPackPerm defines model for UserPack.Perm.
type UserPackPerm string

// UserPackParams Parameters to attach or unlink user pack
type UserPackParams struct {
	Pack string              `json:"pack"`
	Perm *UserPackParamsPerm `json:"perm,omitempty"`
}

// UserPackParamsPerm defines model for UserPackParams.Perm.
type UserPackParamsPerm string

// UserPacks Model to represent user packs
type UserPacks struct {
	Packs *[]UserPack `json:"packs,omitempty"`
	Total *int64      `json:"total,omitempty"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

// UserTeam Model to represent user team
type UserTeam struct {
	CreatedAt *time.Time    `json:"created_at,omitempty"`
	Perm      *UserTeamPerm `json:"perm,omitempty"`

	// Team Model to represent team
	Team      *Team      `json:"team,omitempty"`
	TeamId    string     `json:"team_id"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// User Model to represent user
	User   *User  `json:"user,omitempty"`
	UserId string `json:"user_id"`
}

// UserTeamPerm defines model for UserTeam.Perm.
type UserTeamPerm string

// UserTeamParams Parameters to attach or unlink user team
type UserTeamParams struct {
	Perm *UserTeamParamsPerm `json:"perm,omitempty"`
	Team string              `json:"team"`
}

// UserTeamParamsPerm defines model for UserTeamParams.Perm.
type UserTeamParamsPerm string

// UserTeams Model to represent user teams
type UserTeams struct {
	Teams *[]UserTeam `json:"teams,omitempty"`
	Total *int64      `json:"total,omitempty"`

	// User Model to represent user
	User *User `json:"user,omitempty"`
}

// Users Model to represent list of users
type Users struct {
	Total *int64  `json:"total,omitempty"`
	Users *[]User `json:"users,omitempty"`
}

// Validation General structure to show validation errors
type Validation struct {
	Field   *string `json:"field,omitempty"`
	Message *string `json:"message,omitempty"`
}

// Version Model to represent version
type Version struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// File Model to represent version file
	File *VersionFile `json:"file,omitempty"`
	Id   *string      `json:"id,omitempty"`

	// Mod Model to represent mod
	Mod       *Mod       `json:"mod,omitempty"`
	Name      *string    `json:"name,omitempty"`
	Public    *bool      `json:"public,omitempty"`
	Slug      *string    `json:"slug,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// VersionBuildParams Parameters to attach or unlink version build
type VersionBuildParams struct {
	Build string `json:"build"`
	Pack  string `json:"pack"`
}

// VersionBuilds Model to represent version builds
type VersionBuilds struct {
	Builds *[]BuildVersion `json:"builds,omitempty"`

	// Mod Model to represent mod
	Mod   *Mod   `json:"mod,omitempty"`
	Total *int64 `json:"total,omitempty"`

	// Version Model to represent version
	Version *Version `json:"version,omitempty"`
}

// VersionFile Model to represent version file
type VersionFile struct {
	ContentType *string    `json:"content_type,omitempty"`
	CreatedAt   *time.Time `json:"created_at,omitempty"`
	Id          *string    `json:"id,omitempty"`
	Md5         *string    `json:"md5,omitempty"`
	Path        *string    `json:"path,omitempty"`
	Slug        *string    `json:"slug,omitempty"`
	UpdatedAt   *time.Time `json:"updated_at,omitempty"`
	Upload      *string    `json:"upload,omitempty"`
	Url         *string    `json:"url,omitempty"`
}

// Versions Model to represent list of versions
type Versions struct {
	// Mod Model to represent mod
	Mod      *Mod       `json:"mod,omitempty"`
	Total    *int64     `json:"total,omitempty"`
	Versions *[]Version `json:"versions,omitempty"`
}

// ExternalCallbackParams defines parameters for ExternalCallback.
type ExternalCallbackParams struct {
	// State Auth state
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// Code Auth code
	Code *string `form:"code,omitempty" json:"code,omitempty"`
}

// ExternalInitializeParams defines parameters for ExternalInitialize.
type ExternalInitializeParams struct {
	// State Auth state
	State *string `form:"state,omitempty" json:"state,omitempty"`
}

// ListFabricsParams defines parameters for ListFabrics.
type ListFabricsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// ListFabricBuildsParams defines parameters for ListFabricBuilds.
type ListFabricBuildsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListFabricBuildsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListFabricBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListFabricBuildsParamsSort defines parameters for ListFabricBuilds.
type ListFabricBuildsParamsSort string

// ListFabricBuildsParamsOrder defines parameters for ListFabricBuilds.
type ListFabricBuildsParamsOrder string

// ListForgesParams defines parameters for ListForges.
type ListForgesParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// ListForgeBuildsParams defines parameters for ListForgeBuilds.
type ListForgeBuildsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListForgeBuildsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListForgeBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListForgeBuildsParamsSort defines parameters for ListForgeBuilds.
type ListForgeBuildsParamsSort string

// ListForgeBuildsParamsOrder defines parameters for ListForgeBuilds.
type ListForgeBuildsParamsOrder string

// ListMinecraftsParams defines parameters for ListMinecrafts.
type ListMinecraftsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// ListMinecraftBuildsParams defines parameters for ListMinecraftBuilds.
type ListMinecraftBuildsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListMinecraftBuildsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListMinecraftBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListMinecraftBuildsParamsSort defines parameters for ListMinecraftBuilds.
type ListMinecraftBuildsParamsSort string

// ListMinecraftBuildsParamsOrder defines parameters for ListMinecraftBuilds.
type ListMinecraftBuildsParamsOrder string

// ListModsParams defines parameters for ListMods.
type ListModsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListModsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListModsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListModsParamsSort defines parameters for ListMods.
type ListModsParamsSort string

// ListModsParamsOrder defines parameters for ListMods.
type ListModsParamsOrder string

// ListModTeamsParams defines parameters for ListModTeams.
type ListModTeamsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListModTeamsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListModTeamsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListModTeamsParamsSort defines parameters for ListModTeams.
type ListModTeamsParamsSort string

// ListModTeamsParamsOrder defines parameters for ListModTeams.
type ListModTeamsParamsOrder string

// ListModUsersParams defines parameters for ListModUsers.
type ListModUsersParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListModUsersParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListModUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListModUsersParamsSort defines parameters for ListModUsers.
type ListModUsersParamsSort string

// ListModUsersParamsOrder defines parameters for ListModUsers.
type ListModUsersParamsOrder string

// ListVersionsParams defines parameters for ListVersions.
type ListVersionsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListVersionsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListVersionsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListVersionsParamsSort defines parameters for ListVersions.
type ListVersionsParamsSort string

// ListVersionsParamsOrder defines parameters for ListVersions.
type ListVersionsParamsOrder string

// ListVersionBuildsParams defines parameters for ListVersionBuilds.
type ListVersionBuildsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListVersionBuildsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListVersionBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListVersionBuildsParamsSort defines parameters for ListVersionBuilds.
type ListVersionBuildsParamsSort string

// ListVersionBuildsParamsOrder defines parameters for ListVersionBuilds.
type ListVersionBuildsParamsOrder string

// ListNeoforgesParams defines parameters for ListNeoforges.
type ListNeoforgesParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// ListNeoforgeBuildsParams defines parameters for ListNeoforgeBuilds.
type ListNeoforgeBuildsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListNeoforgeBuildsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListNeoforgeBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListNeoforgeBuildsParamsSort defines parameters for ListNeoforgeBuilds.
type ListNeoforgeBuildsParamsSort string

// ListNeoforgeBuildsParamsOrder defines parameters for ListNeoforgeBuilds.
type ListNeoforgeBuildsParamsOrder string

// ListPacksParams defines parameters for ListPacks.
type ListPacksParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListPacksParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListPacksParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListPacksParamsSort defines parameters for ListPacks.
type ListPacksParamsSort string

// ListPacksParamsOrder defines parameters for ListPacks.
type ListPacksParamsOrder string

// ListBuildsParams defines parameters for ListBuilds.
type ListBuildsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListBuildsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListBuildsParamsSort defines parameters for ListBuilds.
type ListBuildsParamsSort string

// ListBuildsParamsOrder defines parameters for ListBuilds.
type ListBuildsParamsOrder string

// ListBuildVersionsParams defines parameters for ListBuildVersions.
type ListBuildVersionsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListBuildVersionsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListBuildVersionsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListBuildVersionsParamsSort defines parameters for ListBuildVersions.
type ListBuildVersionsParamsSort string

// ListBuildVersionsParamsOrder defines parameters for ListBuildVersions.
type ListBuildVersionsParamsOrder string

// ListPackTeamsParams defines parameters for ListPackTeams.
type ListPackTeamsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListPackTeamsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListPackTeamsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListPackTeamsParamsSort defines parameters for ListPackTeams.
type ListPackTeamsParamsSort string

// ListPackTeamsParamsOrder defines parameters for ListPackTeams.
type ListPackTeamsParamsOrder string

// ListPackUsersParams defines parameters for ListPackUsers.
type ListPackUsersParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListPackUsersParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListPackUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListPackUsersParamsSort defines parameters for ListPackUsers.
type ListPackUsersParamsSort string

// ListPackUsersParamsOrder defines parameters for ListPackUsers.
type ListPackUsersParamsOrder string

// ListQuiltsParams defines parameters for ListQuilts.
type ListQuiltsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`
}

// ListQuiltBuildsParams defines parameters for ListQuiltBuilds.
type ListQuiltBuildsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListQuiltBuildsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListQuiltBuildsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListQuiltBuildsParamsSort defines parameters for ListQuiltBuilds.
type ListQuiltBuildsParamsSort string

// ListQuiltBuildsParamsOrder defines parameters for ListQuiltBuilds.
type ListQuiltBuildsParamsOrder string

// ListTeamsParams defines parameters for ListTeams.
type ListTeamsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListTeamsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListTeamsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListTeamsParamsSort defines parameters for ListTeams.
type ListTeamsParamsSort string

// ListTeamsParamsOrder defines parameters for ListTeams.
type ListTeamsParamsOrder string

// ListTeamModsParams defines parameters for ListTeamMods.
type ListTeamModsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListTeamModsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListTeamModsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListTeamModsParamsSort defines parameters for ListTeamMods.
type ListTeamModsParamsSort string

// ListTeamModsParamsOrder defines parameters for ListTeamMods.
type ListTeamModsParamsOrder string

// ListTeamPacksParams defines parameters for ListTeamPacks.
type ListTeamPacksParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListTeamPacksParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListTeamPacksParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListTeamPacksParamsSort defines parameters for ListTeamPacks.
type ListTeamPacksParamsSort string

// ListTeamPacksParamsOrder defines parameters for ListTeamPacks.
type ListTeamPacksParamsOrder string

// ListTeamUsersParams defines parameters for ListTeamUsers.
type ListTeamUsersParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListTeamUsersParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListTeamUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListTeamUsersParamsSort defines parameters for ListTeamUsers.
type ListTeamUsersParamsSort string

// ListTeamUsersParamsOrder defines parameters for ListTeamUsers.
type ListTeamUsersParamsOrder string

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListUsersParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUsersParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUsersParamsSort defines parameters for ListUsers.
type ListUsersParamsSort string

// ListUsersParamsOrder defines parameters for ListUsers.
type ListUsersParamsOrder string

// ListUserModsParams defines parameters for ListUserMods.
type ListUserModsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListUserModsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUserModsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUserModsParamsSort defines parameters for ListUserMods.
type ListUserModsParamsSort string

// ListUserModsParamsOrder defines parameters for ListUserMods.
type ListUserModsParamsOrder string

// ListUserPacksParams defines parameters for ListUserPacks.
type ListUserPacksParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListUserPacksParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUserPacksParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUserPacksParamsSort defines parameters for ListUserPacks.
type ListUserPacksParamsSort string

// ListUserPacksParamsOrder defines parameters for ListUserPacks.
type ListUserPacksParamsOrder string

// ListUserTeamsParams defines parameters for ListUserTeams.
type ListUserTeamsParams struct {
	// Search Search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Sort Sorting column
	Sort *ListUserTeamsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Sorting order
	Order *ListUserTeamsParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Limit Paging limit
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Paging offset
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListUserTeamsParamsSort defines parameters for ListUserTeams.
type ListUserTeamsParamsSort string

// ListUserTeamsParamsOrder defines parameters for ListUserTeams.
type ListUserTeamsParamsOrder string

// LoginAuthJSONRequestBody defines body for LoginAuth for application/json ContentType.
type LoginAuthJSONRequestBody = AuthLogin

// DeleteFabricFromBuildJSONRequestBody defines body for DeleteFabricFromBuild for application/json ContentType.
type DeleteFabricFromBuildJSONRequestBody = FabricBuildParams

// AttachFabricToBuildJSONRequestBody defines body for AttachFabricToBuild for application/json ContentType.
type AttachFabricToBuildJSONRequestBody = FabricBuildParams

// DeleteForgeFromBuildJSONRequestBody defines body for DeleteForgeFromBuild for application/json ContentType.
type DeleteForgeFromBuildJSONRequestBody = ForgeBuildParams

// AttachForgeToBuildJSONRequestBody defines body for AttachForgeToBuild for application/json ContentType.
type AttachForgeToBuildJSONRequestBody = ForgeBuildParams

// DeleteMinecraftFromBuildJSONRequestBody defines body for DeleteMinecraftFromBuild for application/json ContentType.
type DeleteMinecraftFromBuildJSONRequestBody = MinecraftBuildParams

// AttachMinecraftToBuildJSONRequestBody defines body for AttachMinecraftToBuild for application/json ContentType.
type AttachMinecraftToBuildJSONRequestBody = MinecraftBuildParams

// CreateModJSONRequestBody defines body for CreateMod for application/json ContentType.
type CreateModJSONRequestBody = Mod

// UpdateModJSONRequestBody defines body for UpdateMod for application/json ContentType.
type UpdateModJSONRequestBody = Mod

// DeleteModFromTeamJSONRequestBody defines body for DeleteModFromTeam for application/json ContentType.
type DeleteModFromTeamJSONRequestBody = ModTeamParams

// AttachModToTeamJSONRequestBody defines body for AttachModToTeam for application/json ContentType.
type AttachModToTeamJSONRequestBody = ModTeamParams

// PermitModTeamJSONRequestBody defines body for PermitModTeam for application/json ContentType.
type PermitModTeamJSONRequestBody = ModTeamParams

// DeleteModFromUserJSONRequestBody defines body for DeleteModFromUser for application/json ContentType.
type DeleteModFromUserJSONRequestBody = ModUserParams

// AttachModToUserJSONRequestBody defines body for AttachModToUser for application/json ContentType.
type AttachModToUserJSONRequestBody = ModUserParams

// PermitModUserJSONRequestBody defines body for PermitModUser for application/json ContentType.
type PermitModUserJSONRequestBody = ModUserParams

// CreateVersionJSONRequestBody defines body for CreateVersion for application/json ContentType.
type CreateVersionJSONRequestBody = Version

// UpdateVersionJSONRequestBody defines body for UpdateVersion for application/json ContentType.
type UpdateVersionJSONRequestBody = Version

// DeleteVersionFromBuildJSONRequestBody defines body for DeleteVersionFromBuild for application/json ContentType.
type DeleteVersionFromBuildJSONRequestBody = VersionBuildParams

// AttachVersionToBuildJSONRequestBody defines body for AttachVersionToBuild for application/json ContentType.
type AttachVersionToBuildJSONRequestBody = VersionBuildParams

// DeleteNeoforgeFromBuildJSONRequestBody defines body for DeleteNeoforgeFromBuild for application/json ContentType.
type DeleteNeoforgeFromBuildJSONRequestBody = NeoforgeBuildParams

// AttachNeoforgeToBuildJSONRequestBody defines body for AttachNeoforgeToBuild for application/json ContentType.
type AttachNeoforgeToBuildJSONRequestBody = NeoforgeBuildParams

// CreatePackJSONRequestBody defines body for CreatePack for application/json ContentType.
type CreatePackJSONRequestBody = Pack

// UpdatePackJSONRequestBody defines body for UpdatePack for application/json ContentType.
type UpdatePackJSONRequestBody = Pack

// CreateBuildJSONRequestBody defines body for CreateBuild for application/json ContentType.
type CreateBuildJSONRequestBody = Build

// UpdateBuildJSONRequestBody defines body for UpdateBuild for application/json ContentType.
type UpdateBuildJSONRequestBody = Build

// DeleteBuildFromVersionJSONRequestBody defines body for DeleteBuildFromVersion for application/json ContentType.
type DeleteBuildFromVersionJSONRequestBody = BuildVersionParams

// AttachBuildToVersionJSONRequestBody defines body for AttachBuildToVersion for application/json ContentType.
type AttachBuildToVersionJSONRequestBody = BuildVersionParams

// DeletePackFromTeamJSONRequestBody defines body for DeletePackFromTeam for application/json ContentType.
type DeletePackFromTeamJSONRequestBody = PackTeamParams

// AttachPackToTeamJSONRequestBody defines body for AttachPackToTeam for application/json ContentType.
type AttachPackToTeamJSONRequestBody = PackTeamParams

// PermitPackTeamJSONRequestBody defines body for PermitPackTeam for application/json ContentType.
type PermitPackTeamJSONRequestBody = PackTeamParams

// DeletePackFromUserJSONRequestBody defines body for DeletePackFromUser for application/json ContentType.
type DeletePackFromUserJSONRequestBody = PackUserParams

// AttachPackToUserJSONRequestBody defines body for AttachPackToUser for application/json ContentType.
type AttachPackToUserJSONRequestBody = PackUserParams

// PermitPackUserJSONRequestBody defines body for PermitPackUser for application/json ContentType.
type PermitPackUserJSONRequestBody = PackUserParams

// UpdateProfileJSONRequestBody defines body for UpdateProfile for application/json ContentType.
type UpdateProfileJSONRequestBody = Profile

// DeleteQuiltFromBuildJSONRequestBody defines body for DeleteQuiltFromBuild for application/json ContentType.
type DeleteQuiltFromBuildJSONRequestBody = QuiltBuildParams

// AttachQuiltToBuildJSONRequestBody defines body for AttachQuiltToBuild for application/json ContentType.
type AttachQuiltToBuildJSONRequestBody = QuiltBuildParams

// CreateTeamJSONRequestBody defines body for CreateTeam for application/json ContentType.
type CreateTeamJSONRequestBody = Team

// UpdateTeamJSONRequestBody defines body for UpdateTeam for application/json ContentType.
type UpdateTeamJSONRequestBody = Team

// DeleteTeamFromModJSONRequestBody defines body for DeleteTeamFromMod for application/json ContentType.
type DeleteTeamFromModJSONRequestBody = TeamModParams

// AttachTeamToModJSONRequestBody defines body for AttachTeamToMod for application/json ContentType.
type AttachTeamToModJSONRequestBody = TeamModParams

// PermitTeamModJSONRequestBody defines body for PermitTeamMod for application/json ContentType.
type PermitTeamModJSONRequestBody = TeamModParams

// DeleteTeamFromPackJSONRequestBody defines body for DeleteTeamFromPack for application/json ContentType.
type DeleteTeamFromPackJSONRequestBody = TeamPackParams

// AttachTeamToPackJSONRequestBody defines body for AttachTeamToPack for application/json ContentType.
type AttachTeamToPackJSONRequestBody = TeamPackParams

// PermitTeamPackJSONRequestBody defines body for PermitTeamPack for application/json ContentType.
type PermitTeamPackJSONRequestBody = TeamPackParams

// DeleteTeamFromUserJSONRequestBody defines body for DeleteTeamFromUser for application/json ContentType.
type DeleteTeamFromUserJSONRequestBody = TeamUserParams

// AttachTeamToUserJSONRequestBody defines body for AttachTeamToUser for application/json ContentType.
type AttachTeamToUserJSONRequestBody = TeamUserParams

// PermitTeamUserJSONRequestBody defines body for PermitTeamUser for application/json ContentType.
type PermitTeamUserJSONRequestBody = TeamUserParams

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = User

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = User

// DeleteUserFromModJSONRequestBody defines body for DeleteUserFromMod for application/json ContentType.
type DeleteUserFromModJSONRequestBody = UserModParams

// AttachUserToModJSONRequestBody defines body for AttachUserToMod for application/json ContentType.
type AttachUserToModJSONRequestBody = UserModParams

// PermitUserModJSONRequestBody defines body for PermitUserMod for application/json ContentType.
type PermitUserModJSONRequestBody = UserModParams

// DeleteUserFromPackJSONRequestBody defines body for DeleteUserFromPack for application/json ContentType.
type DeleteUserFromPackJSONRequestBody = UserPackParams

// AttachUserToPackJSONRequestBody defines body for AttachUserToPack for application/json ContentType.
type AttachUserToPackJSONRequestBody = UserPackParams

// PermitUserPackJSONRequestBody defines body for PermitUserPack for application/json ContentType.
type PermitUserPackJSONRequestBody = UserPackParams

// DeleteUserFromTeamJSONRequestBody defines body for DeleteUserFromTeam for application/json ContentType.
type DeleteUserFromTeamJSONRequestBody = UserTeamParams

// AttachUserToTeamJSONRequestBody defines body for AttachUserToTeam for application/json ContentType.
type AttachUserToTeamJSONRequestBody = UserTeamParams

// PermitUserTeamJSONRequestBody defines body for PermitUserTeam for application/json ContentType.
type PermitUserTeamJSONRequestBody = UserTeamParams

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// LoginAuthWithBody request with any body
	LoginAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoginAuth(ctx context.Context, body LoginAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExternalProviders request
	ExternalProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshAuth request
	RefreshAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyAuth request
	VerifyAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExternalCallback request
	ExternalCallback(ctx context.Context, provider string, params *ExternalCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExternalInitialize request
	ExternalInitialize(ctx context.Context, provider string, params *ExternalInitializeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFabrics request
	ListFabrics(ctx context.Context, params *ListFabricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFabric request
	UpdateFabric(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFabricFromBuildWithBody request with any body
	DeleteFabricFromBuildWithBody(ctx context.Context, fabricId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteFabricFromBuild(ctx context.Context, fabricId string, body DeleteFabricFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFabricBuilds request
	ListFabricBuilds(ctx context.Context, fabricId string, params *ListFabricBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachFabricToBuildWithBody request with any body
	AttachFabricToBuildWithBody(ctx context.Context, fabricId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachFabricToBuild(ctx context.Context, fabricId string, body AttachFabricToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListForges request
	ListForges(ctx context.Context, params *ListForgesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateForge request
	UpdateForge(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteForgeFromBuildWithBody request with any body
	DeleteForgeFromBuildWithBody(ctx context.Context, forgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteForgeFromBuild(ctx context.Context, forgeId string, body DeleteForgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListForgeBuilds request
	ListForgeBuilds(ctx context.Context, forgeId string, params *ListForgeBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachForgeToBuildWithBody request with any body
	AttachForgeToBuildWithBody(ctx context.Context, forgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachForgeToBuild(ctx context.Context, forgeId string, body AttachForgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMinecrafts request
	ListMinecrafts(ctx context.Context, params *ListMinecraftsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMinecraft request
	UpdateMinecraft(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMinecraftFromBuildWithBody request with any body
	DeleteMinecraftFromBuildWithBody(ctx context.Context, minecraftId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteMinecraftFromBuild(ctx context.Context, minecraftId string, body DeleteMinecraftFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMinecraftBuilds request
	ListMinecraftBuilds(ctx context.Context, minecraftId string, params *ListMinecraftBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachMinecraftToBuildWithBody request with any body
	AttachMinecraftToBuildWithBody(ctx context.Context, minecraftId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachMinecraftToBuild(ctx context.Context, minecraftId string, body AttachMinecraftToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMods request
	ListMods(ctx context.Context, params *ListModsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateModWithBody request with any body
	CreateModWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMod(ctx context.Context, body CreateModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMod request
	DeleteMod(ctx context.Context, modId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowMod request
	ShowMod(ctx context.Context, modId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateModWithBody request with any body
	UpdateModWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMod(ctx context.Context, modId string, body UpdateModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteModFromTeamWithBody request with any body
	DeleteModFromTeamWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteModFromTeam(ctx context.Context, modId string, body DeleteModFromTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListModTeams request
	ListModTeams(ctx context.Context, modId string, params *ListModTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachModToTeamWithBody request with any body
	AttachModToTeamWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachModToTeam(ctx context.Context, modId string, body AttachModToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitModTeamWithBody request with any body
	PermitModTeamWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitModTeam(ctx context.Context, modId string, body PermitModTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteModFromUserWithBody request with any body
	DeleteModFromUserWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteModFromUser(ctx context.Context, modId string, body DeleteModFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListModUsers request
	ListModUsers(ctx context.Context, modId string, params *ListModUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachModToUserWithBody request with any body
	AttachModToUserWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachModToUser(ctx context.Context, modId string, body AttachModToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitModUserWithBody request with any body
	PermitModUserWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitModUser(ctx context.Context, modId string, body PermitModUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVersions request
	ListVersions(ctx context.Context, modId string, params *ListVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVersionWithBody request with any body
	CreateVersionWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVersion(ctx context.Context, modId string, body CreateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVersion request
	DeleteVersion(ctx context.Context, modId string, versionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowVersion request
	ShowVersion(ctx context.Context, modId string, versionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateVersionWithBody request with any body
	UpdateVersionWithBody(ctx context.Context, modId string, versionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateVersion(ctx context.Context, modId string, versionId string, body UpdateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVersionFromBuildWithBody request with any body
	DeleteVersionFromBuildWithBody(ctx context.Context, modId string, versionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteVersionFromBuild(ctx context.Context, modId string, versionId string, body DeleteVersionFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVersionBuilds request
	ListVersionBuilds(ctx context.Context, modId string, versionId string, params *ListVersionBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachVersionToBuildWithBody request with any body
	AttachVersionToBuildWithBody(ctx context.Context, modId string, versionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachVersionToBuild(ctx context.Context, modId string, versionId string, body AttachVersionToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNeoforges request
	ListNeoforges(ctx context.Context, params *ListNeoforgesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNeoforge request
	UpdateNeoforge(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNeoforgeFromBuildWithBody request with any body
	DeleteNeoforgeFromBuildWithBody(ctx context.Context, neoforgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteNeoforgeFromBuild(ctx context.Context, neoforgeId string, body DeleteNeoforgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNeoforgeBuilds request
	ListNeoforgeBuilds(ctx context.Context, neoforgeId string, params *ListNeoforgeBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachNeoforgeToBuildWithBody request with any body
	AttachNeoforgeToBuildWithBody(ctx context.Context, neoforgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachNeoforgeToBuild(ctx context.Context, neoforgeId string, body AttachNeoforgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPacks request
	ListPacks(ctx context.Context, params *ListPacksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePackWithBody request with any body
	CreatePackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePack(ctx context.Context, body CreatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePack request
	DeletePack(ctx context.Context, packId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowPack request
	ShowPack(ctx context.Context, packId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePackWithBody request with any body
	UpdatePackWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePack(ctx context.Context, packId string, body UpdatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBuilds request
	ListBuilds(ctx context.Context, packId string, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBuildWithBody request with any body
	CreateBuildWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBuild(ctx context.Context, packId string, body CreateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBuild request
	DeleteBuild(ctx context.Context, packId string, buildId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowBuild request
	ShowBuild(ctx context.Context, packId string, buildId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBuildWithBody request with any body
	UpdateBuildWithBody(ctx context.Context, packId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBuild(ctx context.Context, packId string, buildId string, body UpdateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBuildFromVersionWithBody request with any body
	DeleteBuildFromVersionWithBody(ctx context.Context, packId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteBuildFromVersion(ctx context.Context, packId string, buildId string, body DeleteBuildFromVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBuildVersions request
	ListBuildVersions(ctx context.Context, packId string, buildId string, params *ListBuildVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachBuildToVersionWithBody request with any body
	AttachBuildToVersionWithBody(ctx context.Context, packId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachBuildToVersion(ctx context.Context, packId string, buildId string, body AttachBuildToVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePackFromTeamWithBody request with any body
	DeletePackFromTeamWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePackFromTeam(ctx context.Context, packId string, body DeletePackFromTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPackTeams request
	ListPackTeams(ctx context.Context, packId string, params *ListPackTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachPackToTeamWithBody request with any body
	AttachPackToTeamWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachPackToTeam(ctx context.Context, packId string, body AttachPackToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitPackTeamWithBody request with any body
	PermitPackTeamWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitPackTeam(ctx context.Context, packId string, body PermitPackTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePackFromUserWithBody request with any body
	DeletePackFromUserWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePackFromUser(ctx context.Context, packId string, body DeletePackFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPackUsers request
	ListPackUsers(ctx context.Context, packId string, params *ListPackUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachPackToUserWithBody request with any body
	AttachPackToUserWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachPackToUser(ctx context.Context, packId string, body AttachPackToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitPackUserWithBody request with any body
	PermitPackUserWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitPackUser(ctx context.Context, packId string, body PermitPackUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowProfile request
	ShowProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProfileWithBody request with any body
	UpdateProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProfile(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokenProfile request
	TokenProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListQuilts request
	ListQuilts(ctx context.Context, params *ListQuiltsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateQuilt request
	UpdateQuilt(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteQuiltFromBuildWithBody request with any body
	DeleteQuiltFromBuildWithBody(ctx context.Context, quiltId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteQuiltFromBuild(ctx context.Context, quiltId string, body DeleteQuiltFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListQuiltBuilds request
	ListQuiltBuilds(ctx context.Context, quiltId string, params *ListQuiltBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachQuiltToBuildWithBody request with any body
	AttachQuiltToBuildWithBody(ctx context.Context, quiltId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachQuiltToBuild(ctx context.Context, quiltId string, body AttachQuiltToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTeams request
	ListTeams(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTeamWithBody request with any body
	CreateTeamWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTeam(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTeam request
	DeleteTeam(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowTeam request
	ShowTeam(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTeamWithBody request with any body
	UpdateTeamWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTeam(ctx context.Context, teamId string, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTeamFromModWithBody request with any body
	DeleteTeamFromModWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTeamFromMod(ctx context.Context, teamId string, body DeleteTeamFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTeamMods request
	ListTeamMods(ctx context.Context, teamId string, params *ListTeamModsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachTeamToModWithBody request with any body
	AttachTeamToModWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachTeamToMod(ctx context.Context, teamId string, body AttachTeamToModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitTeamModWithBody request with any body
	PermitTeamModWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitTeamMod(ctx context.Context, teamId string, body PermitTeamModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTeamFromPackWithBody request with any body
	DeleteTeamFromPackWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTeamFromPack(ctx context.Context, teamId string, body DeleteTeamFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTeamPacks request
	ListTeamPacks(ctx context.Context, teamId string, params *ListTeamPacksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachTeamToPackWithBody request with any body
	AttachTeamToPackWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachTeamToPack(ctx context.Context, teamId string, body AttachTeamToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitTeamPackWithBody request with any body
	PermitTeamPackWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitTeamPack(ctx context.Context, teamId string, body PermitTeamPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTeamFromUserWithBody request with any body
	DeleteTeamFromUserWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTeamFromUser(ctx context.Context, teamId string, body DeleteTeamFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTeamUsers request
	ListTeamUsers(ctx context.Context, teamId string, params *ListTeamUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachTeamToUserWithBody request with any body
	AttachTeamToUserWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachTeamToUser(ctx context.Context, teamId string, body AttachTeamToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitTeamUserWithBody request with any body
	PermitTeamUserWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitTeamUser(ctx context.Context, teamId string, body PermitTeamUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowUser request
	ShowUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserFromModWithBody request with any body
	DeleteUserFromModWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteUserFromMod(ctx context.Context, userId string, body DeleteUserFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserMods request
	ListUserMods(ctx context.Context, userId string, params *ListUserModsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachUserToModWithBody request with any body
	AttachUserToModWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachUserToMod(ctx context.Context, userId string, body AttachUserToModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitUserModWithBody request with any body
	PermitUserModWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitUserMod(ctx context.Context, userId string, body PermitUserModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserFromPackWithBody request with any body
	DeleteUserFromPackWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteUserFromPack(ctx context.Context, userId string, body DeleteUserFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserPacks request
	ListUserPacks(ctx context.Context, userId string, params *ListUserPacksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachUserToPackWithBody request with any body
	AttachUserToPackWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachUserToPack(ctx context.Context, userId string, body AttachUserToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitUserPackWithBody request with any body
	PermitUserPackWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitUserPack(ctx context.Context, userId string, body PermitUserPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserFromTeamWithBody request with any body
	DeleteUserFromTeamWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteUserFromTeam(ctx context.Context, userId string, body DeleteUserFromTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserTeams request
	ListUserTeams(ctx context.Context, userId string, params *ListUserTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AttachUserToTeamWithBody request with any body
	AttachUserToTeamWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AttachUserToTeam(ctx context.Context, userId string, body AttachUserToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PermitUserTeamWithBody request with any body
	PermitUserTeamWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PermitUserTeam(ctx context.Context, userId string, body PermitUserTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) LoginAuthWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginAuthRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginAuth(ctx context.Context, body LoginAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginAuthRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExternalProviders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExternalProvidersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshAuthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyAuth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyAuthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExternalCallback(ctx context.Context, provider string, params *ExternalCallbackParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExternalCallbackRequest(c.Server, provider, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExternalInitialize(ctx context.Context, provider string, params *ExternalInitializeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExternalInitializeRequest(c.Server, provider, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFabrics(ctx context.Context, params *ListFabricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFabricsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFabric(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFabricRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFabricFromBuildWithBody(ctx context.Context, fabricId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFabricFromBuildRequestWithBody(c.Server, fabricId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFabricFromBuild(ctx context.Context, fabricId string, body DeleteFabricFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFabricFromBuildRequest(c.Server, fabricId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFabricBuilds(ctx context.Context, fabricId string, params *ListFabricBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFabricBuildsRequest(c.Server, fabricId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachFabricToBuildWithBody(ctx context.Context, fabricId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachFabricToBuildRequestWithBody(c.Server, fabricId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachFabricToBuild(ctx context.Context, fabricId string, body AttachFabricToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachFabricToBuildRequest(c.Server, fabricId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListForges(ctx context.Context, params *ListForgesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListForgesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateForge(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateForgeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteForgeFromBuildWithBody(ctx context.Context, forgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteForgeFromBuildRequestWithBody(c.Server, forgeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteForgeFromBuild(ctx context.Context, forgeId string, body DeleteForgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteForgeFromBuildRequest(c.Server, forgeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListForgeBuilds(ctx context.Context, forgeId string, params *ListForgeBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListForgeBuildsRequest(c.Server, forgeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachForgeToBuildWithBody(ctx context.Context, forgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachForgeToBuildRequestWithBody(c.Server, forgeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachForgeToBuild(ctx context.Context, forgeId string, body AttachForgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachForgeToBuildRequest(c.Server, forgeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMinecrafts(ctx context.Context, params *ListMinecraftsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMinecraftsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMinecraft(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMinecraftRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMinecraftFromBuildWithBody(ctx context.Context, minecraftId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMinecraftFromBuildRequestWithBody(c.Server, minecraftId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMinecraftFromBuild(ctx context.Context, minecraftId string, body DeleteMinecraftFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMinecraftFromBuildRequest(c.Server, minecraftId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMinecraftBuilds(ctx context.Context, minecraftId string, params *ListMinecraftBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMinecraftBuildsRequest(c.Server, minecraftId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachMinecraftToBuildWithBody(ctx context.Context, minecraftId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachMinecraftToBuildRequestWithBody(c.Server, minecraftId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachMinecraftToBuild(ctx context.Context, minecraftId string, body AttachMinecraftToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachMinecraftToBuildRequest(c.Server, minecraftId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMods(ctx context.Context, params *ListModsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateModWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMod(ctx context.Context, body CreateModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateModRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMod(ctx context.Context, modId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModRequest(c.Server, modId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowMod(ctx context.Context, modId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowModRequest(c.Server, modId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateModWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateModRequestWithBody(c.Server, modId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMod(ctx context.Context, modId string, body UpdateModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateModRequest(c.Server, modId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModFromTeamWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModFromTeamRequestWithBody(c.Server, modId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModFromTeam(ctx context.Context, modId string, body DeleteModFromTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModFromTeamRequest(c.Server, modId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListModTeams(ctx context.Context, modId string, params *ListModTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModTeamsRequest(c.Server, modId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachModToTeamWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachModToTeamRequestWithBody(c.Server, modId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachModToTeam(ctx context.Context, modId string, body AttachModToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachModToTeamRequest(c.Server, modId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitModTeamWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitModTeamRequestWithBody(c.Server, modId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitModTeam(ctx context.Context, modId string, body PermitModTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitModTeamRequest(c.Server, modId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModFromUserWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModFromUserRequestWithBody(c.Server, modId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteModFromUser(ctx context.Context, modId string, body DeleteModFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteModFromUserRequest(c.Server, modId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListModUsers(ctx context.Context, modId string, params *ListModUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListModUsersRequest(c.Server, modId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachModToUserWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachModToUserRequestWithBody(c.Server, modId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachModToUser(ctx context.Context, modId string, body AttachModToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachModToUserRequest(c.Server, modId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitModUserWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitModUserRequestWithBody(c.Server, modId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitModUser(ctx context.Context, modId string, body PermitModUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitModUserRequest(c.Server, modId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVersions(ctx context.Context, modId string, params *ListVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVersionsRequest(c.Server, modId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVersionWithBody(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVersionRequestWithBody(c.Server, modId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVersion(ctx context.Context, modId string, body CreateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVersionRequest(c.Server, modId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVersion(ctx context.Context, modId string, versionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVersionRequest(c.Server, modId, versionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowVersion(ctx context.Context, modId string, versionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowVersionRequest(c.Server, modId, versionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVersionWithBody(ctx context.Context, modId string, versionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVersionRequestWithBody(c.Server, modId, versionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateVersion(ctx context.Context, modId string, versionId string, body UpdateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateVersionRequest(c.Server, modId, versionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVersionFromBuildWithBody(ctx context.Context, modId string, versionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVersionFromBuildRequestWithBody(c.Server, modId, versionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVersionFromBuild(ctx context.Context, modId string, versionId string, body DeleteVersionFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVersionFromBuildRequest(c.Server, modId, versionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVersionBuilds(ctx context.Context, modId string, versionId string, params *ListVersionBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVersionBuildsRequest(c.Server, modId, versionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachVersionToBuildWithBody(ctx context.Context, modId string, versionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachVersionToBuildRequestWithBody(c.Server, modId, versionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachVersionToBuild(ctx context.Context, modId string, versionId string, body AttachVersionToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachVersionToBuildRequest(c.Server, modId, versionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNeoforges(ctx context.Context, params *ListNeoforgesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNeoforgesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNeoforge(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNeoforgeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNeoforgeFromBuildWithBody(ctx context.Context, neoforgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNeoforgeFromBuildRequestWithBody(c.Server, neoforgeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNeoforgeFromBuild(ctx context.Context, neoforgeId string, body DeleteNeoforgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNeoforgeFromBuildRequest(c.Server, neoforgeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNeoforgeBuilds(ctx context.Context, neoforgeId string, params *ListNeoforgeBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNeoforgeBuildsRequest(c.Server, neoforgeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachNeoforgeToBuildWithBody(ctx context.Context, neoforgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachNeoforgeToBuildRequestWithBody(c.Server, neoforgeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachNeoforgeToBuild(ctx context.Context, neoforgeId string, body AttachNeoforgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachNeoforgeToBuildRequest(c.Server, neoforgeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPacks(ctx context.Context, params *ListPacksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPacksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePackWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePackRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePack(ctx context.Context, body CreatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePackRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePack(ctx context.Context, packId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackRequest(c.Server, packId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowPack(ctx context.Context, packId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowPackRequest(c.Server, packId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePackWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePackRequestWithBody(c.Server, packId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePack(ctx context.Context, packId string, body UpdatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePackRequest(c.Server, packId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBuilds(ctx context.Context, packId string, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBuildsRequest(c.Server, packId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBuildWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBuildRequestWithBody(c.Server, packId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBuild(ctx context.Context, packId string, body CreateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBuildRequest(c.Server, packId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBuild(ctx context.Context, packId string, buildId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBuildRequest(c.Server, packId, buildId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowBuild(ctx context.Context, packId string, buildId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowBuildRequest(c.Server, packId, buildId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBuildWithBody(ctx context.Context, packId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBuildRequestWithBody(c.Server, packId, buildId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBuild(ctx context.Context, packId string, buildId string, body UpdateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBuildRequest(c.Server, packId, buildId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBuildFromVersionWithBody(ctx context.Context, packId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBuildFromVersionRequestWithBody(c.Server, packId, buildId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBuildFromVersion(ctx context.Context, packId string, buildId string, body DeleteBuildFromVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBuildFromVersionRequest(c.Server, packId, buildId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBuildVersions(ctx context.Context, packId string, buildId string, params *ListBuildVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBuildVersionsRequest(c.Server, packId, buildId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachBuildToVersionWithBody(ctx context.Context, packId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachBuildToVersionRequestWithBody(c.Server, packId, buildId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachBuildToVersion(ctx context.Context, packId string, buildId string, body AttachBuildToVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachBuildToVersionRequest(c.Server, packId, buildId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackFromTeamWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackFromTeamRequestWithBody(c.Server, packId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackFromTeam(ctx context.Context, packId string, body DeletePackFromTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackFromTeamRequest(c.Server, packId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPackTeams(ctx context.Context, packId string, params *ListPackTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPackTeamsRequest(c.Server, packId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPackToTeamWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPackToTeamRequestWithBody(c.Server, packId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPackToTeam(ctx context.Context, packId string, body AttachPackToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPackToTeamRequest(c.Server, packId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitPackTeamWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitPackTeamRequestWithBody(c.Server, packId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitPackTeam(ctx context.Context, packId string, body PermitPackTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitPackTeamRequest(c.Server, packId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackFromUserWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackFromUserRequestWithBody(c.Server, packId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackFromUser(ctx context.Context, packId string, body DeletePackFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackFromUserRequest(c.Server, packId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPackUsers(ctx context.Context, packId string, params *ListPackUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPackUsersRequest(c.Server, packId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPackToUserWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPackToUserRequestWithBody(c.Server, packId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachPackToUser(ctx context.Context, packId string, body AttachPackToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachPackToUserRequest(c.Server, packId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitPackUserWithBody(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitPackUserRequestWithBody(c.Server, packId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitPackUser(ctx context.Context, packId string, body PermitPackUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitPackUserRequest(c.Server, packId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowProfileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProfileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProfile(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProfileRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenProfileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListQuilts(ctx context.Context, params *ListQuiltsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListQuiltsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateQuilt(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateQuiltRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteQuiltFromBuildWithBody(ctx context.Context, quiltId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteQuiltFromBuildRequestWithBody(c.Server, quiltId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteQuiltFromBuild(ctx context.Context, quiltId string, body DeleteQuiltFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteQuiltFromBuildRequest(c.Server, quiltId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListQuiltBuilds(ctx context.Context, quiltId string, params *ListQuiltBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListQuiltBuildsRequest(c.Server, quiltId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachQuiltToBuildWithBody(ctx context.Context, quiltId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachQuiltToBuildRequestWithBody(c.Server, quiltId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachQuiltToBuild(ctx context.Context, quiltId string, body AttachQuiltToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachQuiltToBuildRequest(c.Server, quiltId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTeams(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeamWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeam(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeam(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowTeam(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowTeamRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeam(ctx context.Context, teamId string, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamFromModWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamFromModRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamFromMod(ctx context.Context, teamId string, body DeleteTeamFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamFromModRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTeamMods(ctx context.Context, teamId string, params *ListTeamModsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTeamModsRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachTeamToModWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachTeamToModRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachTeamToMod(ctx context.Context, teamId string, body AttachTeamToModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachTeamToModRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitTeamModWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitTeamModRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitTeamMod(ctx context.Context, teamId string, body PermitTeamModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitTeamModRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamFromPackWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamFromPackRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamFromPack(ctx context.Context, teamId string, body DeleteTeamFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamFromPackRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTeamPacks(ctx context.Context, teamId string, params *ListTeamPacksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTeamPacksRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachTeamToPackWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachTeamToPackRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachTeamToPack(ctx context.Context, teamId string, body AttachTeamToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachTeamToPackRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitTeamPackWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitTeamPackRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitTeamPack(ctx context.Context, teamId string, body PermitTeamPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitTeamPackRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamFromUserWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamFromUserRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamFromUser(ctx context.Context, teamId string, body DeleteTeamFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamFromUserRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTeamUsers(ctx context.Context, teamId string, params *ListTeamUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTeamUsersRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachTeamToUserWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachTeamToUserRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachTeamToUser(ctx context.Context, teamId string, body AttachTeamToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachTeamToUserRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitTeamUserWithBody(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitTeamUserRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitTeamUser(ctx context.Context, teamId string, body PermitTeamUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitTeamUserRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromModWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromModRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromMod(ctx context.Context, userId string, body DeleteUserFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromModRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserMods(ctx context.Context, userId string, params *ListUserModsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserModsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToModWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToModRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToMod(ctx context.Context, userId string, body AttachUserToModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToModRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserModWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserModRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserMod(ctx context.Context, userId string, body PermitUserModJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserModRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromPackWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromPackRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromPack(ctx context.Context, userId string, body DeleteUserFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromPackRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserPacks(ctx context.Context, userId string, params *ListUserPacksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserPacksRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToPackWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToPackRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToPack(ctx context.Context, userId string, body AttachUserToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToPackRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserPackWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserPackRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserPack(ctx context.Context, userId string, body PermitUserPackJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserPackRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromTeamWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromTeamRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserFromTeam(ctx context.Context, userId string, body DeleteUserFromTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserFromTeamRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserTeams(ctx context.Context, userId string, params *ListUserTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserTeamsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToTeamWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToTeamRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AttachUserToTeam(ctx context.Context, userId string, body AttachUserToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAttachUserToTeamRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserTeamWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserTeamRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PermitUserTeam(ctx context.Context, userId string, body PermitUserTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPermitUserTeamRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewLoginAuthRequest calls the generic LoginAuth builder with application/json body
func NewLoginAuthRequest(server string, body LoginAuthJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginAuthRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginAuthRequestWithBody generates requests for LoginAuth with any type of body
func NewLoginAuthRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExternalProvidersRequest generates requests for ExternalProviders
func NewExternalProvidersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/providers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRefreshAuthRequest generates requests for RefreshAuth
func NewRefreshAuthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVerifyAuthRequest generates requests for VerifyAuth
func NewVerifyAuthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/verify")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExternalCallbackRequest generates requests for ExternalCallback
func NewExternalCallbackRequest(server string, provider string, params *ExternalCallbackParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/%s/callback", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Code != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, *params.Code); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExternalInitializeRequest generates requests for ExternalInitialize
func NewExternalInitializeRequest(server string, provider string, params *ExternalInitializeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "provider", runtime.ParamLocationPath, provider)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/%s/initialize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListFabricsRequest generates requests for ListFabrics
func NewListFabricsRequest(server string, params *ListFabricsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fabric")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFabricRequest generates requests for UpdateFabric
func NewUpdateFabricRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fabric")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteFabricFromBuildRequest calls the generic DeleteFabricFromBuild builder with application/json body
func NewDeleteFabricFromBuildRequest(server string, fabricId string, body DeleteFabricFromBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteFabricFromBuildRequestWithBody(server, fabricId, "application/json", bodyReader)
}

// NewDeleteFabricFromBuildRequestWithBody generates requests for DeleteFabricFromBuild with any type of body
func NewDeleteFabricFromBuildRequestWithBody(server string, fabricId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fabric_id", runtime.ParamLocationPath, fabricId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fabric/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFabricBuildsRequest generates requests for ListFabricBuilds
func NewListFabricBuildsRequest(server string, fabricId string, params *ListFabricBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fabric_id", runtime.ParamLocationPath, fabricId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fabric/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachFabricToBuildRequest calls the generic AttachFabricToBuild builder with application/json body
func NewAttachFabricToBuildRequest(server string, fabricId string, body AttachFabricToBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachFabricToBuildRequestWithBody(server, fabricId, "application/json", bodyReader)
}

// NewAttachFabricToBuildRequestWithBody generates requests for AttachFabricToBuild with any type of body
func NewAttachFabricToBuildRequestWithBody(server string, fabricId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fabric_id", runtime.ParamLocationPath, fabricId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fabric/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListForgesRequest generates requests for ListForges
func NewListForgesRequest(server string, params *ListForgesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/forge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateForgeRequest generates requests for UpdateForge
func NewUpdateForgeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/forge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteForgeFromBuildRequest calls the generic DeleteForgeFromBuild builder with application/json body
func NewDeleteForgeFromBuildRequest(server string, forgeId string, body DeleteForgeFromBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteForgeFromBuildRequestWithBody(server, forgeId, "application/json", bodyReader)
}

// NewDeleteForgeFromBuildRequestWithBody generates requests for DeleteForgeFromBuild with any type of body
func NewDeleteForgeFromBuildRequestWithBody(server string, forgeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "forge_id", runtime.ParamLocationPath, forgeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/forge/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListForgeBuildsRequest generates requests for ListForgeBuilds
func NewListForgeBuildsRequest(server string, forgeId string, params *ListForgeBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "forge_id", runtime.ParamLocationPath, forgeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/forge/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachForgeToBuildRequest calls the generic AttachForgeToBuild builder with application/json body
func NewAttachForgeToBuildRequest(server string, forgeId string, body AttachForgeToBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachForgeToBuildRequestWithBody(server, forgeId, "application/json", bodyReader)
}

// NewAttachForgeToBuildRequestWithBody generates requests for AttachForgeToBuild with any type of body
func NewAttachForgeToBuildRequestWithBody(server string, forgeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "forge_id", runtime.ParamLocationPath, forgeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/forge/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListMinecraftsRequest generates requests for ListMinecrafts
func NewListMinecraftsRequest(server string, params *ListMinecraftsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/minecraft")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMinecraftRequest generates requests for UpdateMinecraft
func NewUpdateMinecraftRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/minecraft")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteMinecraftFromBuildRequest calls the generic DeleteMinecraftFromBuild builder with application/json body
func NewDeleteMinecraftFromBuildRequest(server string, minecraftId string, body DeleteMinecraftFromBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteMinecraftFromBuildRequestWithBody(server, minecraftId, "application/json", bodyReader)
}

// NewDeleteMinecraftFromBuildRequestWithBody generates requests for DeleteMinecraftFromBuild with any type of body
func NewDeleteMinecraftFromBuildRequestWithBody(server string, minecraftId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "minecraft_id", runtime.ParamLocationPath, minecraftId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/minecraft/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListMinecraftBuildsRequest generates requests for ListMinecraftBuilds
func NewListMinecraftBuildsRequest(server string, minecraftId string, params *ListMinecraftBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "minecraft_id", runtime.ParamLocationPath, minecraftId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/minecraft/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachMinecraftToBuildRequest calls the generic AttachMinecraftToBuild builder with application/json body
func NewAttachMinecraftToBuildRequest(server string, minecraftId string, body AttachMinecraftToBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachMinecraftToBuildRequestWithBody(server, minecraftId, "application/json", bodyReader)
}

// NewAttachMinecraftToBuildRequestWithBody generates requests for AttachMinecraftToBuild with any type of body
func NewAttachMinecraftToBuildRequestWithBody(server string, minecraftId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "minecraft_id", runtime.ParamLocationPath, minecraftId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/minecraft/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListModsRequest generates requests for ListMods
func NewListModsRequest(server string, params *ListModsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateModRequest calls the generic CreateMod builder with application/json body
func NewCreateModRequest(server string, body CreateModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateModRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateModRequestWithBody generates requests for CreateMod with any type of body
func NewCreateModRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteModRequest generates requests for DeleteMod
func NewDeleteModRequest(server string, modId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowModRequest generates requests for ShowMod
func NewShowModRequest(server string, modId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateModRequest calls the generic UpdateMod builder with application/json body
func NewUpdateModRequest(server string, modId string, body UpdateModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateModRequestWithBody(server, modId, "application/json", bodyReader)
}

// NewUpdateModRequestWithBody generates requests for UpdateMod with any type of body
func NewUpdateModRequestWithBody(server string, modId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteModFromTeamRequest calls the generic DeleteModFromTeam builder with application/json body
func NewDeleteModFromTeamRequest(server string, modId string, body DeleteModFromTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteModFromTeamRequestWithBody(server, modId, "application/json", bodyReader)
}

// NewDeleteModFromTeamRequestWithBody generates requests for DeleteModFromTeam with any type of body
func NewDeleteModFromTeamRequestWithBody(server string, modId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListModTeamsRequest generates requests for ListModTeams
func NewListModTeamsRequest(server string, modId string, params *ListModTeamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachModToTeamRequest calls the generic AttachModToTeam builder with application/json body
func NewAttachModToTeamRequest(server string, modId string, body AttachModToTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachModToTeamRequestWithBody(server, modId, "application/json", bodyReader)
}

// NewAttachModToTeamRequestWithBody generates requests for AttachModToTeam with any type of body
func NewAttachModToTeamRequestWithBody(server string, modId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitModTeamRequest calls the generic PermitModTeam builder with application/json body
func NewPermitModTeamRequest(server string, modId string, body PermitModTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitModTeamRequestWithBody(server, modId, "application/json", bodyReader)
}

// NewPermitModTeamRequestWithBody generates requests for PermitModTeam with any type of body
func NewPermitModTeamRequestWithBody(server string, modId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteModFromUserRequest calls the generic DeleteModFromUser builder with application/json body
func NewDeleteModFromUserRequest(server string, modId string, body DeleteModFromUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteModFromUserRequestWithBody(server, modId, "application/json", bodyReader)
}

// NewDeleteModFromUserRequestWithBody generates requests for DeleteModFromUser with any type of body
func NewDeleteModFromUserRequestWithBody(server string, modId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListModUsersRequest generates requests for ListModUsers
func NewListModUsersRequest(server string, modId string, params *ListModUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachModToUserRequest calls the generic AttachModToUser builder with application/json body
func NewAttachModToUserRequest(server string, modId string, body AttachModToUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachModToUserRequestWithBody(server, modId, "application/json", bodyReader)
}

// NewAttachModToUserRequestWithBody generates requests for AttachModToUser with any type of body
func NewAttachModToUserRequestWithBody(server string, modId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitModUserRequest calls the generic PermitModUser builder with application/json body
func NewPermitModUserRequest(server string, modId string, body PermitModUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitModUserRequestWithBody(server, modId, "application/json", bodyReader)
}

// NewPermitModUserRequestWithBody generates requests for PermitModUser with any type of body
func NewPermitModUserRequestWithBody(server string, modId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVersionsRequest generates requests for ListVersions
func NewListVersionsRequest(server string, modId string, params *ListVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVersionRequest calls the generic CreateVersion builder with application/json body
func NewCreateVersionRequest(server string, modId string, body CreateVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVersionRequestWithBody(server, modId, "application/json", bodyReader)
}

// NewCreateVersionRequestWithBody generates requests for CreateVersion with any type of body
func NewCreateVersionRequestWithBody(server string, modId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVersionRequest generates requests for DeleteVersion
func NewDeleteVersionRequest(server string, modId string, versionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version_id", runtime.ParamLocationPath, versionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowVersionRequest generates requests for ShowVersion
func NewShowVersionRequest(server string, modId string, versionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version_id", runtime.ParamLocationPath, versionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateVersionRequest calls the generic UpdateVersion builder with application/json body
func NewUpdateVersionRequest(server string, modId string, versionId string, body UpdateVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateVersionRequestWithBody(server, modId, versionId, "application/json", bodyReader)
}

// NewUpdateVersionRequestWithBody generates requests for UpdateVersion with any type of body
func NewUpdateVersionRequestWithBody(server string, modId string, versionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version_id", runtime.ParamLocationPath, versionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVersionFromBuildRequest calls the generic DeleteVersionFromBuild builder with application/json body
func NewDeleteVersionFromBuildRequest(server string, modId string, versionId string, body DeleteVersionFromBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteVersionFromBuildRequestWithBody(server, modId, versionId, "application/json", bodyReader)
}

// NewDeleteVersionFromBuildRequestWithBody generates requests for DeleteVersionFromBuild with any type of body
func NewDeleteVersionFromBuildRequestWithBody(server string, modId string, versionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version_id", runtime.ParamLocationPath, versionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions/%s/builds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListVersionBuildsRequest generates requests for ListVersionBuilds
func NewListVersionBuildsRequest(server string, modId string, versionId string, params *ListVersionBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version_id", runtime.ParamLocationPath, versionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions/%s/builds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachVersionToBuildRequest calls the generic AttachVersionToBuild builder with application/json body
func NewAttachVersionToBuildRequest(server string, modId string, versionId string, body AttachVersionToBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachVersionToBuildRequestWithBody(server, modId, versionId, "application/json", bodyReader)
}

// NewAttachVersionToBuildRequestWithBody generates requests for AttachVersionToBuild with any type of body
func NewAttachVersionToBuildRequestWithBody(server string, modId string, versionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mod_id", runtime.ParamLocationPath, modId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version_id", runtime.ParamLocationPath, versionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mods/%s/versions/%s/builds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListNeoforgesRequest generates requests for ListNeoforges
func NewListNeoforgesRequest(server string, params *ListNeoforgesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/neoforge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNeoforgeRequest generates requests for UpdateNeoforge
func NewUpdateNeoforgeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/neoforge")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNeoforgeFromBuildRequest calls the generic DeleteNeoforgeFromBuild builder with application/json body
func NewDeleteNeoforgeFromBuildRequest(server string, neoforgeId string, body DeleteNeoforgeFromBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteNeoforgeFromBuildRequestWithBody(server, neoforgeId, "application/json", bodyReader)
}

// NewDeleteNeoforgeFromBuildRequestWithBody generates requests for DeleteNeoforgeFromBuild with any type of body
func NewDeleteNeoforgeFromBuildRequestWithBody(server string, neoforgeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "neoforge_id", runtime.ParamLocationPath, neoforgeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/neoforge/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListNeoforgeBuildsRequest generates requests for ListNeoforgeBuilds
func NewListNeoforgeBuildsRequest(server string, neoforgeId string, params *ListNeoforgeBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "neoforge_id", runtime.ParamLocationPath, neoforgeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/neoforge/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachNeoforgeToBuildRequest calls the generic AttachNeoforgeToBuild builder with application/json body
func NewAttachNeoforgeToBuildRequest(server string, neoforgeId string, body AttachNeoforgeToBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachNeoforgeToBuildRequestWithBody(server, neoforgeId, "application/json", bodyReader)
}

// NewAttachNeoforgeToBuildRequestWithBody generates requests for AttachNeoforgeToBuild with any type of body
func NewAttachNeoforgeToBuildRequestWithBody(server string, neoforgeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "neoforge_id", runtime.ParamLocationPath, neoforgeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/neoforge/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPacksRequest generates requests for ListPacks
func NewListPacksRequest(server string, params *ListPacksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePackRequest calls the generic CreatePack builder with application/json body
func NewCreatePackRequest(server string, body CreatePackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePackRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePackRequestWithBody generates requests for CreatePack with any type of body
func NewCreatePackRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePackRequest generates requests for DeletePack
func NewDeletePackRequest(server string, packId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowPackRequest generates requests for ShowPack
func NewShowPackRequest(server string, packId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePackRequest calls the generic UpdatePack builder with application/json body
func NewUpdatePackRequest(server string, packId string, body UpdatePackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePackRequestWithBody(server, packId, "application/json", bodyReader)
}

// NewUpdatePackRequestWithBody generates requests for UpdatePack with any type of body
func NewUpdatePackRequestWithBody(server string, packId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBuildsRequest generates requests for ListBuilds
func NewListBuildsRequest(server string, packId string, params *ListBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBuildRequest calls the generic CreateBuild builder with application/json body
func NewCreateBuildRequest(server string, packId string, body CreateBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBuildRequestWithBody(server, packId, "application/json", bodyReader)
}

// NewCreateBuildRequestWithBody generates requests for CreateBuild with any type of body
func NewCreateBuildRequestWithBody(server string, packId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBuildRequest generates requests for DeleteBuild
func NewDeleteBuildRequest(server string, packId string, buildId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowBuildRequest generates requests for ShowBuild
func NewShowBuildRequest(server string, packId string, buildId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBuildRequest calls the generic UpdateBuild builder with application/json body
func NewUpdateBuildRequest(server string, packId string, buildId string, body UpdateBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBuildRequestWithBody(server, packId, buildId, "application/json", bodyReader)
}

// NewUpdateBuildRequestWithBody generates requests for UpdateBuild with any type of body
func NewUpdateBuildRequestWithBody(server string, packId string, buildId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBuildFromVersionRequest calls the generic DeleteBuildFromVersion builder with application/json body
func NewDeleteBuildFromVersionRequest(server string, packId string, buildId string, body DeleteBuildFromVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteBuildFromVersionRequestWithBody(server, packId, buildId, "application/json", bodyReader)
}

// NewDeleteBuildFromVersionRequestWithBody generates requests for DeleteBuildFromVersion with any type of body
func NewDeleteBuildFromVersionRequestWithBody(server string, packId string, buildId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds/%s/versions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBuildVersionsRequest generates requests for ListBuildVersions
func NewListBuildVersionsRequest(server string, packId string, buildId string, params *ListBuildVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds/%s/versions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachBuildToVersionRequest calls the generic AttachBuildToVersion builder with application/json body
func NewAttachBuildToVersionRequest(server string, packId string, buildId string, body AttachBuildToVersionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachBuildToVersionRequestWithBody(server, packId, buildId, "application/json", bodyReader)
}

// NewAttachBuildToVersionRequestWithBody generates requests for AttachBuildToVersion with any type of body
func NewAttachBuildToVersionRequestWithBody(server string, packId string, buildId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/builds/%s/versions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePackFromTeamRequest calls the generic DeletePackFromTeam builder with application/json body
func NewDeletePackFromTeamRequest(server string, packId string, body DeletePackFromTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePackFromTeamRequestWithBody(server, packId, "application/json", bodyReader)
}

// NewDeletePackFromTeamRequestWithBody generates requests for DeletePackFromTeam with any type of body
func NewDeletePackFromTeamRequestWithBody(server string, packId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPackTeamsRequest generates requests for ListPackTeams
func NewListPackTeamsRequest(server string, packId string, params *ListPackTeamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachPackToTeamRequest calls the generic AttachPackToTeam builder with application/json body
func NewAttachPackToTeamRequest(server string, packId string, body AttachPackToTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachPackToTeamRequestWithBody(server, packId, "application/json", bodyReader)
}

// NewAttachPackToTeamRequestWithBody generates requests for AttachPackToTeam with any type of body
func NewAttachPackToTeamRequestWithBody(server string, packId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitPackTeamRequest calls the generic PermitPackTeam builder with application/json body
func NewPermitPackTeamRequest(server string, packId string, body PermitPackTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitPackTeamRequestWithBody(server, packId, "application/json", bodyReader)
}

// NewPermitPackTeamRequestWithBody generates requests for PermitPackTeam with any type of body
func NewPermitPackTeamRequestWithBody(server string, packId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePackFromUserRequest calls the generic DeletePackFromUser builder with application/json body
func NewDeletePackFromUserRequest(server string, packId string, body DeletePackFromUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePackFromUserRequestWithBody(server, packId, "application/json", bodyReader)
}

// NewDeletePackFromUserRequestWithBody generates requests for DeletePackFromUser with any type of body
func NewDeletePackFromUserRequestWithBody(server string, packId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPackUsersRequest generates requests for ListPackUsers
func NewListPackUsersRequest(server string, packId string, params *ListPackUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachPackToUserRequest calls the generic AttachPackToUser builder with application/json body
func NewAttachPackToUserRequest(server string, packId string, body AttachPackToUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachPackToUserRequestWithBody(server, packId, "application/json", bodyReader)
}

// NewAttachPackToUserRequestWithBody generates requests for AttachPackToUser with any type of body
func NewAttachPackToUserRequestWithBody(server string, packId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitPackUserRequest calls the generic PermitPackUser builder with application/json body
func NewPermitPackUserRequest(server string, packId string, body PermitPackUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitPackUserRequestWithBody(server, packId, "application/json", bodyReader)
}

// NewPermitPackUserRequestWithBody generates requests for PermitPackUser with any type of body
func NewPermitPackUserRequestWithBody(server string, packId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pack_id", runtime.ParamLocationPath, packId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packs/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShowProfileRequest generates requests for ShowProfile
func NewShowProfileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile/self")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProfileRequest calls the generic UpdateProfile builder with application/json body
func NewUpdateProfileRequest(server string, body UpdateProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProfileRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateProfileRequestWithBody generates requests for UpdateProfile with any type of body
func NewUpdateProfileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile/self")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTokenProfileRequest generates requests for TokenProfile
func NewTokenProfileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profile/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListQuiltsRequest generates requests for ListQuilts
func NewListQuiltsRequest(server string, params *ListQuiltsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/quilt")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateQuiltRequest generates requests for UpdateQuilt
func NewUpdateQuiltRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/quilt")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteQuiltFromBuildRequest calls the generic DeleteQuiltFromBuild builder with application/json body
func NewDeleteQuiltFromBuildRequest(server string, quiltId string, body DeleteQuiltFromBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteQuiltFromBuildRequestWithBody(server, quiltId, "application/json", bodyReader)
}

// NewDeleteQuiltFromBuildRequestWithBody generates requests for DeleteQuiltFromBuild with any type of body
func NewDeleteQuiltFromBuildRequestWithBody(server string, quiltId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "quilt_id", runtime.ParamLocationPath, quiltId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/quilt/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListQuiltBuildsRequest generates requests for ListQuiltBuilds
func NewListQuiltBuildsRequest(server string, quiltId string, params *ListQuiltBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "quilt_id", runtime.ParamLocationPath, quiltId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/quilt/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachQuiltToBuildRequest calls the generic AttachQuiltToBuild builder with application/json body
func NewAttachQuiltToBuildRequest(server string, quiltId string, body AttachQuiltToBuildJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachQuiltToBuildRequestWithBody(server, quiltId, "application/json", bodyReader)
}

// NewAttachQuiltToBuildRequestWithBody generates requests for AttachQuiltToBuild with any type of body
func NewAttachQuiltToBuildRequestWithBody(server string, quiltId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "quilt_id", runtime.ParamLocationPath, quiltId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/quilt/%s/builds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTeamsRequest generates requests for ListTeams
func NewListTeamsRequest(server string, params *ListTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTeamRequest calls the generic CreateTeam builder with application/json body
func NewCreateTeamRequest(server string, body CreateTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTeamRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTeamRequestWithBody generates requests for CreateTeam with any type of body
func NewCreateTeamRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTeamRequest generates requests for DeleteTeam
func NewDeleteTeamRequest(server string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowTeamRequest generates requests for ShowTeam
func NewShowTeamRequest(server string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTeamRequest calls the generic UpdateTeam builder with application/json body
func NewUpdateTeamRequest(server string, teamId string, body UpdateTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTeamRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewUpdateTeamRequestWithBody generates requests for UpdateTeam with any type of body
func NewUpdateTeamRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTeamFromModRequest calls the generic DeleteTeamFromMod builder with application/json body
func NewDeleteTeamFromModRequest(server string, teamId string, body DeleteTeamFromModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTeamFromModRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewDeleteTeamFromModRequestWithBody generates requests for DeleteTeamFromMod with any type of body
func NewDeleteTeamFromModRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTeamModsRequest generates requests for ListTeamMods
func NewListTeamModsRequest(server string, teamId string, params *ListTeamModsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachTeamToModRequest calls the generic AttachTeamToMod builder with application/json body
func NewAttachTeamToModRequest(server string, teamId string, body AttachTeamToModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachTeamToModRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewAttachTeamToModRequestWithBody generates requests for AttachTeamToMod with any type of body
func NewAttachTeamToModRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitTeamModRequest calls the generic PermitTeamMod builder with application/json body
func NewPermitTeamModRequest(server string, teamId string, body PermitTeamModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitTeamModRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewPermitTeamModRequestWithBody generates requests for PermitTeamMod with any type of body
func NewPermitTeamModRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTeamFromPackRequest calls the generic DeleteTeamFromPack builder with application/json body
func NewDeleteTeamFromPackRequest(server string, teamId string, body DeleteTeamFromPackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTeamFromPackRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewDeleteTeamFromPackRequestWithBody generates requests for DeleteTeamFromPack with any type of body
func NewDeleteTeamFromPackRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTeamPacksRequest generates requests for ListTeamPacks
func NewListTeamPacksRequest(server string, teamId string, params *ListTeamPacksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachTeamToPackRequest calls the generic AttachTeamToPack builder with application/json body
func NewAttachTeamToPackRequest(server string, teamId string, body AttachTeamToPackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachTeamToPackRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewAttachTeamToPackRequestWithBody generates requests for AttachTeamToPack with any type of body
func NewAttachTeamToPackRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitTeamPackRequest calls the generic PermitTeamPack builder with application/json body
func NewPermitTeamPackRequest(server string, teamId string, body PermitTeamPackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitTeamPackRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewPermitTeamPackRequestWithBody generates requests for PermitTeamPack with any type of body
func NewPermitTeamPackRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTeamFromUserRequest calls the generic DeleteTeamFromUser builder with application/json body
func NewDeleteTeamFromUserRequest(server string, teamId string, body DeleteTeamFromUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTeamFromUserRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewDeleteTeamFromUserRequestWithBody generates requests for DeleteTeamFromUser with any type of body
func NewDeleteTeamFromUserRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTeamUsersRequest generates requests for ListTeamUsers
func NewListTeamUsersRequest(server string, teamId string, params *ListTeamUsersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachTeamToUserRequest calls the generic AttachTeamToUser builder with application/json body
func NewAttachTeamToUserRequest(server string, teamId string, body AttachTeamToUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachTeamToUserRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewAttachTeamToUserRequestWithBody generates requests for AttachTeamToUser with any type of body
func NewAttachTeamToUserRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitTeamUserRequest calls the generic PermitTeamUser builder with application/json body
func NewPermitTeamUserRequest(server string, teamId string, body PermitTeamUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitTeamUserRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewPermitTeamUserRequestWithBody generates requests for PermitTeamUser with any type of body
func NewPermitTeamUserRequestWithBody(server string, teamId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewShowUserRequest generates requests for ShowUser
func NewShowUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, userId string, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserFromModRequest calls the generic DeleteUserFromMod builder with application/json body
func NewDeleteUserFromModRequest(server string, userId string, body DeleteUserFromModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteUserFromModRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewDeleteUserFromModRequestWithBody generates requests for DeleteUserFromMod with any type of body
func NewDeleteUserFromModRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserModsRequest generates requests for ListUserMods
func NewListUserModsRequest(server string, userId string, params *ListUserModsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachUserToModRequest calls the generic AttachUserToMod builder with application/json body
func NewAttachUserToModRequest(server string, userId string, body AttachUserToModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachUserToModRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewAttachUserToModRequestWithBody generates requests for AttachUserToMod with any type of body
func NewAttachUserToModRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitUserModRequest calls the generic PermitUserMod builder with application/json body
func NewPermitUserModRequest(server string, userId string, body PermitUserModJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitUserModRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewPermitUserModRequestWithBody generates requests for PermitUserMod with any type of body
func NewPermitUserModRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/mods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserFromPackRequest calls the generic DeleteUserFromPack builder with application/json body
func NewDeleteUserFromPackRequest(server string, userId string, body DeleteUserFromPackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteUserFromPackRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewDeleteUserFromPackRequestWithBody generates requests for DeleteUserFromPack with any type of body
func NewDeleteUserFromPackRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserPacksRequest generates requests for ListUserPacks
func NewListUserPacksRequest(server string, userId string, params *ListUserPacksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachUserToPackRequest calls the generic AttachUserToPack builder with application/json body
func NewAttachUserToPackRequest(server string, userId string, body AttachUserToPackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachUserToPackRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewAttachUserToPackRequestWithBody generates requests for AttachUserToPack with any type of body
func NewAttachUserToPackRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitUserPackRequest calls the generic PermitUserPack builder with application/json body
func NewPermitUserPackRequest(server string, userId string, body PermitUserPackJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitUserPackRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewPermitUserPackRequestWithBody generates requests for PermitUserPack with any type of body
func NewPermitUserPackRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserFromTeamRequest calls the generic DeleteUserFromTeam builder with application/json body
func NewDeleteUserFromTeamRequest(server string, userId string, body DeleteUserFromTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteUserFromTeamRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewDeleteUserFromTeamRequestWithBody generates requests for DeleteUserFromTeam with any type of body
func NewDeleteUserFromTeamRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUserTeamsRequest generates requests for ListUserTeams
func NewListUserTeamsRequest(server string, userId string, params *ListUserTeamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAttachUserToTeamRequest calls the generic AttachUserToTeam builder with application/json body
func NewAttachUserToTeamRequest(server string, userId string, body AttachUserToTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAttachUserToTeamRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewAttachUserToTeamRequestWithBody generates requests for AttachUserToTeam with any type of body
func NewAttachUserToTeamRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPermitUserTeamRequest calls the generic PermitUserTeam builder with application/json body
func NewPermitUserTeamRequest(server string, userId string, body PermitUserTeamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPermitUserTeamRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewPermitUserTeamRequestWithBody generates requests for PermitUserTeam with any type of body
func NewPermitUserTeamRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// LoginAuthWithBodyWithResponse request with any body
	LoginAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginAuthResponse, error)

	LoginAuthWithResponse(ctx context.Context, body LoginAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginAuthResponse, error)

	// ExternalProvidersWithResponse request
	ExternalProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExternalProvidersResponse, error)

	// RefreshAuthWithResponse request
	RefreshAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RefreshAuthResponse, error)

	// VerifyAuthWithResponse request
	VerifyAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VerifyAuthResponse, error)

	// ExternalCallbackWithResponse request
	ExternalCallbackWithResponse(ctx context.Context, provider string, params *ExternalCallbackParams, reqEditors ...RequestEditorFn) (*ExternalCallbackResponse, error)

	// ExternalInitializeWithResponse request
	ExternalInitializeWithResponse(ctx context.Context, provider string, params *ExternalInitializeParams, reqEditors ...RequestEditorFn) (*ExternalInitializeResponse, error)

	// ListFabricsWithResponse request
	ListFabricsWithResponse(ctx context.Context, params *ListFabricsParams, reqEditors ...RequestEditorFn) (*ListFabricsResponse, error)

	// UpdateFabricWithResponse request
	UpdateFabricWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateFabricResponse, error)

	// DeleteFabricFromBuildWithBodyWithResponse request with any body
	DeleteFabricFromBuildWithBodyWithResponse(ctx context.Context, fabricId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteFabricFromBuildResponse, error)

	DeleteFabricFromBuildWithResponse(ctx context.Context, fabricId string, body DeleteFabricFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteFabricFromBuildResponse, error)

	// ListFabricBuildsWithResponse request
	ListFabricBuildsWithResponse(ctx context.Context, fabricId string, params *ListFabricBuildsParams, reqEditors ...RequestEditorFn) (*ListFabricBuildsResponse, error)

	// AttachFabricToBuildWithBodyWithResponse request with any body
	AttachFabricToBuildWithBodyWithResponse(ctx context.Context, fabricId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachFabricToBuildResponse, error)

	AttachFabricToBuildWithResponse(ctx context.Context, fabricId string, body AttachFabricToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachFabricToBuildResponse, error)

	// ListForgesWithResponse request
	ListForgesWithResponse(ctx context.Context, params *ListForgesParams, reqEditors ...RequestEditorFn) (*ListForgesResponse, error)

	// UpdateForgeWithResponse request
	UpdateForgeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateForgeResponse, error)

	// DeleteForgeFromBuildWithBodyWithResponse request with any body
	DeleteForgeFromBuildWithBodyWithResponse(ctx context.Context, forgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteForgeFromBuildResponse, error)

	DeleteForgeFromBuildWithResponse(ctx context.Context, forgeId string, body DeleteForgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteForgeFromBuildResponse, error)

	// ListForgeBuildsWithResponse request
	ListForgeBuildsWithResponse(ctx context.Context, forgeId string, params *ListForgeBuildsParams, reqEditors ...RequestEditorFn) (*ListForgeBuildsResponse, error)

	// AttachForgeToBuildWithBodyWithResponse request with any body
	AttachForgeToBuildWithBodyWithResponse(ctx context.Context, forgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachForgeToBuildResponse, error)

	AttachForgeToBuildWithResponse(ctx context.Context, forgeId string, body AttachForgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachForgeToBuildResponse, error)

	// ListMinecraftsWithResponse request
	ListMinecraftsWithResponse(ctx context.Context, params *ListMinecraftsParams, reqEditors ...RequestEditorFn) (*ListMinecraftsResponse, error)

	// UpdateMinecraftWithResponse request
	UpdateMinecraftWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateMinecraftResponse, error)

	// DeleteMinecraftFromBuildWithBodyWithResponse request with any body
	DeleteMinecraftFromBuildWithBodyWithResponse(ctx context.Context, minecraftId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteMinecraftFromBuildResponse, error)

	DeleteMinecraftFromBuildWithResponse(ctx context.Context, minecraftId string, body DeleteMinecraftFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteMinecraftFromBuildResponse, error)

	// ListMinecraftBuildsWithResponse request
	ListMinecraftBuildsWithResponse(ctx context.Context, minecraftId string, params *ListMinecraftBuildsParams, reqEditors ...RequestEditorFn) (*ListMinecraftBuildsResponse, error)

	// AttachMinecraftToBuildWithBodyWithResponse request with any body
	AttachMinecraftToBuildWithBodyWithResponse(ctx context.Context, minecraftId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachMinecraftToBuildResponse, error)

	AttachMinecraftToBuildWithResponse(ctx context.Context, minecraftId string, body AttachMinecraftToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachMinecraftToBuildResponse, error)

	// ListModsWithResponse request
	ListModsWithResponse(ctx context.Context, params *ListModsParams, reqEditors ...RequestEditorFn) (*ListModsResponse, error)

	// CreateModWithBodyWithResponse request with any body
	CreateModWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModResponse, error)

	CreateModWithResponse(ctx context.Context, body CreateModJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModResponse, error)

	// DeleteModWithResponse request
	DeleteModWithResponse(ctx context.Context, modId string, reqEditors ...RequestEditorFn) (*DeleteModResponse, error)

	// ShowModWithResponse request
	ShowModWithResponse(ctx context.Context, modId string, reqEditors ...RequestEditorFn) (*ShowModResponse, error)

	// UpdateModWithBodyWithResponse request with any body
	UpdateModWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateModResponse, error)

	UpdateModWithResponse(ctx context.Context, modId string, body UpdateModJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateModResponse, error)

	// DeleteModFromTeamWithBodyWithResponse request with any body
	DeleteModFromTeamWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteModFromTeamResponse, error)

	DeleteModFromTeamWithResponse(ctx context.Context, modId string, body DeleteModFromTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteModFromTeamResponse, error)

	// ListModTeamsWithResponse request
	ListModTeamsWithResponse(ctx context.Context, modId string, params *ListModTeamsParams, reqEditors ...RequestEditorFn) (*ListModTeamsResponse, error)

	// AttachModToTeamWithBodyWithResponse request with any body
	AttachModToTeamWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachModToTeamResponse, error)

	AttachModToTeamWithResponse(ctx context.Context, modId string, body AttachModToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachModToTeamResponse, error)

	// PermitModTeamWithBodyWithResponse request with any body
	PermitModTeamWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitModTeamResponse, error)

	PermitModTeamWithResponse(ctx context.Context, modId string, body PermitModTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitModTeamResponse, error)

	// DeleteModFromUserWithBodyWithResponse request with any body
	DeleteModFromUserWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteModFromUserResponse, error)

	DeleteModFromUserWithResponse(ctx context.Context, modId string, body DeleteModFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteModFromUserResponse, error)

	// ListModUsersWithResponse request
	ListModUsersWithResponse(ctx context.Context, modId string, params *ListModUsersParams, reqEditors ...RequestEditorFn) (*ListModUsersResponse, error)

	// AttachModToUserWithBodyWithResponse request with any body
	AttachModToUserWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachModToUserResponse, error)

	AttachModToUserWithResponse(ctx context.Context, modId string, body AttachModToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachModToUserResponse, error)

	// PermitModUserWithBodyWithResponse request with any body
	PermitModUserWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitModUserResponse, error)

	PermitModUserWithResponse(ctx context.Context, modId string, body PermitModUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitModUserResponse, error)

	// ListVersionsWithResponse request
	ListVersionsWithResponse(ctx context.Context, modId string, params *ListVersionsParams, reqEditors ...RequestEditorFn) (*ListVersionsResponse, error)

	// CreateVersionWithBodyWithResponse request with any body
	CreateVersionWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVersionResponse, error)

	CreateVersionWithResponse(ctx context.Context, modId string, body CreateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVersionResponse, error)

	// DeleteVersionWithResponse request
	DeleteVersionWithResponse(ctx context.Context, modId string, versionId string, reqEditors ...RequestEditorFn) (*DeleteVersionResponse, error)

	// ShowVersionWithResponse request
	ShowVersionWithResponse(ctx context.Context, modId string, versionId string, reqEditors ...RequestEditorFn) (*ShowVersionResponse, error)

	// UpdateVersionWithBodyWithResponse request with any body
	UpdateVersionWithBodyWithResponse(ctx context.Context, modId string, versionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVersionResponse, error)

	UpdateVersionWithResponse(ctx context.Context, modId string, versionId string, body UpdateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVersionResponse, error)

	// DeleteVersionFromBuildWithBodyWithResponse request with any body
	DeleteVersionFromBuildWithBodyWithResponse(ctx context.Context, modId string, versionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVersionFromBuildResponse, error)

	DeleteVersionFromBuildWithResponse(ctx context.Context, modId string, versionId string, body DeleteVersionFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVersionFromBuildResponse, error)

	// ListVersionBuildsWithResponse request
	ListVersionBuildsWithResponse(ctx context.Context, modId string, versionId string, params *ListVersionBuildsParams, reqEditors ...RequestEditorFn) (*ListVersionBuildsResponse, error)

	// AttachVersionToBuildWithBodyWithResponse request with any body
	AttachVersionToBuildWithBodyWithResponse(ctx context.Context, modId string, versionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachVersionToBuildResponse, error)

	AttachVersionToBuildWithResponse(ctx context.Context, modId string, versionId string, body AttachVersionToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachVersionToBuildResponse, error)

	// ListNeoforgesWithResponse request
	ListNeoforgesWithResponse(ctx context.Context, params *ListNeoforgesParams, reqEditors ...RequestEditorFn) (*ListNeoforgesResponse, error)

	// UpdateNeoforgeWithResponse request
	UpdateNeoforgeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateNeoforgeResponse, error)

	// DeleteNeoforgeFromBuildWithBodyWithResponse request with any body
	DeleteNeoforgeFromBuildWithBodyWithResponse(ctx context.Context, neoforgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteNeoforgeFromBuildResponse, error)

	DeleteNeoforgeFromBuildWithResponse(ctx context.Context, neoforgeId string, body DeleteNeoforgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteNeoforgeFromBuildResponse, error)

	// ListNeoforgeBuildsWithResponse request
	ListNeoforgeBuildsWithResponse(ctx context.Context, neoforgeId string, params *ListNeoforgeBuildsParams, reqEditors ...RequestEditorFn) (*ListNeoforgeBuildsResponse, error)

	// AttachNeoforgeToBuildWithBodyWithResponse request with any body
	AttachNeoforgeToBuildWithBodyWithResponse(ctx context.Context, neoforgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachNeoforgeToBuildResponse, error)

	AttachNeoforgeToBuildWithResponse(ctx context.Context, neoforgeId string, body AttachNeoforgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachNeoforgeToBuildResponse, error)

	// ListPacksWithResponse request
	ListPacksWithResponse(ctx context.Context, params *ListPacksParams, reqEditors ...RequestEditorFn) (*ListPacksResponse, error)

	// CreatePackWithBodyWithResponse request with any body
	CreatePackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePackResponse, error)

	CreatePackWithResponse(ctx context.Context, body CreatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePackResponse, error)

	// DeletePackWithResponse request
	DeletePackWithResponse(ctx context.Context, packId string, reqEditors ...RequestEditorFn) (*DeletePackResponse, error)

	// ShowPackWithResponse request
	ShowPackWithResponse(ctx context.Context, packId string, reqEditors ...RequestEditorFn) (*ShowPackResponse, error)

	// UpdatePackWithBodyWithResponse request with any body
	UpdatePackWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePackResponse, error)

	UpdatePackWithResponse(ctx context.Context, packId string, body UpdatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePackResponse, error)

	// ListBuildsWithResponse request
	ListBuildsWithResponse(ctx context.Context, packId string, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*ListBuildsResponse, error)

	// CreateBuildWithBodyWithResponse request with any body
	CreateBuildWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBuildResponse, error)

	CreateBuildWithResponse(ctx context.Context, packId string, body CreateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBuildResponse, error)

	// DeleteBuildWithResponse request
	DeleteBuildWithResponse(ctx context.Context, packId string, buildId string, reqEditors ...RequestEditorFn) (*DeleteBuildResponse, error)

	// ShowBuildWithResponse request
	ShowBuildWithResponse(ctx context.Context, packId string, buildId string, reqEditors ...RequestEditorFn) (*ShowBuildResponse, error)

	// UpdateBuildWithBodyWithResponse request with any body
	UpdateBuildWithBodyWithResponse(ctx context.Context, packId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBuildResponse, error)

	UpdateBuildWithResponse(ctx context.Context, packId string, buildId string, body UpdateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBuildResponse, error)

	// DeleteBuildFromVersionWithBodyWithResponse request with any body
	DeleteBuildFromVersionWithBodyWithResponse(ctx context.Context, packId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteBuildFromVersionResponse, error)

	DeleteBuildFromVersionWithResponse(ctx context.Context, packId string, buildId string, body DeleteBuildFromVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteBuildFromVersionResponse, error)

	// ListBuildVersionsWithResponse request
	ListBuildVersionsWithResponse(ctx context.Context, packId string, buildId string, params *ListBuildVersionsParams, reqEditors ...RequestEditorFn) (*ListBuildVersionsResponse, error)

	// AttachBuildToVersionWithBodyWithResponse request with any body
	AttachBuildToVersionWithBodyWithResponse(ctx context.Context, packId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachBuildToVersionResponse, error)

	AttachBuildToVersionWithResponse(ctx context.Context, packId string, buildId string, body AttachBuildToVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachBuildToVersionResponse, error)

	// DeletePackFromTeamWithBodyWithResponse request with any body
	DeletePackFromTeamWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePackFromTeamResponse, error)

	DeletePackFromTeamWithResponse(ctx context.Context, packId string, body DeletePackFromTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePackFromTeamResponse, error)

	// ListPackTeamsWithResponse request
	ListPackTeamsWithResponse(ctx context.Context, packId string, params *ListPackTeamsParams, reqEditors ...RequestEditorFn) (*ListPackTeamsResponse, error)

	// AttachPackToTeamWithBodyWithResponse request with any body
	AttachPackToTeamWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachPackToTeamResponse, error)

	AttachPackToTeamWithResponse(ctx context.Context, packId string, body AttachPackToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachPackToTeamResponse, error)

	// PermitPackTeamWithBodyWithResponse request with any body
	PermitPackTeamWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitPackTeamResponse, error)

	PermitPackTeamWithResponse(ctx context.Context, packId string, body PermitPackTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitPackTeamResponse, error)

	// DeletePackFromUserWithBodyWithResponse request with any body
	DeletePackFromUserWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePackFromUserResponse, error)

	DeletePackFromUserWithResponse(ctx context.Context, packId string, body DeletePackFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePackFromUserResponse, error)

	// ListPackUsersWithResponse request
	ListPackUsersWithResponse(ctx context.Context, packId string, params *ListPackUsersParams, reqEditors ...RequestEditorFn) (*ListPackUsersResponse, error)

	// AttachPackToUserWithBodyWithResponse request with any body
	AttachPackToUserWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachPackToUserResponse, error)

	AttachPackToUserWithResponse(ctx context.Context, packId string, body AttachPackToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachPackToUserResponse, error)

	// PermitPackUserWithBodyWithResponse request with any body
	PermitPackUserWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitPackUserResponse, error)

	PermitPackUserWithResponse(ctx context.Context, packId string, body PermitPackUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitPackUserResponse, error)

	// ShowProfileWithResponse request
	ShowProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ShowProfileResponse, error)

	// UpdateProfileWithBodyWithResponse request with any body
	UpdateProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error)

	UpdateProfileWithResponse(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error)

	// TokenProfileWithResponse request
	TokenProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TokenProfileResponse, error)

	// ListQuiltsWithResponse request
	ListQuiltsWithResponse(ctx context.Context, params *ListQuiltsParams, reqEditors ...RequestEditorFn) (*ListQuiltsResponse, error)

	// UpdateQuiltWithResponse request
	UpdateQuiltWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateQuiltResponse, error)

	// DeleteQuiltFromBuildWithBodyWithResponse request with any body
	DeleteQuiltFromBuildWithBodyWithResponse(ctx context.Context, quiltId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteQuiltFromBuildResponse, error)

	DeleteQuiltFromBuildWithResponse(ctx context.Context, quiltId string, body DeleteQuiltFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteQuiltFromBuildResponse, error)

	// ListQuiltBuildsWithResponse request
	ListQuiltBuildsWithResponse(ctx context.Context, quiltId string, params *ListQuiltBuildsParams, reqEditors ...RequestEditorFn) (*ListQuiltBuildsResponse, error)

	// AttachQuiltToBuildWithBodyWithResponse request with any body
	AttachQuiltToBuildWithBodyWithResponse(ctx context.Context, quiltId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachQuiltToBuildResponse, error)

	AttachQuiltToBuildWithResponse(ctx context.Context, quiltId string, body AttachQuiltToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachQuiltToBuildResponse, error)

	// ListTeamsWithResponse request
	ListTeamsWithResponse(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*ListTeamsResponse, error)

	// CreateTeamWithBodyWithResponse request with any body
	CreateTeamWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error)

	CreateTeamWithResponse(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error)

	// DeleteTeamWithResponse request
	DeleteTeamWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*DeleteTeamResponse, error)

	// ShowTeamWithResponse request
	ShowTeamWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*ShowTeamResponse, error)

	// UpdateTeamWithBodyWithResponse request with any body
	UpdateTeamWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error)

	UpdateTeamWithResponse(ctx context.Context, teamId string, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error)

	// DeleteTeamFromModWithBodyWithResponse request with any body
	DeleteTeamFromModWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTeamFromModResponse, error)

	DeleteTeamFromModWithResponse(ctx context.Context, teamId string, body DeleteTeamFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTeamFromModResponse, error)

	// ListTeamModsWithResponse request
	ListTeamModsWithResponse(ctx context.Context, teamId string, params *ListTeamModsParams, reqEditors ...RequestEditorFn) (*ListTeamModsResponse, error)

	// AttachTeamToModWithBodyWithResponse request with any body
	AttachTeamToModWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachTeamToModResponse, error)

	AttachTeamToModWithResponse(ctx context.Context, teamId string, body AttachTeamToModJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachTeamToModResponse, error)

	// PermitTeamModWithBodyWithResponse request with any body
	PermitTeamModWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitTeamModResponse, error)

	PermitTeamModWithResponse(ctx context.Context, teamId string, body PermitTeamModJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitTeamModResponse, error)

	// DeleteTeamFromPackWithBodyWithResponse request with any body
	DeleteTeamFromPackWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTeamFromPackResponse, error)

	DeleteTeamFromPackWithResponse(ctx context.Context, teamId string, body DeleteTeamFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTeamFromPackResponse, error)

	// ListTeamPacksWithResponse request
	ListTeamPacksWithResponse(ctx context.Context, teamId string, params *ListTeamPacksParams, reqEditors ...RequestEditorFn) (*ListTeamPacksResponse, error)

	// AttachTeamToPackWithBodyWithResponse request with any body
	AttachTeamToPackWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachTeamToPackResponse, error)

	AttachTeamToPackWithResponse(ctx context.Context, teamId string, body AttachTeamToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachTeamToPackResponse, error)

	// PermitTeamPackWithBodyWithResponse request with any body
	PermitTeamPackWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitTeamPackResponse, error)

	PermitTeamPackWithResponse(ctx context.Context, teamId string, body PermitTeamPackJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitTeamPackResponse, error)

	// DeleteTeamFromUserWithBodyWithResponse request with any body
	DeleteTeamFromUserWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTeamFromUserResponse, error)

	DeleteTeamFromUserWithResponse(ctx context.Context, teamId string, body DeleteTeamFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTeamFromUserResponse, error)

	// ListTeamUsersWithResponse request
	ListTeamUsersWithResponse(ctx context.Context, teamId string, params *ListTeamUsersParams, reqEditors ...RequestEditorFn) (*ListTeamUsersResponse, error)

	// AttachTeamToUserWithBodyWithResponse request with any body
	AttachTeamToUserWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachTeamToUserResponse, error)

	AttachTeamToUserWithResponse(ctx context.Context, teamId string, body AttachTeamToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachTeamToUserResponse, error)

	// PermitTeamUserWithBodyWithResponse request with any body
	PermitTeamUserWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitTeamUserResponse, error)

	PermitTeamUserWithResponse(ctx context.Context, teamId string, body PermitTeamUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitTeamUserResponse, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// ShowUserWithResponse request
	ShowUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*ShowUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// DeleteUserFromModWithBodyWithResponse request with any body
	DeleteUserFromModWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromModResponse, error)

	DeleteUserFromModWithResponse(ctx context.Context, userId string, body DeleteUserFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromModResponse, error)

	// ListUserModsWithResponse request
	ListUserModsWithResponse(ctx context.Context, userId string, params *ListUserModsParams, reqEditors ...RequestEditorFn) (*ListUserModsResponse, error)

	// AttachUserToModWithBodyWithResponse request with any body
	AttachUserToModWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToModResponse, error)

	AttachUserToModWithResponse(ctx context.Context, userId string, body AttachUserToModJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToModResponse, error)

	// PermitUserModWithBodyWithResponse request with any body
	PermitUserModWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserModResponse, error)

	PermitUserModWithResponse(ctx context.Context, userId string, body PermitUserModJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserModResponse, error)

	// DeleteUserFromPackWithBodyWithResponse request with any body
	DeleteUserFromPackWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromPackResponse, error)

	DeleteUserFromPackWithResponse(ctx context.Context, userId string, body DeleteUserFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromPackResponse, error)

	// ListUserPacksWithResponse request
	ListUserPacksWithResponse(ctx context.Context, userId string, params *ListUserPacksParams, reqEditors ...RequestEditorFn) (*ListUserPacksResponse, error)

	// AttachUserToPackWithBodyWithResponse request with any body
	AttachUserToPackWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToPackResponse, error)

	AttachUserToPackWithResponse(ctx context.Context, userId string, body AttachUserToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToPackResponse, error)

	// PermitUserPackWithBodyWithResponse request with any body
	PermitUserPackWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserPackResponse, error)

	PermitUserPackWithResponse(ctx context.Context, userId string, body PermitUserPackJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserPackResponse, error)

	// DeleteUserFromTeamWithBodyWithResponse request with any body
	DeleteUserFromTeamWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromTeamResponse, error)

	DeleteUserFromTeamWithResponse(ctx context.Context, userId string, body DeleteUserFromTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromTeamResponse, error)

	// ListUserTeamsWithResponse request
	ListUserTeamsWithResponse(ctx context.Context, userId string, params *ListUserTeamsParams, reqEditors ...RequestEditorFn) (*ListUserTeamsResponse, error)

	// AttachUserToTeamWithBodyWithResponse request with any body
	AttachUserToTeamWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToTeamResponse, error)

	AttachUserToTeamWithResponse(ctx context.Context, userId string, body AttachUserToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToTeamResponse, error)

	// PermitUserTeamWithBodyWithResponse request with any body
	PermitUserTeamWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserTeamResponse, error)

	PermitUserTeamWithResponse(ctx context.Context, userId string, body PermitUserTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserTeamResponse, error)
}

type LoginAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthToken
	JSON401      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r LoginAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExternalProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Providers
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ExternalProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExternalProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthToken
	JSON401      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r RefreshAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyAuthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthVerify
	JSON401      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r VerifyAuthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyAuthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExternalCallbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Notification
	JSON412      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ExternalCallbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExternalCallbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExternalInitializeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Notification
	JSON412      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ExternalInitializeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExternalInitializeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFabricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Fabrics
	JSON403      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListFabricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFabricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFabricResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON500      *Notification
	JSON503      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r UpdateFabricResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFabricResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFabricFromBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteFabricFromBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFabricFromBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFabricBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FabricBuilds
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListFabricBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFabricBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachFabricToBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachFabricToBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachFabricToBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListForgesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Forges
	JSON403      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListForgesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListForgesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateForgeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON500      *Notification
	JSON503      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r UpdateForgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateForgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteForgeFromBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteForgeFromBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteForgeFromBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListForgeBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ForgeBuilds
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListForgeBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListForgeBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachForgeToBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachForgeToBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachForgeToBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMinecraftsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Minecrafts
	JSON403      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListMinecraftsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMinecraftsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMinecraftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON500      *Notification
	JSON503      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r UpdateMinecraftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMinecraftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMinecraftFromBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteMinecraftFromBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMinecraftFromBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMinecraftBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MinecraftBuilds
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListMinecraftBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMinecraftBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachMinecraftToBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachMinecraftToBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachMinecraftToBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Mods
	JSON403      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListModsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Mod
	JSON403      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r CreateModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON400      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Mod
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ShowModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Mod
	JSON403      *Notification
	JSON404      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r UpdateModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteModFromTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteModFromTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteModFromTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModTeams
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListModTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachModToTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachModToTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachModToTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitModTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r PermitModTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitModTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteModFromUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteModFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteModFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListModUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ModUsers
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListModUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachModToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachModToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachModToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitModUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r PermitModUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitModUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Versions
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Version
	JSON403      *Notification
	JSON404      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r CreateVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON400      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Version
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ShowVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Version
	JSON403      *Notification
	JSON404      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r UpdateVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVersionFromBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteVersionFromBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVersionFromBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVersionBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionBuilds
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListVersionBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVersionBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachVersionToBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachVersionToBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachVersionToBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNeoforgesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Neoforges
	JSON403      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListNeoforgesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNeoforgesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNeoforgeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON500      *Notification
	JSON503      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r UpdateNeoforgeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNeoforgeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNeoforgeFromBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteNeoforgeFromBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNeoforgeFromBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNeoforgeBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NeoforgeBuilds
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListNeoforgeBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNeoforgeBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachNeoforgeToBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachNeoforgeToBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachNeoforgeToBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPacksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Packs
	JSON403      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListPacksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPacksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Pack
	JSON403      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r CreatePackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON400      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeletePackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowPackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Pack
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ShowPackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowPackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Pack
	JSON403      *Notification
	JSON404      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r UpdatePackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Builds
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Build
	JSON403      *Notification
	JSON404      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r CreateBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON400      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Build
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ShowBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Build
	JSON403      *Notification
	JSON404      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r UpdateBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBuildFromVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteBuildFromVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBuildFromVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBuildVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BuildVersions
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListBuildVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBuildVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachBuildToVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachBuildToVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachBuildToVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePackFromTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeletePackFromTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePackFromTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPackTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackTeams
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListPackTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPackTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachPackToTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachPackToTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachPackToTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitPackTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r PermitPackTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitPackTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePackFromUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeletePackFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePackFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPackUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackUsers
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListPackUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPackUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachPackToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachPackToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachPackToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitPackUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r PermitPackUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitPackUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Profile
	JSON403      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ShowProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Profile
	JSON403      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r UpdateProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokenProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthToken
	JSON403      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r TokenProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokenProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListQuiltsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Quilts
	JSON403      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListQuiltsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListQuiltsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateQuiltResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON500      *Notification
	JSON503      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r UpdateQuiltResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateQuiltResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteQuiltFromBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteQuiltFromBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteQuiltFromBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListQuiltBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuiltBuilds
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListQuiltBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListQuiltBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachQuiltToBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachQuiltToBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachQuiltToBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Teams
	JSON403      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON403      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r CreateTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON400      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ShowTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON403      *Notification
	JSON404      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r UpdateTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTeamFromModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteTeamFromModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTeamFromModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTeamModsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamMods
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListTeamModsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTeamModsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachTeamToModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachTeamToModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachTeamToModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitTeamModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r PermitTeamModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitTeamModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTeamFromPackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteTeamFromPackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTeamFromPackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTeamPacksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamPacks
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListTeamPacksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTeamPacksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachTeamToPackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachTeamToPackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachTeamToPackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitTeamPackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r PermitTeamPackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitTeamPackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTeamFromUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteTeamFromUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTeamFromUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTeamUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamUsers
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListTeamUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTeamUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachTeamToUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachTeamToUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachTeamToUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitTeamUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r PermitTeamUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitTeamUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Users
	JSON403      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON403      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON400      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ShowUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON403      *Notification
	JSON404      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserFromModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteUserFromModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserFromModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserModsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserMods
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListUserModsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserModsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachUserToModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachUserToModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachUserToModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitUserModResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r PermitUserModResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitUserModResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserFromPackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteUserFromPackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserFromPackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserPacksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserPacks
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListUserPacksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserPacksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachUserToPackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachUserToPackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachUserToPackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitUserPackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r PermitUserPackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitUserPackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserFromTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r DeleteUserFromTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserFromTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserTeams
	JSON403      *Notification
	JSON404      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r ListUserTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AttachUserToTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r AttachUserToTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AttachUserToTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PermitUserTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Notification
	JSON403      *Notification
	JSON404      *Notification
	JSON412      *Notification
	JSON422      *Notification
	JSON500      *Notification
	JSONDefault  *Notification
}

// Status returns HTTPResponse.Status
func (r PermitUserTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PermitUserTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// LoginAuthWithBodyWithResponse request with arbitrary body returning *LoginAuthResponse
func (c *ClientWithResponses) LoginAuthWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginAuthResponse, error) {
	rsp, err := c.LoginAuthWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginAuthResponse(rsp)
}

func (c *ClientWithResponses) LoginAuthWithResponse(ctx context.Context, body LoginAuthJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginAuthResponse, error) {
	rsp, err := c.LoginAuth(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginAuthResponse(rsp)
}

// ExternalProvidersWithResponse request returning *ExternalProvidersResponse
func (c *ClientWithResponses) ExternalProvidersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ExternalProvidersResponse, error) {
	rsp, err := c.ExternalProviders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExternalProvidersResponse(rsp)
}

// RefreshAuthWithResponse request returning *RefreshAuthResponse
func (c *ClientWithResponses) RefreshAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RefreshAuthResponse, error) {
	rsp, err := c.RefreshAuth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshAuthResponse(rsp)
}

// VerifyAuthWithResponse request returning *VerifyAuthResponse
func (c *ClientWithResponses) VerifyAuthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*VerifyAuthResponse, error) {
	rsp, err := c.VerifyAuth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyAuthResponse(rsp)
}

// ExternalCallbackWithResponse request returning *ExternalCallbackResponse
func (c *ClientWithResponses) ExternalCallbackWithResponse(ctx context.Context, provider string, params *ExternalCallbackParams, reqEditors ...RequestEditorFn) (*ExternalCallbackResponse, error) {
	rsp, err := c.ExternalCallback(ctx, provider, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExternalCallbackResponse(rsp)
}

// ExternalInitializeWithResponse request returning *ExternalInitializeResponse
func (c *ClientWithResponses) ExternalInitializeWithResponse(ctx context.Context, provider string, params *ExternalInitializeParams, reqEditors ...RequestEditorFn) (*ExternalInitializeResponse, error) {
	rsp, err := c.ExternalInitialize(ctx, provider, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExternalInitializeResponse(rsp)
}

// ListFabricsWithResponse request returning *ListFabricsResponse
func (c *ClientWithResponses) ListFabricsWithResponse(ctx context.Context, params *ListFabricsParams, reqEditors ...RequestEditorFn) (*ListFabricsResponse, error) {
	rsp, err := c.ListFabrics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFabricsResponse(rsp)
}

// UpdateFabricWithResponse request returning *UpdateFabricResponse
func (c *ClientWithResponses) UpdateFabricWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateFabricResponse, error) {
	rsp, err := c.UpdateFabric(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFabricResponse(rsp)
}

// DeleteFabricFromBuildWithBodyWithResponse request with arbitrary body returning *DeleteFabricFromBuildResponse
func (c *ClientWithResponses) DeleteFabricFromBuildWithBodyWithResponse(ctx context.Context, fabricId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteFabricFromBuildResponse, error) {
	rsp, err := c.DeleteFabricFromBuildWithBody(ctx, fabricId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFabricFromBuildResponse(rsp)
}

func (c *ClientWithResponses) DeleteFabricFromBuildWithResponse(ctx context.Context, fabricId string, body DeleteFabricFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteFabricFromBuildResponse, error) {
	rsp, err := c.DeleteFabricFromBuild(ctx, fabricId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFabricFromBuildResponse(rsp)
}

// ListFabricBuildsWithResponse request returning *ListFabricBuildsResponse
func (c *ClientWithResponses) ListFabricBuildsWithResponse(ctx context.Context, fabricId string, params *ListFabricBuildsParams, reqEditors ...RequestEditorFn) (*ListFabricBuildsResponse, error) {
	rsp, err := c.ListFabricBuilds(ctx, fabricId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFabricBuildsResponse(rsp)
}

// AttachFabricToBuildWithBodyWithResponse request with arbitrary body returning *AttachFabricToBuildResponse
func (c *ClientWithResponses) AttachFabricToBuildWithBodyWithResponse(ctx context.Context, fabricId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachFabricToBuildResponse, error) {
	rsp, err := c.AttachFabricToBuildWithBody(ctx, fabricId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachFabricToBuildResponse(rsp)
}

func (c *ClientWithResponses) AttachFabricToBuildWithResponse(ctx context.Context, fabricId string, body AttachFabricToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachFabricToBuildResponse, error) {
	rsp, err := c.AttachFabricToBuild(ctx, fabricId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachFabricToBuildResponse(rsp)
}

// ListForgesWithResponse request returning *ListForgesResponse
func (c *ClientWithResponses) ListForgesWithResponse(ctx context.Context, params *ListForgesParams, reqEditors ...RequestEditorFn) (*ListForgesResponse, error) {
	rsp, err := c.ListForges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListForgesResponse(rsp)
}

// UpdateForgeWithResponse request returning *UpdateForgeResponse
func (c *ClientWithResponses) UpdateForgeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateForgeResponse, error) {
	rsp, err := c.UpdateForge(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateForgeResponse(rsp)
}

// DeleteForgeFromBuildWithBodyWithResponse request with arbitrary body returning *DeleteForgeFromBuildResponse
func (c *ClientWithResponses) DeleteForgeFromBuildWithBodyWithResponse(ctx context.Context, forgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteForgeFromBuildResponse, error) {
	rsp, err := c.DeleteForgeFromBuildWithBody(ctx, forgeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteForgeFromBuildResponse(rsp)
}

func (c *ClientWithResponses) DeleteForgeFromBuildWithResponse(ctx context.Context, forgeId string, body DeleteForgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteForgeFromBuildResponse, error) {
	rsp, err := c.DeleteForgeFromBuild(ctx, forgeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteForgeFromBuildResponse(rsp)
}

// ListForgeBuildsWithResponse request returning *ListForgeBuildsResponse
func (c *ClientWithResponses) ListForgeBuildsWithResponse(ctx context.Context, forgeId string, params *ListForgeBuildsParams, reqEditors ...RequestEditorFn) (*ListForgeBuildsResponse, error) {
	rsp, err := c.ListForgeBuilds(ctx, forgeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListForgeBuildsResponse(rsp)
}

// AttachForgeToBuildWithBodyWithResponse request with arbitrary body returning *AttachForgeToBuildResponse
func (c *ClientWithResponses) AttachForgeToBuildWithBodyWithResponse(ctx context.Context, forgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachForgeToBuildResponse, error) {
	rsp, err := c.AttachForgeToBuildWithBody(ctx, forgeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachForgeToBuildResponse(rsp)
}

func (c *ClientWithResponses) AttachForgeToBuildWithResponse(ctx context.Context, forgeId string, body AttachForgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachForgeToBuildResponse, error) {
	rsp, err := c.AttachForgeToBuild(ctx, forgeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachForgeToBuildResponse(rsp)
}

// ListMinecraftsWithResponse request returning *ListMinecraftsResponse
func (c *ClientWithResponses) ListMinecraftsWithResponse(ctx context.Context, params *ListMinecraftsParams, reqEditors ...RequestEditorFn) (*ListMinecraftsResponse, error) {
	rsp, err := c.ListMinecrafts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMinecraftsResponse(rsp)
}

// UpdateMinecraftWithResponse request returning *UpdateMinecraftResponse
func (c *ClientWithResponses) UpdateMinecraftWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateMinecraftResponse, error) {
	rsp, err := c.UpdateMinecraft(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMinecraftResponse(rsp)
}

// DeleteMinecraftFromBuildWithBodyWithResponse request with arbitrary body returning *DeleteMinecraftFromBuildResponse
func (c *ClientWithResponses) DeleteMinecraftFromBuildWithBodyWithResponse(ctx context.Context, minecraftId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteMinecraftFromBuildResponse, error) {
	rsp, err := c.DeleteMinecraftFromBuildWithBody(ctx, minecraftId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMinecraftFromBuildResponse(rsp)
}

func (c *ClientWithResponses) DeleteMinecraftFromBuildWithResponse(ctx context.Context, minecraftId string, body DeleteMinecraftFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteMinecraftFromBuildResponse, error) {
	rsp, err := c.DeleteMinecraftFromBuild(ctx, minecraftId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMinecraftFromBuildResponse(rsp)
}

// ListMinecraftBuildsWithResponse request returning *ListMinecraftBuildsResponse
func (c *ClientWithResponses) ListMinecraftBuildsWithResponse(ctx context.Context, minecraftId string, params *ListMinecraftBuildsParams, reqEditors ...RequestEditorFn) (*ListMinecraftBuildsResponse, error) {
	rsp, err := c.ListMinecraftBuilds(ctx, minecraftId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMinecraftBuildsResponse(rsp)
}

// AttachMinecraftToBuildWithBodyWithResponse request with arbitrary body returning *AttachMinecraftToBuildResponse
func (c *ClientWithResponses) AttachMinecraftToBuildWithBodyWithResponse(ctx context.Context, minecraftId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachMinecraftToBuildResponse, error) {
	rsp, err := c.AttachMinecraftToBuildWithBody(ctx, minecraftId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachMinecraftToBuildResponse(rsp)
}

func (c *ClientWithResponses) AttachMinecraftToBuildWithResponse(ctx context.Context, minecraftId string, body AttachMinecraftToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachMinecraftToBuildResponse, error) {
	rsp, err := c.AttachMinecraftToBuild(ctx, minecraftId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachMinecraftToBuildResponse(rsp)
}

// ListModsWithResponse request returning *ListModsResponse
func (c *ClientWithResponses) ListModsWithResponse(ctx context.Context, params *ListModsParams, reqEditors ...RequestEditorFn) (*ListModsResponse, error) {
	rsp, err := c.ListMods(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModsResponse(rsp)
}

// CreateModWithBodyWithResponse request with arbitrary body returning *CreateModResponse
func (c *ClientWithResponses) CreateModWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateModResponse, error) {
	rsp, err := c.CreateModWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModResponse(rsp)
}

func (c *ClientWithResponses) CreateModWithResponse(ctx context.Context, body CreateModJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateModResponse, error) {
	rsp, err := c.CreateMod(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateModResponse(rsp)
}

// DeleteModWithResponse request returning *DeleteModResponse
func (c *ClientWithResponses) DeleteModWithResponse(ctx context.Context, modId string, reqEditors ...RequestEditorFn) (*DeleteModResponse, error) {
	rsp, err := c.DeleteMod(ctx, modId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModResponse(rsp)
}

// ShowModWithResponse request returning *ShowModResponse
func (c *ClientWithResponses) ShowModWithResponse(ctx context.Context, modId string, reqEditors ...RequestEditorFn) (*ShowModResponse, error) {
	rsp, err := c.ShowMod(ctx, modId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowModResponse(rsp)
}

// UpdateModWithBodyWithResponse request with arbitrary body returning *UpdateModResponse
func (c *ClientWithResponses) UpdateModWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateModResponse, error) {
	rsp, err := c.UpdateModWithBody(ctx, modId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateModResponse(rsp)
}

func (c *ClientWithResponses) UpdateModWithResponse(ctx context.Context, modId string, body UpdateModJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateModResponse, error) {
	rsp, err := c.UpdateMod(ctx, modId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateModResponse(rsp)
}

// DeleteModFromTeamWithBodyWithResponse request with arbitrary body returning *DeleteModFromTeamResponse
func (c *ClientWithResponses) DeleteModFromTeamWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteModFromTeamResponse, error) {
	rsp, err := c.DeleteModFromTeamWithBody(ctx, modId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModFromTeamResponse(rsp)
}

func (c *ClientWithResponses) DeleteModFromTeamWithResponse(ctx context.Context, modId string, body DeleteModFromTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteModFromTeamResponse, error) {
	rsp, err := c.DeleteModFromTeam(ctx, modId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModFromTeamResponse(rsp)
}

// ListModTeamsWithResponse request returning *ListModTeamsResponse
func (c *ClientWithResponses) ListModTeamsWithResponse(ctx context.Context, modId string, params *ListModTeamsParams, reqEditors ...RequestEditorFn) (*ListModTeamsResponse, error) {
	rsp, err := c.ListModTeams(ctx, modId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModTeamsResponse(rsp)
}

// AttachModToTeamWithBodyWithResponse request with arbitrary body returning *AttachModToTeamResponse
func (c *ClientWithResponses) AttachModToTeamWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachModToTeamResponse, error) {
	rsp, err := c.AttachModToTeamWithBody(ctx, modId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachModToTeamResponse(rsp)
}

func (c *ClientWithResponses) AttachModToTeamWithResponse(ctx context.Context, modId string, body AttachModToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachModToTeamResponse, error) {
	rsp, err := c.AttachModToTeam(ctx, modId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachModToTeamResponse(rsp)
}

// PermitModTeamWithBodyWithResponse request with arbitrary body returning *PermitModTeamResponse
func (c *ClientWithResponses) PermitModTeamWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitModTeamResponse, error) {
	rsp, err := c.PermitModTeamWithBody(ctx, modId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitModTeamResponse(rsp)
}

func (c *ClientWithResponses) PermitModTeamWithResponse(ctx context.Context, modId string, body PermitModTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitModTeamResponse, error) {
	rsp, err := c.PermitModTeam(ctx, modId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitModTeamResponse(rsp)
}

// DeleteModFromUserWithBodyWithResponse request with arbitrary body returning *DeleteModFromUserResponse
func (c *ClientWithResponses) DeleteModFromUserWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteModFromUserResponse, error) {
	rsp, err := c.DeleteModFromUserWithBody(ctx, modId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModFromUserResponse(rsp)
}

func (c *ClientWithResponses) DeleteModFromUserWithResponse(ctx context.Context, modId string, body DeleteModFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteModFromUserResponse, error) {
	rsp, err := c.DeleteModFromUser(ctx, modId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteModFromUserResponse(rsp)
}

// ListModUsersWithResponse request returning *ListModUsersResponse
func (c *ClientWithResponses) ListModUsersWithResponse(ctx context.Context, modId string, params *ListModUsersParams, reqEditors ...RequestEditorFn) (*ListModUsersResponse, error) {
	rsp, err := c.ListModUsers(ctx, modId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListModUsersResponse(rsp)
}

// AttachModToUserWithBodyWithResponse request with arbitrary body returning *AttachModToUserResponse
func (c *ClientWithResponses) AttachModToUserWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachModToUserResponse, error) {
	rsp, err := c.AttachModToUserWithBody(ctx, modId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachModToUserResponse(rsp)
}

func (c *ClientWithResponses) AttachModToUserWithResponse(ctx context.Context, modId string, body AttachModToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachModToUserResponse, error) {
	rsp, err := c.AttachModToUser(ctx, modId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachModToUserResponse(rsp)
}

// PermitModUserWithBodyWithResponse request with arbitrary body returning *PermitModUserResponse
func (c *ClientWithResponses) PermitModUserWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitModUserResponse, error) {
	rsp, err := c.PermitModUserWithBody(ctx, modId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitModUserResponse(rsp)
}

func (c *ClientWithResponses) PermitModUserWithResponse(ctx context.Context, modId string, body PermitModUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitModUserResponse, error) {
	rsp, err := c.PermitModUser(ctx, modId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitModUserResponse(rsp)
}

// ListVersionsWithResponse request returning *ListVersionsResponse
func (c *ClientWithResponses) ListVersionsWithResponse(ctx context.Context, modId string, params *ListVersionsParams, reqEditors ...RequestEditorFn) (*ListVersionsResponse, error) {
	rsp, err := c.ListVersions(ctx, modId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVersionsResponse(rsp)
}

// CreateVersionWithBodyWithResponse request with arbitrary body returning *CreateVersionResponse
func (c *ClientWithResponses) CreateVersionWithBodyWithResponse(ctx context.Context, modId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVersionResponse, error) {
	rsp, err := c.CreateVersionWithBody(ctx, modId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVersionResponse(rsp)
}

func (c *ClientWithResponses) CreateVersionWithResponse(ctx context.Context, modId string, body CreateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVersionResponse, error) {
	rsp, err := c.CreateVersion(ctx, modId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVersionResponse(rsp)
}

// DeleteVersionWithResponse request returning *DeleteVersionResponse
func (c *ClientWithResponses) DeleteVersionWithResponse(ctx context.Context, modId string, versionId string, reqEditors ...RequestEditorFn) (*DeleteVersionResponse, error) {
	rsp, err := c.DeleteVersion(ctx, modId, versionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVersionResponse(rsp)
}

// ShowVersionWithResponse request returning *ShowVersionResponse
func (c *ClientWithResponses) ShowVersionWithResponse(ctx context.Context, modId string, versionId string, reqEditors ...RequestEditorFn) (*ShowVersionResponse, error) {
	rsp, err := c.ShowVersion(ctx, modId, versionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowVersionResponse(rsp)
}

// UpdateVersionWithBodyWithResponse request with arbitrary body returning *UpdateVersionResponse
func (c *ClientWithResponses) UpdateVersionWithBodyWithResponse(ctx context.Context, modId string, versionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateVersionResponse, error) {
	rsp, err := c.UpdateVersionWithBody(ctx, modId, versionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVersionResponse(rsp)
}

func (c *ClientWithResponses) UpdateVersionWithResponse(ctx context.Context, modId string, versionId string, body UpdateVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateVersionResponse, error) {
	rsp, err := c.UpdateVersion(ctx, modId, versionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateVersionResponse(rsp)
}

// DeleteVersionFromBuildWithBodyWithResponse request with arbitrary body returning *DeleteVersionFromBuildResponse
func (c *ClientWithResponses) DeleteVersionFromBuildWithBodyWithResponse(ctx context.Context, modId string, versionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteVersionFromBuildResponse, error) {
	rsp, err := c.DeleteVersionFromBuildWithBody(ctx, modId, versionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVersionFromBuildResponse(rsp)
}

func (c *ClientWithResponses) DeleteVersionFromBuildWithResponse(ctx context.Context, modId string, versionId string, body DeleteVersionFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteVersionFromBuildResponse, error) {
	rsp, err := c.DeleteVersionFromBuild(ctx, modId, versionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVersionFromBuildResponse(rsp)
}

// ListVersionBuildsWithResponse request returning *ListVersionBuildsResponse
func (c *ClientWithResponses) ListVersionBuildsWithResponse(ctx context.Context, modId string, versionId string, params *ListVersionBuildsParams, reqEditors ...RequestEditorFn) (*ListVersionBuildsResponse, error) {
	rsp, err := c.ListVersionBuilds(ctx, modId, versionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVersionBuildsResponse(rsp)
}

// AttachVersionToBuildWithBodyWithResponse request with arbitrary body returning *AttachVersionToBuildResponse
func (c *ClientWithResponses) AttachVersionToBuildWithBodyWithResponse(ctx context.Context, modId string, versionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachVersionToBuildResponse, error) {
	rsp, err := c.AttachVersionToBuildWithBody(ctx, modId, versionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachVersionToBuildResponse(rsp)
}

func (c *ClientWithResponses) AttachVersionToBuildWithResponse(ctx context.Context, modId string, versionId string, body AttachVersionToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachVersionToBuildResponse, error) {
	rsp, err := c.AttachVersionToBuild(ctx, modId, versionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachVersionToBuildResponse(rsp)
}

// ListNeoforgesWithResponse request returning *ListNeoforgesResponse
func (c *ClientWithResponses) ListNeoforgesWithResponse(ctx context.Context, params *ListNeoforgesParams, reqEditors ...RequestEditorFn) (*ListNeoforgesResponse, error) {
	rsp, err := c.ListNeoforges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNeoforgesResponse(rsp)
}

// UpdateNeoforgeWithResponse request returning *UpdateNeoforgeResponse
func (c *ClientWithResponses) UpdateNeoforgeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateNeoforgeResponse, error) {
	rsp, err := c.UpdateNeoforge(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNeoforgeResponse(rsp)
}

// DeleteNeoforgeFromBuildWithBodyWithResponse request with arbitrary body returning *DeleteNeoforgeFromBuildResponse
func (c *ClientWithResponses) DeleteNeoforgeFromBuildWithBodyWithResponse(ctx context.Context, neoforgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteNeoforgeFromBuildResponse, error) {
	rsp, err := c.DeleteNeoforgeFromBuildWithBody(ctx, neoforgeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNeoforgeFromBuildResponse(rsp)
}

func (c *ClientWithResponses) DeleteNeoforgeFromBuildWithResponse(ctx context.Context, neoforgeId string, body DeleteNeoforgeFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteNeoforgeFromBuildResponse, error) {
	rsp, err := c.DeleteNeoforgeFromBuild(ctx, neoforgeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNeoforgeFromBuildResponse(rsp)
}

// ListNeoforgeBuildsWithResponse request returning *ListNeoforgeBuildsResponse
func (c *ClientWithResponses) ListNeoforgeBuildsWithResponse(ctx context.Context, neoforgeId string, params *ListNeoforgeBuildsParams, reqEditors ...RequestEditorFn) (*ListNeoforgeBuildsResponse, error) {
	rsp, err := c.ListNeoforgeBuilds(ctx, neoforgeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNeoforgeBuildsResponse(rsp)
}

// AttachNeoforgeToBuildWithBodyWithResponse request with arbitrary body returning *AttachNeoforgeToBuildResponse
func (c *ClientWithResponses) AttachNeoforgeToBuildWithBodyWithResponse(ctx context.Context, neoforgeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachNeoforgeToBuildResponse, error) {
	rsp, err := c.AttachNeoforgeToBuildWithBody(ctx, neoforgeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachNeoforgeToBuildResponse(rsp)
}

func (c *ClientWithResponses) AttachNeoforgeToBuildWithResponse(ctx context.Context, neoforgeId string, body AttachNeoforgeToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachNeoforgeToBuildResponse, error) {
	rsp, err := c.AttachNeoforgeToBuild(ctx, neoforgeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachNeoforgeToBuildResponse(rsp)
}

// ListPacksWithResponse request returning *ListPacksResponse
func (c *ClientWithResponses) ListPacksWithResponse(ctx context.Context, params *ListPacksParams, reqEditors ...RequestEditorFn) (*ListPacksResponse, error) {
	rsp, err := c.ListPacks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPacksResponse(rsp)
}

// CreatePackWithBodyWithResponse request with arbitrary body returning *CreatePackResponse
func (c *ClientWithResponses) CreatePackWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePackResponse, error) {
	rsp, err := c.CreatePackWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePackResponse(rsp)
}

func (c *ClientWithResponses) CreatePackWithResponse(ctx context.Context, body CreatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePackResponse, error) {
	rsp, err := c.CreatePack(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePackResponse(rsp)
}

// DeletePackWithResponse request returning *DeletePackResponse
func (c *ClientWithResponses) DeletePackWithResponse(ctx context.Context, packId string, reqEditors ...RequestEditorFn) (*DeletePackResponse, error) {
	rsp, err := c.DeletePack(ctx, packId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackResponse(rsp)
}

// ShowPackWithResponse request returning *ShowPackResponse
func (c *ClientWithResponses) ShowPackWithResponse(ctx context.Context, packId string, reqEditors ...RequestEditorFn) (*ShowPackResponse, error) {
	rsp, err := c.ShowPack(ctx, packId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowPackResponse(rsp)
}

// UpdatePackWithBodyWithResponse request with arbitrary body returning *UpdatePackResponse
func (c *ClientWithResponses) UpdatePackWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePackResponse, error) {
	rsp, err := c.UpdatePackWithBody(ctx, packId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePackResponse(rsp)
}

func (c *ClientWithResponses) UpdatePackWithResponse(ctx context.Context, packId string, body UpdatePackJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePackResponse, error) {
	rsp, err := c.UpdatePack(ctx, packId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePackResponse(rsp)
}

// ListBuildsWithResponse request returning *ListBuildsResponse
func (c *ClientWithResponses) ListBuildsWithResponse(ctx context.Context, packId string, params *ListBuildsParams, reqEditors ...RequestEditorFn) (*ListBuildsResponse, error) {
	rsp, err := c.ListBuilds(ctx, packId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBuildsResponse(rsp)
}

// CreateBuildWithBodyWithResponse request with arbitrary body returning *CreateBuildResponse
func (c *ClientWithResponses) CreateBuildWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBuildResponse, error) {
	rsp, err := c.CreateBuildWithBody(ctx, packId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBuildResponse(rsp)
}

func (c *ClientWithResponses) CreateBuildWithResponse(ctx context.Context, packId string, body CreateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBuildResponse, error) {
	rsp, err := c.CreateBuild(ctx, packId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBuildResponse(rsp)
}

// DeleteBuildWithResponse request returning *DeleteBuildResponse
func (c *ClientWithResponses) DeleteBuildWithResponse(ctx context.Context, packId string, buildId string, reqEditors ...RequestEditorFn) (*DeleteBuildResponse, error) {
	rsp, err := c.DeleteBuild(ctx, packId, buildId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBuildResponse(rsp)
}

// ShowBuildWithResponse request returning *ShowBuildResponse
func (c *ClientWithResponses) ShowBuildWithResponse(ctx context.Context, packId string, buildId string, reqEditors ...RequestEditorFn) (*ShowBuildResponse, error) {
	rsp, err := c.ShowBuild(ctx, packId, buildId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowBuildResponse(rsp)
}

// UpdateBuildWithBodyWithResponse request with arbitrary body returning *UpdateBuildResponse
func (c *ClientWithResponses) UpdateBuildWithBodyWithResponse(ctx context.Context, packId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBuildResponse, error) {
	rsp, err := c.UpdateBuildWithBody(ctx, packId, buildId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBuildResponse(rsp)
}

func (c *ClientWithResponses) UpdateBuildWithResponse(ctx context.Context, packId string, buildId string, body UpdateBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBuildResponse, error) {
	rsp, err := c.UpdateBuild(ctx, packId, buildId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBuildResponse(rsp)
}

// DeleteBuildFromVersionWithBodyWithResponse request with arbitrary body returning *DeleteBuildFromVersionResponse
func (c *ClientWithResponses) DeleteBuildFromVersionWithBodyWithResponse(ctx context.Context, packId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteBuildFromVersionResponse, error) {
	rsp, err := c.DeleteBuildFromVersionWithBody(ctx, packId, buildId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBuildFromVersionResponse(rsp)
}

func (c *ClientWithResponses) DeleteBuildFromVersionWithResponse(ctx context.Context, packId string, buildId string, body DeleteBuildFromVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteBuildFromVersionResponse, error) {
	rsp, err := c.DeleteBuildFromVersion(ctx, packId, buildId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBuildFromVersionResponse(rsp)
}

// ListBuildVersionsWithResponse request returning *ListBuildVersionsResponse
func (c *ClientWithResponses) ListBuildVersionsWithResponse(ctx context.Context, packId string, buildId string, params *ListBuildVersionsParams, reqEditors ...RequestEditorFn) (*ListBuildVersionsResponse, error) {
	rsp, err := c.ListBuildVersions(ctx, packId, buildId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBuildVersionsResponse(rsp)
}

// AttachBuildToVersionWithBodyWithResponse request with arbitrary body returning *AttachBuildToVersionResponse
func (c *ClientWithResponses) AttachBuildToVersionWithBodyWithResponse(ctx context.Context, packId string, buildId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachBuildToVersionResponse, error) {
	rsp, err := c.AttachBuildToVersionWithBody(ctx, packId, buildId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachBuildToVersionResponse(rsp)
}

func (c *ClientWithResponses) AttachBuildToVersionWithResponse(ctx context.Context, packId string, buildId string, body AttachBuildToVersionJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachBuildToVersionResponse, error) {
	rsp, err := c.AttachBuildToVersion(ctx, packId, buildId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachBuildToVersionResponse(rsp)
}

// DeletePackFromTeamWithBodyWithResponse request with arbitrary body returning *DeletePackFromTeamResponse
func (c *ClientWithResponses) DeletePackFromTeamWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePackFromTeamResponse, error) {
	rsp, err := c.DeletePackFromTeamWithBody(ctx, packId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackFromTeamResponse(rsp)
}

func (c *ClientWithResponses) DeletePackFromTeamWithResponse(ctx context.Context, packId string, body DeletePackFromTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePackFromTeamResponse, error) {
	rsp, err := c.DeletePackFromTeam(ctx, packId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackFromTeamResponse(rsp)
}

// ListPackTeamsWithResponse request returning *ListPackTeamsResponse
func (c *ClientWithResponses) ListPackTeamsWithResponse(ctx context.Context, packId string, params *ListPackTeamsParams, reqEditors ...RequestEditorFn) (*ListPackTeamsResponse, error) {
	rsp, err := c.ListPackTeams(ctx, packId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPackTeamsResponse(rsp)
}

// AttachPackToTeamWithBodyWithResponse request with arbitrary body returning *AttachPackToTeamResponse
func (c *ClientWithResponses) AttachPackToTeamWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachPackToTeamResponse, error) {
	rsp, err := c.AttachPackToTeamWithBody(ctx, packId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPackToTeamResponse(rsp)
}

func (c *ClientWithResponses) AttachPackToTeamWithResponse(ctx context.Context, packId string, body AttachPackToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachPackToTeamResponse, error) {
	rsp, err := c.AttachPackToTeam(ctx, packId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPackToTeamResponse(rsp)
}

// PermitPackTeamWithBodyWithResponse request with arbitrary body returning *PermitPackTeamResponse
func (c *ClientWithResponses) PermitPackTeamWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitPackTeamResponse, error) {
	rsp, err := c.PermitPackTeamWithBody(ctx, packId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitPackTeamResponse(rsp)
}

func (c *ClientWithResponses) PermitPackTeamWithResponse(ctx context.Context, packId string, body PermitPackTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitPackTeamResponse, error) {
	rsp, err := c.PermitPackTeam(ctx, packId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitPackTeamResponse(rsp)
}

// DeletePackFromUserWithBodyWithResponse request with arbitrary body returning *DeletePackFromUserResponse
func (c *ClientWithResponses) DeletePackFromUserWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePackFromUserResponse, error) {
	rsp, err := c.DeletePackFromUserWithBody(ctx, packId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackFromUserResponse(rsp)
}

func (c *ClientWithResponses) DeletePackFromUserWithResponse(ctx context.Context, packId string, body DeletePackFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePackFromUserResponse, error) {
	rsp, err := c.DeletePackFromUser(ctx, packId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackFromUserResponse(rsp)
}

// ListPackUsersWithResponse request returning *ListPackUsersResponse
func (c *ClientWithResponses) ListPackUsersWithResponse(ctx context.Context, packId string, params *ListPackUsersParams, reqEditors ...RequestEditorFn) (*ListPackUsersResponse, error) {
	rsp, err := c.ListPackUsers(ctx, packId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPackUsersResponse(rsp)
}

// AttachPackToUserWithBodyWithResponse request with arbitrary body returning *AttachPackToUserResponse
func (c *ClientWithResponses) AttachPackToUserWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachPackToUserResponse, error) {
	rsp, err := c.AttachPackToUserWithBody(ctx, packId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPackToUserResponse(rsp)
}

func (c *ClientWithResponses) AttachPackToUserWithResponse(ctx context.Context, packId string, body AttachPackToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachPackToUserResponse, error) {
	rsp, err := c.AttachPackToUser(ctx, packId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachPackToUserResponse(rsp)
}

// PermitPackUserWithBodyWithResponse request with arbitrary body returning *PermitPackUserResponse
func (c *ClientWithResponses) PermitPackUserWithBodyWithResponse(ctx context.Context, packId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitPackUserResponse, error) {
	rsp, err := c.PermitPackUserWithBody(ctx, packId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitPackUserResponse(rsp)
}

func (c *ClientWithResponses) PermitPackUserWithResponse(ctx context.Context, packId string, body PermitPackUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitPackUserResponse, error) {
	rsp, err := c.PermitPackUser(ctx, packId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitPackUserResponse(rsp)
}

// ShowProfileWithResponse request returning *ShowProfileResponse
func (c *ClientWithResponses) ShowProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ShowProfileResponse, error) {
	rsp, err := c.ShowProfile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowProfileResponse(rsp)
}

// UpdateProfileWithBodyWithResponse request with arbitrary body returning *UpdateProfileResponse
func (c *ClientWithResponses) UpdateProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error) {
	rsp, err := c.UpdateProfileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProfileResponse(rsp)
}

func (c *ClientWithResponses) UpdateProfileWithResponse(ctx context.Context, body UpdateProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProfileResponse, error) {
	rsp, err := c.UpdateProfile(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProfileResponse(rsp)
}

// TokenProfileWithResponse request returning *TokenProfileResponse
func (c *ClientWithResponses) TokenProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TokenProfileResponse, error) {
	rsp, err := c.TokenProfile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenProfileResponse(rsp)
}

// ListQuiltsWithResponse request returning *ListQuiltsResponse
func (c *ClientWithResponses) ListQuiltsWithResponse(ctx context.Context, params *ListQuiltsParams, reqEditors ...RequestEditorFn) (*ListQuiltsResponse, error) {
	rsp, err := c.ListQuilts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListQuiltsResponse(rsp)
}

// UpdateQuiltWithResponse request returning *UpdateQuiltResponse
func (c *ClientWithResponses) UpdateQuiltWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UpdateQuiltResponse, error) {
	rsp, err := c.UpdateQuilt(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateQuiltResponse(rsp)
}

// DeleteQuiltFromBuildWithBodyWithResponse request with arbitrary body returning *DeleteQuiltFromBuildResponse
func (c *ClientWithResponses) DeleteQuiltFromBuildWithBodyWithResponse(ctx context.Context, quiltId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteQuiltFromBuildResponse, error) {
	rsp, err := c.DeleteQuiltFromBuildWithBody(ctx, quiltId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteQuiltFromBuildResponse(rsp)
}

func (c *ClientWithResponses) DeleteQuiltFromBuildWithResponse(ctx context.Context, quiltId string, body DeleteQuiltFromBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteQuiltFromBuildResponse, error) {
	rsp, err := c.DeleteQuiltFromBuild(ctx, quiltId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteQuiltFromBuildResponse(rsp)
}

// ListQuiltBuildsWithResponse request returning *ListQuiltBuildsResponse
func (c *ClientWithResponses) ListQuiltBuildsWithResponse(ctx context.Context, quiltId string, params *ListQuiltBuildsParams, reqEditors ...RequestEditorFn) (*ListQuiltBuildsResponse, error) {
	rsp, err := c.ListQuiltBuilds(ctx, quiltId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListQuiltBuildsResponse(rsp)
}

// AttachQuiltToBuildWithBodyWithResponse request with arbitrary body returning *AttachQuiltToBuildResponse
func (c *ClientWithResponses) AttachQuiltToBuildWithBodyWithResponse(ctx context.Context, quiltId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachQuiltToBuildResponse, error) {
	rsp, err := c.AttachQuiltToBuildWithBody(ctx, quiltId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachQuiltToBuildResponse(rsp)
}

func (c *ClientWithResponses) AttachQuiltToBuildWithResponse(ctx context.Context, quiltId string, body AttachQuiltToBuildJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachQuiltToBuildResponse, error) {
	rsp, err := c.AttachQuiltToBuild(ctx, quiltId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachQuiltToBuildResponse(rsp)
}

// ListTeamsWithResponse request returning *ListTeamsResponse
func (c *ClientWithResponses) ListTeamsWithResponse(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*ListTeamsResponse, error) {
	rsp, err := c.ListTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTeamsResponse(rsp)
}

// CreateTeamWithBodyWithResponse request with arbitrary body returning *CreateTeamResponse
func (c *ClientWithResponses) CreateTeamWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error) {
	rsp, err := c.CreateTeamWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamResponse(rsp)
}

func (c *ClientWithResponses) CreateTeamWithResponse(ctx context.Context, body CreateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamResponse, error) {
	rsp, err := c.CreateTeam(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamResponse(rsp)
}

// DeleteTeamWithResponse request returning *DeleteTeamResponse
func (c *ClientWithResponses) DeleteTeamWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*DeleteTeamResponse, error) {
	rsp, err := c.DeleteTeam(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamResponse(rsp)
}

// ShowTeamWithResponse request returning *ShowTeamResponse
func (c *ClientWithResponses) ShowTeamWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*ShowTeamResponse, error) {
	rsp, err := c.ShowTeam(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowTeamResponse(rsp)
}

// UpdateTeamWithBodyWithResponse request with arbitrary body returning *UpdateTeamResponse
func (c *ClientWithResponses) UpdateTeamWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error) {
	rsp, err := c.UpdateTeamWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamResponse(rsp)
}

func (c *ClientWithResponses) UpdateTeamWithResponse(ctx context.Context, teamId string, body UpdateTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamResponse, error) {
	rsp, err := c.UpdateTeam(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamResponse(rsp)
}

// DeleteTeamFromModWithBodyWithResponse request with arbitrary body returning *DeleteTeamFromModResponse
func (c *ClientWithResponses) DeleteTeamFromModWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTeamFromModResponse, error) {
	rsp, err := c.DeleteTeamFromModWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamFromModResponse(rsp)
}

func (c *ClientWithResponses) DeleteTeamFromModWithResponse(ctx context.Context, teamId string, body DeleteTeamFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTeamFromModResponse, error) {
	rsp, err := c.DeleteTeamFromMod(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamFromModResponse(rsp)
}

// ListTeamModsWithResponse request returning *ListTeamModsResponse
func (c *ClientWithResponses) ListTeamModsWithResponse(ctx context.Context, teamId string, params *ListTeamModsParams, reqEditors ...RequestEditorFn) (*ListTeamModsResponse, error) {
	rsp, err := c.ListTeamMods(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTeamModsResponse(rsp)
}

// AttachTeamToModWithBodyWithResponse request with arbitrary body returning *AttachTeamToModResponse
func (c *ClientWithResponses) AttachTeamToModWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachTeamToModResponse, error) {
	rsp, err := c.AttachTeamToModWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachTeamToModResponse(rsp)
}

func (c *ClientWithResponses) AttachTeamToModWithResponse(ctx context.Context, teamId string, body AttachTeamToModJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachTeamToModResponse, error) {
	rsp, err := c.AttachTeamToMod(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachTeamToModResponse(rsp)
}

// PermitTeamModWithBodyWithResponse request with arbitrary body returning *PermitTeamModResponse
func (c *ClientWithResponses) PermitTeamModWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitTeamModResponse, error) {
	rsp, err := c.PermitTeamModWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitTeamModResponse(rsp)
}

func (c *ClientWithResponses) PermitTeamModWithResponse(ctx context.Context, teamId string, body PermitTeamModJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitTeamModResponse, error) {
	rsp, err := c.PermitTeamMod(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitTeamModResponse(rsp)
}

// DeleteTeamFromPackWithBodyWithResponse request with arbitrary body returning *DeleteTeamFromPackResponse
func (c *ClientWithResponses) DeleteTeamFromPackWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTeamFromPackResponse, error) {
	rsp, err := c.DeleteTeamFromPackWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamFromPackResponse(rsp)
}

func (c *ClientWithResponses) DeleteTeamFromPackWithResponse(ctx context.Context, teamId string, body DeleteTeamFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTeamFromPackResponse, error) {
	rsp, err := c.DeleteTeamFromPack(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamFromPackResponse(rsp)
}

// ListTeamPacksWithResponse request returning *ListTeamPacksResponse
func (c *ClientWithResponses) ListTeamPacksWithResponse(ctx context.Context, teamId string, params *ListTeamPacksParams, reqEditors ...RequestEditorFn) (*ListTeamPacksResponse, error) {
	rsp, err := c.ListTeamPacks(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTeamPacksResponse(rsp)
}

// AttachTeamToPackWithBodyWithResponse request with arbitrary body returning *AttachTeamToPackResponse
func (c *ClientWithResponses) AttachTeamToPackWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachTeamToPackResponse, error) {
	rsp, err := c.AttachTeamToPackWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachTeamToPackResponse(rsp)
}

func (c *ClientWithResponses) AttachTeamToPackWithResponse(ctx context.Context, teamId string, body AttachTeamToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachTeamToPackResponse, error) {
	rsp, err := c.AttachTeamToPack(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachTeamToPackResponse(rsp)
}

// PermitTeamPackWithBodyWithResponse request with arbitrary body returning *PermitTeamPackResponse
func (c *ClientWithResponses) PermitTeamPackWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitTeamPackResponse, error) {
	rsp, err := c.PermitTeamPackWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitTeamPackResponse(rsp)
}

func (c *ClientWithResponses) PermitTeamPackWithResponse(ctx context.Context, teamId string, body PermitTeamPackJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitTeamPackResponse, error) {
	rsp, err := c.PermitTeamPack(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitTeamPackResponse(rsp)
}

// DeleteTeamFromUserWithBodyWithResponse request with arbitrary body returning *DeleteTeamFromUserResponse
func (c *ClientWithResponses) DeleteTeamFromUserWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTeamFromUserResponse, error) {
	rsp, err := c.DeleteTeamFromUserWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamFromUserResponse(rsp)
}

func (c *ClientWithResponses) DeleteTeamFromUserWithResponse(ctx context.Context, teamId string, body DeleteTeamFromUserJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTeamFromUserResponse, error) {
	rsp, err := c.DeleteTeamFromUser(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamFromUserResponse(rsp)
}

// ListTeamUsersWithResponse request returning *ListTeamUsersResponse
func (c *ClientWithResponses) ListTeamUsersWithResponse(ctx context.Context, teamId string, params *ListTeamUsersParams, reqEditors ...RequestEditorFn) (*ListTeamUsersResponse, error) {
	rsp, err := c.ListTeamUsers(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTeamUsersResponse(rsp)
}

// AttachTeamToUserWithBodyWithResponse request with arbitrary body returning *AttachTeamToUserResponse
func (c *ClientWithResponses) AttachTeamToUserWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachTeamToUserResponse, error) {
	rsp, err := c.AttachTeamToUserWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachTeamToUserResponse(rsp)
}

func (c *ClientWithResponses) AttachTeamToUserWithResponse(ctx context.Context, teamId string, body AttachTeamToUserJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachTeamToUserResponse, error) {
	rsp, err := c.AttachTeamToUser(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachTeamToUserResponse(rsp)
}

// PermitTeamUserWithBodyWithResponse request with arbitrary body returning *PermitTeamUserResponse
func (c *ClientWithResponses) PermitTeamUserWithBodyWithResponse(ctx context.Context, teamId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitTeamUserResponse, error) {
	rsp, err := c.PermitTeamUserWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitTeamUserResponse(rsp)
}

func (c *ClientWithResponses) PermitTeamUserWithResponse(ctx context.Context, teamId string, body PermitTeamUserJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitTeamUserResponse, error) {
	rsp, err := c.PermitTeamUser(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitTeamUserResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// ShowUserWithResponse request returning *ShowUserResponse
func (c *ClientWithResponses) ShowUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*ShowUserResponse, error) {
	rsp, err := c.ShowUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// DeleteUserFromModWithBodyWithResponse request with arbitrary body returning *DeleteUserFromModResponse
func (c *ClientWithResponses) DeleteUserFromModWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromModResponse, error) {
	rsp, err := c.DeleteUserFromModWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromModResponse(rsp)
}

func (c *ClientWithResponses) DeleteUserFromModWithResponse(ctx context.Context, userId string, body DeleteUserFromModJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromModResponse, error) {
	rsp, err := c.DeleteUserFromMod(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromModResponse(rsp)
}

// ListUserModsWithResponse request returning *ListUserModsResponse
func (c *ClientWithResponses) ListUserModsWithResponse(ctx context.Context, userId string, params *ListUserModsParams, reqEditors ...RequestEditorFn) (*ListUserModsResponse, error) {
	rsp, err := c.ListUserMods(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserModsResponse(rsp)
}

// AttachUserToModWithBodyWithResponse request with arbitrary body returning *AttachUserToModResponse
func (c *ClientWithResponses) AttachUserToModWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToModResponse, error) {
	rsp, err := c.AttachUserToModWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToModResponse(rsp)
}

func (c *ClientWithResponses) AttachUserToModWithResponse(ctx context.Context, userId string, body AttachUserToModJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToModResponse, error) {
	rsp, err := c.AttachUserToMod(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToModResponse(rsp)
}

// PermitUserModWithBodyWithResponse request with arbitrary body returning *PermitUserModResponse
func (c *ClientWithResponses) PermitUserModWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserModResponse, error) {
	rsp, err := c.PermitUserModWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserModResponse(rsp)
}

func (c *ClientWithResponses) PermitUserModWithResponse(ctx context.Context, userId string, body PermitUserModJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserModResponse, error) {
	rsp, err := c.PermitUserMod(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserModResponse(rsp)
}

// DeleteUserFromPackWithBodyWithResponse request with arbitrary body returning *DeleteUserFromPackResponse
func (c *ClientWithResponses) DeleteUserFromPackWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromPackResponse, error) {
	rsp, err := c.DeleteUserFromPackWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromPackResponse(rsp)
}

func (c *ClientWithResponses) DeleteUserFromPackWithResponse(ctx context.Context, userId string, body DeleteUserFromPackJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromPackResponse, error) {
	rsp, err := c.DeleteUserFromPack(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromPackResponse(rsp)
}

// ListUserPacksWithResponse request returning *ListUserPacksResponse
func (c *ClientWithResponses) ListUserPacksWithResponse(ctx context.Context, userId string, params *ListUserPacksParams, reqEditors ...RequestEditorFn) (*ListUserPacksResponse, error) {
	rsp, err := c.ListUserPacks(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserPacksResponse(rsp)
}

// AttachUserToPackWithBodyWithResponse request with arbitrary body returning *AttachUserToPackResponse
func (c *ClientWithResponses) AttachUserToPackWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToPackResponse, error) {
	rsp, err := c.AttachUserToPackWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToPackResponse(rsp)
}

func (c *ClientWithResponses) AttachUserToPackWithResponse(ctx context.Context, userId string, body AttachUserToPackJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToPackResponse, error) {
	rsp, err := c.AttachUserToPack(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToPackResponse(rsp)
}

// PermitUserPackWithBodyWithResponse request with arbitrary body returning *PermitUserPackResponse
func (c *ClientWithResponses) PermitUserPackWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserPackResponse, error) {
	rsp, err := c.PermitUserPackWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserPackResponse(rsp)
}

func (c *ClientWithResponses) PermitUserPackWithResponse(ctx context.Context, userId string, body PermitUserPackJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserPackResponse, error) {
	rsp, err := c.PermitUserPack(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserPackResponse(rsp)
}

// DeleteUserFromTeamWithBodyWithResponse request with arbitrary body returning *DeleteUserFromTeamResponse
func (c *ClientWithResponses) DeleteUserFromTeamWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUserFromTeamResponse, error) {
	rsp, err := c.DeleteUserFromTeamWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromTeamResponse(rsp)
}

func (c *ClientWithResponses) DeleteUserFromTeamWithResponse(ctx context.Context, userId string, body DeleteUserFromTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUserFromTeamResponse, error) {
	rsp, err := c.DeleteUserFromTeam(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserFromTeamResponse(rsp)
}

// ListUserTeamsWithResponse request returning *ListUserTeamsResponse
func (c *ClientWithResponses) ListUserTeamsWithResponse(ctx context.Context, userId string, params *ListUserTeamsParams, reqEditors ...RequestEditorFn) (*ListUserTeamsResponse, error) {
	rsp, err := c.ListUserTeams(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserTeamsResponse(rsp)
}

// AttachUserToTeamWithBodyWithResponse request with arbitrary body returning *AttachUserToTeamResponse
func (c *ClientWithResponses) AttachUserToTeamWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AttachUserToTeamResponse, error) {
	rsp, err := c.AttachUserToTeamWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToTeamResponse(rsp)
}

func (c *ClientWithResponses) AttachUserToTeamWithResponse(ctx context.Context, userId string, body AttachUserToTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*AttachUserToTeamResponse, error) {
	rsp, err := c.AttachUserToTeam(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAttachUserToTeamResponse(rsp)
}

// PermitUserTeamWithBodyWithResponse request with arbitrary body returning *PermitUserTeamResponse
func (c *ClientWithResponses) PermitUserTeamWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PermitUserTeamResponse, error) {
	rsp, err := c.PermitUserTeamWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserTeamResponse(rsp)
}

func (c *ClientWithResponses) PermitUserTeamWithResponse(ctx context.Context, userId string, body PermitUserTeamJSONRequestBody, reqEditors ...RequestEditorFn) (*PermitUserTeamResponse, error) {
	rsp, err := c.PermitUserTeam(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePermitUserTeamResponse(rsp)
}

// ParseLoginAuthResponse parses an HTTP response from a LoginAuthWithResponse call
func ParseLoginAuthResponse(rsp *http.Response) (*LoginAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExternalProvidersResponse parses an HTTP response from a ExternalProvidersWithResponse call
func ParseExternalProvidersResponse(rsp *http.Response) (*ExternalProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExternalProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Providers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRefreshAuthResponse parses an HTTP response from a RefreshAuthWithResponse call
func ParseRefreshAuthResponse(rsp *http.Response) (*RefreshAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseVerifyAuthResponse parses an HTTP response from a VerifyAuthWithResponse call
func ParseVerifyAuthResponse(rsp *http.Response) (*VerifyAuthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyAuthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthVerify
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExternalCallbackResponse parses an HTTP response from a ExternalCallbackWithResponse call
func ParseExternalCallbackResponse(rsp *http.Response) (*ExternalCallbackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExternalCallbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExternalInitializeResponse parses an HTTP response from a ExternalInitializeWithResponse call
func ParseExternalInitializeResponse(rsp *http.Response) (*ExternalInitializeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExternalInitializeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListFabricsResponse parses an HTTP response from a ListFabricsWithResponse call
func ParseListFabricsResponse(rsp *http.Response) (*ListFabricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFabricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Fabrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateFabricResponse parses an HTTP response from a UpdateFabricWithResponse call
func ParseUpdateFabricResponse(rsp *http.Response) (*UpdateFabricResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFabricResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFabricFromBuildResponse parses an HTTP response from a DeleteFabricFromBuildWithResponse call
func ParseDeleteFabricFromBuildResponse(rsp *http.Response) (*DeleteFabricFromBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFabricFromBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListFabricBuildsResponse parses an HTTP response from a ListFabricBuildsWithResponse call
func ParseListFabricBuildsResponse(rsp *http.Response) (*ListFabricBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFabricBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FabricBuilds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachFabricToBuildResponse parses an HTTP response from a AttachFabricToBuildWithResponse call
func ParseAttachFabricToBuildResponse(rsp *http.Response) (*AttachFabricToBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachFabricToBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListForgesResponse parses an HTTP response from a ListForgesWithResponse call
func ParseListForgesResponse(rsp *http.Response) (*ListForgesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListForgesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Forges
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateForgeResponse parses an HTTP response from a UpdateForgeWithResponse call
func ParseUpdateForgeResponse(rsp *http.Response) (*UpdateForgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateForgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteForgeFromBuildResponse parses an HTTP response from a DeleteForgeFromBuildWithResponse call
func ParseDeleteForgeFromBuildResponse(rsp *http.Response) (*DeleteForgeFromBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteForgeFromBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListForgeBuildsResponse parses an HTTP response from a ListForgeBuildsWithResponse call
func ParseListForgeBuildsResponse(rsp *http.Response) (*ListForgeBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListForgeBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ForgeBuilds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachForgeToBuildResponse parses an HTTP response from a AttachForgeToBuildWithResponse call
func ParseAttachForgeToBuildResponse(rsp *http.Response) (*AttachForgeToBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachForgeToBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListMinecraftsResponse parses an HTTP response from a ListMinecraftsWithResponse call
func ParseListMinecraftsResponse(rsp *http.Response) (*ListMinecraftsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMinecraftsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Minecrafts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateMinecraftResponse parses an HTTP response from a UpdateMinecraftWithResponse call
func ParseUpdateMinecraftResponse(rsp *http.Response) (*UpdateMinecraftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMinecraftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteMinecraftFromBuildResponse parses an HTTP response from a DeleteMinecraftFromBuildWithResponse call
func ParseDeleteMinecraftFromBuildResponse(rsp *http.Response) (*DeleteMinecraftFromBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMinecraftFromBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListMinecraftBuildsResponse parses an HTTP response from a ListMinecraftBuildsWithResponse call
func ParseListMinecraftBuildsResponse(rsp *http.Response) (*ListMinecraftBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMinecraftBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MinecraftBuilds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachMinecraftToBuildResponse parses an HTTP response from a AttachMinecraftToBuildWithResponse call
func ParseAttachMinecraftToBuildResponse(rsp *http.Response) (*AttachMinecraftToBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachMinecraftToBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListModsResponse parses an HTTP response from a ListModsWithResponse call
func ParseListModsResponse(rsp *http.Response) (*ListModsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Mods
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateModResponse parses an HTTP response from a CreateModWithResponse call
func ParseCreateModResponse(rsp *http.Response) (*CreateModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Mod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteModResponse parses an HTTP response from a DeleteModWithResponse call
func ParseDeleteModResponse(rsp *http.Response) (*DeleteModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowModResponse parses an HTTP response from a ShowModWithResponse call
func ParseShowModResponse(rsp *http.Response) (*ShowModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Mod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateModResponse parses an HTTP response from a UpdateModWithResponse call
func ParseUpdateModResponse(rsp *http.Response) (*UpdateModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Mod
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteModFromTeamResponse parses an HTTP response from a DeleteModFromTeamWithResponse call
func ParseDeleteModFromTeamResponse(rsp *http.Response) (*DeleteModFromTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteModFromTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListModTeamsResponse parses an HTTP response from a ListModTeamsWithResponse call
func ParseListModTeamsResponse(rsp *http.Response) (*ListModTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModTeams
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachModToTeamResponse parses an HTTP response from a AttachModToTeamWithResponse call
func ParseAttachModToTeamResponse(rsp *http.Response) (*AttachModToTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachModToTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePermitModTeamResponse parses an HTTP response from a PermitModTeamWithResponse call
func ParsePermitModTeamResponse(rsp *http.Response) (*PermitModTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitModTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteModFromUserResponse parses an HTTP response from a DeleteModFromUserWithResponse call
func ParseDeleteModFromUserResponse(rsp *http.Response) (*DeleteModFromUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteModFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListModUsersResponse parses an HTTP response from a ListModUsersWithResponse call
func ParseListModUsersResponse(rsp *http.Response) (*ListModUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListModUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ModUsers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachModToUserResponse parses an HTTP response from a AttachModToUserWithResponse call
func ParseAttachModToUserResponse(rsp *http.Response) (*AttachModToUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachModToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePermitModUserResponse parses an HTTP response from a PermitModUserWithResponse call
func ParsePermitModUserResponse(rsp *http.Response) (*PermitModUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitModUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListVersionsResponse parses an HTTP response from a ListVersionsWithResponse call
func ParseListVersionsResponse(rsp *http.Response) (*ListVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Versions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateVersionResponse parses an HTTP response from a CreateVersionWithResponse call
func ParseCreateVersionResponse(rsp *http.Response) (*CreateVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Version
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVersionResponse parses an HTTP response from a DeleteVersionWithResponse call
func ParseDeleteVersionResponse(rsp *http.Response) (*DeleteVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowVersionResponse parses an HTTP response from a ShowVersionWithResponse call
func ParseShowVersionResponse(rsp *http.Response) (*ShowVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Version
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateVersionResponse parses an HTTP response from a UpdateVersionWithResponse call
func ParseUpdateVersionResponse(rsp *http.Response) (*UpdateVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Version
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVersionFromBuildResponse parses an HTTP response from a DeleteVersionFromBuildWithResponse call
func ParseDeleteVersionFromBuildResponse(rsp *http.Response) (*DeleteVersionFromBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVersionFromBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListVersionBuildsResponse parses an HTTP response from a ListVersionBuildsWithResponse call
func ParseListVersionBuildsResponse(rsp *http.Response) (*ListVersionBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVersionBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionBuilds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachVersionToBuildResponse parses an HTTP response from a AttachVersionToBuildWithResponse call
func ParseAttachVersionToBuildResponse(rsp *http.Response) (*AttachVersionToBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachVersionToBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListNeoforgesResponse parses an HTTP response from a ListNeoforgesWithResponse call
func ParseListNeoforgesResponse(rsp *http.Response) (*ListNeoforgesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNeoforgesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Neoforges
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateNeoforgeResponse parses an HTTP response from a UpdateNeoforgeWithResponse call
func ParseUpdateNeoforgeResponse(rsp *http.Response) (*UpdateNeoforgeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNeoforgeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteNeoforgeFromBuildResponse parses an HTTP response from a DeleteNeoforgeFromBuildWithResponse call
func ParseDeleteNeoforgeFromBuildResponse(rsp *http.Response) (*DeleteNeoforgeFromBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNeoforgeFromBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListNeoforgeBuildsResponse parses an HTTP response from a ListNeoforgeBuildsWithResponse call
func ParseListNeoforgeBuildsResponse(rsp *http.Response) (*ListNeoforgeBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNeoforgeBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NeoforgeBuilds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachNeoforgeToBuildResponse parses an HTTP response from a AttachNeoforgeToBuildWithResponse call
func ParseAttachNeoforgeToBuildResponse(rsp *http.Response) (*AttachNeoforgeToBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachNeoforgeToBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListPacksResponse parses an HTTP response from a ListPacksWithResponse call
func ParseListPacksResponse(rsp *http.Response) (*ListPacksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPacksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Packs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePackResponse parses an HTTP response from a CreatePackWithResponse call
func ParseCreatePackResponse(rsp *http.Response) (*CreatePackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Pack
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePackResponse parses an HTTP response from a DeletePackWithResponse call
func ParseDeletePackResponse(rsp *http.Response) (*DeletePackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowPackResponse parses an HTTP response from a ShowPackWithResponse call
func ParseShowPackResponse(rsp *http.Response) (*ShowPackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowPackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Pack
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdatePackResponse parses an HTTP response from a UpdatePackWithResponse call
func ParseUpdatePackResponse(rsp *http.Response) (*UpdatePackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Pack
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListBuildsResponse parses an HTTP response from a ListBuildsWithResponse call
func ParseListBuildsResponse(rsp *http.Response) (*ListBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Builds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBuildResponse parses an HTTP response from a CreateBuildWithResponse call
func ParseCreateBuildResponse(rsp *http.Response) (*CreateBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBuildResponse parses an HTTP response from a DeleteBuildWithResponse call
func ParseDeleteBuildResponse(rsp *http.Response) (*DeleteBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowBuildResponse parses an HTTP response from a ShowBuildWithResponse call
func ParseShowBuildResponse(rsp *http.Response) (*ShowBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateBuildResponse parses an HTTP response from a UpdateBuildWithResponse call
func ParseUpdateBuildResponse(rsp *http.Response) (*UpdateBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Build
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBuildFromVersionResponse parses an HTTP response from a DeleteBuildFromVersionWithResponse call
func ParseDeleteBuildFromVersionResponse(rsp *http.Response) (*DeleteBuildFromVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBuildFromVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListBuildVersionsResponse parses an HTTP response from a ListBuildVersionsWithResponse call
func ParseListBuildVersionsResponse(rsp *http.Response) (*ListBuildVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBuildVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BuildVersions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachBuildToVersionResponse parses an HTTP response from a AttachBuildToVersionWithResponse call
func ParseAttachBuildToVersionResponse(rsp *http.Response) (*AttachBuildToVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachBuildToVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePackFromTeamResponse parses an HTTP response from a DeletePackFromTeamWithResponse call
func ParseDeletePackFromTeamResponse(rsp *http.Response) (*DeletePackFromTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePackFromTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListPackTeamsResponse parses an HTTP response from a ListPackTeamsWithResponse call
func ParseListPackTeamsResponse(rsp *http.Response) (*ListPackTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPackTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackTeams
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachPackToTeamResponse parses an HTTP response from a AttachPackToTeamWithResponse call
func ParseAttachPackToTeamResponse(rsp *http.Response) (*AttachPackToTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachPackToTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePermitPackTeamResponse parses an HTTP response from a PermitPackTeamWithResponse call
func ParsePermitPackTeamResponse(rsp *http.Response) (*PermitPackTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitPackTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePackFromUserResponse parses an HTTP response from a DeletePackFromUserWithResponse call
func ParseDeletePackFromUserResponse(rsp *http.Response) (*DeletePackFromUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePackFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListPackUsersResponse parses an HTTP response from a ListPackUsersWithResponse call
func ParseListPackUsersResponse(rsp *http.Response) (*ListPackUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPackUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackUsers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachPackToUserResponse parses an HTTP response from a AttachPackToUserWithResponse call
func ParseAttachPackToUserResponse(rsp *http.Response) (*AttachPackToUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachPackToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePermitPackUserResponse parses an HTTP response from a PermitPackUserWithResponse call
func ParsePermitPackUserResponse(rsp *http.Response) (*PermitPackUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitPackUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowProfileResponse parses an HTTP response from a ShowProfileWithResponse call
func ParseShowProfileResponse(rsp *http.Response) (*ShowProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Profile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateProfileResponse parses an HTTP response from a UpdateProfileWithResponse call
func ParseUpdateProfileResponse(rsp *http.Response) (*UpdateProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Profile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTokenProfileResponse parses an HTTP response from a TokenProfileWithResponse call
func ParseTokenProfileResponse(rsp *http.Response) (*TokenProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokenProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListQuiltsResponse parses an HTTP response from a ListQuiltsWithResponse call
func ParseListQuiltsResponse(rsp *http.Response) (*ListQuiltsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListQuiltsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Quilts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateQuiltResponse parses an HTTP response from a UpdateQuiltWithResponse call
func ParseUpdateQuiltResponse(rsp *http.Response) (*UpdateQuiltResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateQuiltResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteQuiltFromBuildResponse parses an HTTP response from a DeleteQuiltFromBuildWithResponse call
func ParseDeleteQuiltFromBuildResponse(rsp *http.Response) (*DeleteQuiltFromBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteQuiltFromBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListQuiltBuildsResponse parses an HTTP response from a ListQuiltBuildsWithResponse call
func ParseListQuiltBuildsResponse(rsp *http.Response) (*ListQuiltBuildsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListQuiltBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuiltBuilds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachQuiltToBuildResponse parses an HTTP response from a AttachQuiltToBuildWithResponse call
func ParseAttachQuiltToBuildResponse(rsp *http.Response) (*AttachQuiltToBuildResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachQuiltToBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListTeamsResponse parses an HTTP response from a ListTeamsWithResponse call
func ParseListTeamsResponse(rsp *http.Response) (*ListTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Teams
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTeamResponse parses an HTTP response from a CreateTeamWithResponse call
func ParseCreateTeamResponse(rsp *http.Response) (*CreateTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTeamResponse parses an HTTP response from a DeleteTeamWithResponse call
func ParseDeleteTeamResponse(rsp *http.Response) (*DeleteTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowTeamResponse parses an HTTP response from a ShowTeamWithResponse call
func ParseShowTeamResponse(rsp *http.Response) (*ShowTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateTeamResponse parses an HTTP response from a UpdateTeamWithResponse call
func ParseUpdateTeamResponse(rsp *http.Response) (*UpdateTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTeamFromModResponse parses an HTTP response from a DeleteTeamFromModWithResponse call
func ParseDeleteTeamFromModResponse(rsp *http.Response) (*DeleteTeamFromModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTeamFromModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListTeamModsResponse parses an HTTP response from a ListTeamModsWithResponse call
func ParseListTeamModsResponse(rsp *http.Response) (*ListTeamModsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTeamModsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamMods
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachTeamToModResponse parses an HTTP response from a AttachTeamToModWithResponse call
func ParseAttachTeamToModResponse(rsp *http.Response) (*AttachTeamToModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachTeamToModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePermitTeamModResponse parses an HTTP response from a PermitTeamModWithResponse call
func ParsePermitTeamModResponse(rsp *http.Response) (*PermitTeamModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitTeamModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTeamFromPackResponse parses an HTTP response from a DeleteTeamFromPackWithResponse call
func ParseDeleteTeamFromPackResponse(rsp *http.Response) (*DeleteTeamFromPackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTeamFromPackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListTeamPacksResponse parses an HTTP response from a ListTeamPacksWithResponse call
func ParseListTeamPacksResponse(rsp *http.Response) (*ListTeamPacksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTeamPacksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamPacks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachTeamToPackResponse parses an HTTP response from a AttachTeamToPackWithResponse call
func ParseAttachTeamToPackResponse(rsp *http.Response) (*AttachTeamToPackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachTeamToPackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePermitTeamPackResponse parses an HTTP response from a PermitTeamPackWithResponse call
func ParsePermitTeamPackResponse(rsp *http.Response) (*PermitTeamPackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitTeamPackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTeamFromUserResponse parses an HTTP response from a DeleteTeamFromUserWithResponse call
func ParseDeleteTeamFromUserResponse(rsp *http.Response) (*DeleteTeamFromUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTeamFromUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListTeamUsersResponse parses an HTTP response from a ListTeamUsersWithResponse call
func ParseListTeamUsersResponse(rsp *http.Response) (*ListTeamUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTeamUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamUsers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachTeamToUserResponse parses an HTTP response from a AttachTeamToUserWithResponse call
func ParseAttachTeamToUserResponse(rsp *http.Response) (*AttachTeamToUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachTeamToUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePermitTeamUserResponse parses an HTTP response from a PermitTeamUserWithResponse call
func ParsePermitTeamUserResponse(rsp *http.Response) (*PermitTeamUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitTeamUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Users
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowUserResponse parses an HTTP response from a ShowUserWithResponse call
func ParseShowUserResponse(rsp *http.Response) (*ShowUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserFromModResponse parses an HTTP response from a DeleteUserFromModWithResponse call
func ParseDeleteUserFromModResponse(rsp *http.Response) (*DeleteUserFromModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserFromModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserModsResponse parses an HTTP response from a ListUserModsWithResponse call
func ParseListUserModsResponse(rsp *http.Response) (*ListUserModsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserModsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserMods
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachUserToModResponse parses an HTTP response from a AttachUserToModWithResponse call
func ParseAttachUserToModResponse(rsp *http.Response) (*AttachUserToModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachUserToModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePermitUserModResponse parses an HTTP response from a PermitUserModWithResponse call
func ParsePermitUserModResponse(rsp *http.Response) (*PermitUserModResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitUserModResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserFromPackResponse parses an HTTP response from a DeleteUserFromPackWithResponse call
func ParseDeleteUserFromPackResponse(rsp *http.Response) (*DeleteUserFromPackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserFromPackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserPacksResponse parses an HTTP response from a ListUserPacksWithResponse call
func ParseListUserPacksResponse(rsp *http.Response) (*ListUserPacksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserPacksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserPacks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachUserToPackResponse parses an HTTP response from a AttachUserToPackWithResponse call
func ParseAttachUserToPackResponse(rsp *http.Response) (*AttachUserToPackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachUserToPackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePermitUserPackResponse parses an HTTP response from a PermitUserPackWithResponse call
func ParsePermitUserPackResponse(rsp *http.Response) (*PermitUserPackResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitUserPackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserFromTeamResponse parses an HTTP response from a DeleteUserFromTeamWithResponse call
func ParseDeleteUserFromTeamResponse(rsp *http.Response) (*DeleteUserFromTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserFromTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListUserTeamsResponse parses an HTTP response from a ListUserTeamsWithResponse call
func ParseListUserTeamsResponse(rsp *http.Response) (*ListUserTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserTeams
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAttachUserToTeamResponse parses an HTTP response from a AttachUserToTeamWithResponse call
func ParseAttachUserToTeamResponse(rsp *http.Response) (*AttachUserToTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AttachUserToTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePermitUserTeamResponse parses an HTTP response from a PermitUserTeamWithResponse call
func ParsePermitUserTeamResponse(rsp *http.Response) (*PermitUserTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PermitUserTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 412:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON412 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Notification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
